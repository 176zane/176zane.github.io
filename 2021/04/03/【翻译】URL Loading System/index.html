<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原文：URL Loading System 前言南峰子大佬之前有翻译过这个专题:URL加载系统之一：基本结构，但是随着官方文档的更新，这篇编程指南的原文也从苹果的文档中删除了，因此为复习一下网络框架，就顺手把这篇翻译了，以下开始正文。 URL 加载系统使用标准的网络协议通过与 URLs 交互，来与服务器进行交流。 概述URL 加载系统通过使用标准的协议如 https 或者创建的自定义协议提供被 U">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻译】URL Loading System">
<meta property="og:url" content="http://yoursite.com/2021/04/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91URL%20Loading%20System/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="原文：URL Loading System 前言南峰子大佬之前有翻译过这个专题:URL加载系统之一：基本结构，但是随着官方文档的更新，这篇编程指南的原文也从苹果的文档中删除了，因此为复习一下网络框架，就顺手把这篇翻译了，以下开始正文。 URL 加载系统使用标准的网络协议通过与 URLs 交互，来与服务器进行交流。 概述URL 加载系统通过使用标准的协议如 https 或者创建的自定义协议提供被 U">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png">
<meta property="og:image" content="http://yoursite.com/images/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png">
<meta property="og:image" content="http://yoursite.com/images/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png">
<meta property="og:image" content="http://yoursite.com/images/759d2099-d938-415f-ac8a-1a0cac9dea4b.png">
<meta property="og:image" content="http://yoursite.com/images/851916ce-5c1c-4c23-b45b-c4632dacf24c.png">
<meta property="article:published_time" content="2021-04-03T12:45:54.000Z">
<meta property="article:modified_time" content="2022-05-12T13:41:36.408Z">
<meta property="article:author" content="姚七六">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Objective-C">
<meta property="article:tag" content="Foundation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png">

<link rel="canonical" href="http://yoursite.com/2021/04/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91URL%20Loading%20System/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【翻译】URL Loading System | Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91URL%20Loading%20System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【翻译】URL Loading System
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-03 20:45:54" itemprop="dateCreated datePublished" datetime="2021-04-03T20:45:54+08:00">2021-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:41:36" itemprop="dateModified" datetime="2022-05-12T21:41:36+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>原文：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc">URL Loading System</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>南峰子大佬之前有翻译过这个专题:<a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/07/11/url-load-system-1/">URL加载系统之一：基本结构</a>，但是随着官方文档的更新，这篇编程指南的原文也从苹果的文档中删除了，因此为复习一下网络框架，就顺手把这篇翻译了，以下开始正文。</p>
<h1 id="URL-加载系统"><a href="#URL-加载系统" class="headerlink" title="URL 加载系统"></a>URL 加载系统</h1><p>使用标准的网络协议通过与 URLs 交互，来与服务器进行交流。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>URL 加载系统通过使用标准的协议如 https 或者创建的自定义协议提供被 URLs 标识的特定资源的访问。加载是异步执行的，因此你的 app 可以保持响应并且在即将到来的数据或错误信息抵达时做出处理。</p>
<p>使用一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 实例来创建一个或多个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc">NSURLSessionTask</a> 实例,它可以用于给你的 app 获取和返回数据，下载文件，或者上传数据和文件到远程地址。你需要使用一个可以控制诸如如何使用 caches 和 cookies 或者是否允许使用蜂窝网络连接等行为的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">NSURLSessionConfiguration</a> 对象来配置这个 session 实例。</p>
<p>你可以使用一个 session 重复的创建多个任务，举个例子：一个网页浏览器可能会有不同的 session 用于正常访问和隐私访问，在隐私访问的 session 中并不缓存数据。图 1 展示了使用这些配置的两个 session 如何创建多个任务。</p>
<p><strong>图 1</strong> 使用 URL session 创建任务<img src="/images/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png" alt="6789dd96-afdc-4c18-b8eb-01f9012dc04d"></p>
<p>每个 session 都会与一个代理关联起来用于接收周期性的更新（或者 errors）。默认的代理调用你提供的处理任务完成 completion block；如果你创建了自定义的代理，就不会调用这个 block 了。</p>
<p>你可以配置一个运行在 background 的 session，这样当你的 app 挂起时，系统会代表你下载数据并且唤醒你的 app 来传递结果。</p>
<h1 id="First-Steps"><a href="#First-Steps" class="headerlink" title="First Steps"></a>First Steps</h1><h2 id="从网站获取数据到内存"><a href="#从网站获取数据到内存" class="headerlink" title="从网站获取数据到内存"></a>从网站获取数据到内存</h2><p>通过从 URL session 中创建一个 data task 直接接收数据到内存。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>对于与远程服务器的简单交互，你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatatask?language=objc">NSURLSessionDataTask</a> 类将数据接收到内存中（使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask?language=objc">NSURLSessionDownloadTask</a> 则不同，它会将数据直接保存到文件系统）。一个 data task 对于访问 web 服务端点来说是很完美的。</p>
<p>使用一个 URL session 来创建 task。如果你的需求很简单，就可以直接使用 NSURLSession 类的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1409000-sharedsession?language=objc">sharedSession</a> 单例对象。如果你想通过代理回调与传输过程交互的话，需要创建一个 session 而不是使用 sharedSession 单例。创建一个 session 时需要一个 NSURLSessionConfiguration 实例，同时还需传入一个实现了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a> 或其子协议的类。Session 可以被重用于创建多个 task，因此可以对每一个独特的配置创建一个 session 并将其作为属性存储到 session 实例中。</p>
<blockquote>
<p>注意<br>注意不要创建超出需求的 session，举例来说，如果你的 app 中几个部分需要差不多配置的 session，只需要创建一个并且共享它就可以了。</p>
</blockquote>
<p>一旦有了 session，就可以使用<code>dataTask()</code>的相关方法中的一个来创建 data task 了，新创建的 task 是处于 suspended 状态的，需要通过调用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/1411121-resume?language=objc">resume</a> 方法来启动它。</p>
<h3 id="使用-Completion-Handler-接收结果"><a href="#使用-Completion-Handler-接收结果" class="headerlink" title="使用 Completion Handler 接收结果"></a>使用 Completion Handler 接收结果</h3><p>获取数据最简单的方法是使用创建一个使用 completion handler 的 data task。这样 task 会传递服务器端的 response，data 也可能是 error 给你提供的 completion handler。下图展示了 session 和 task 之间的关系，以及结果如何传递到 completion handler 中。</p>
<p><img src="/images/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt="bf4501ff-82b2-4dd4-9ec3-243ef0e70d21"></p>
<p>要创建一个使用 completion handler 的 data task，需要调用 URLSession 的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411554-datataskwithurl?language=objc">dataTaskWithURL:</a>方法,在 completion handler 中要做 3 件事情：</p>
<ol>
<li>验证 error 参数是否为空，如果不是则说明传输发生错误；处理错误并退出。</li>
<li>检查 response 参数，验证代表成功的状态码及 MIME 类型是否是预期值，若不是，则处理服务器错误并退出。</li>
<li>按需求使用 data 实例。</li>
</ol>
<p>下面的代码展示了获取 URL 内容的<code>startLoad()</code>方法。通过使用 NSURLSession 类的共享单例创建一个 data task 用于传递结果给 completion handler。在检查了本地和服务端错误后，在 handler 中将数据转化为一个字符串，并用于插入代码到 WKWebView 中。当然，你的 app 可能会将数据用于其他用途，例如解析到数据模型中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">startLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://www.example.com/&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">            <span class="keyword">self</span>.handleClientError(error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">            (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.handleServerError(response)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> mimeType <span class="operator">=</span> httpResponse.mimeType, mimeType <span class="operator">==</span> <span class="string">&quot;text/html&quot;</span>,</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">            <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: url)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要<br>completion handler 是在与创建 task 不同的 GCD queue 中被调用的。因此任何使用 data 或 error 信息来更新 UI ，像更新 webView 的操作，应该像上例中被显式的放到 main queue 中去。</p>
</blockquote>
<h3 id="使用代理接收传输详情及结果"><a href="#使用代理接收传输详情及结果" class="headerlink" title="使用代理接收传输详情及结果"></a>使用代理接收传输详情及结果</h3><p>为了更进一步随着 task 的运行获取它的状态，你可以在创建一个 data task 时给 session 设置一个代理，而不是提供一个 completion handler。下图展示了这种方案：</p>
<p><img src="/images/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt="730c8e1b-654f-4eb9-9c63-d439a69ac5d2"></p>
<p>通过这种方式，一份份的数据随着他们的抵达会提供到 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate?language=objc">NSURLSessionDataDelegate</a> 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411528-urlsession?language=objc"> URLSession:dataTask:didReceiveData:</a>方法，直到传输完成或者失败。随着数据的传输过程代理对象还接收其他的事件。</p>
<p>当你使用这种方式时，你需要创建一个自己的 URLSession 实例,而不是使用共享的单例。创建一个新的 session 允许你设置自己的类作为其代理。正如下面的代码中展示的。</p>
<p>声明你的类实现了一个或多个代理协议（<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate?language=objc">NSURLSessionTaskDelegate</a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate?language=objc">NSURLSessionDataDelegate</a>, 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate?language=objc">NSURLSessionDownloadDelegate</a>）。然后使用初始化方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411597-sessionwithconfiguration?language=objc">sessionWithConfiguration:delegate:delegateQueue:</a> 来创建 URL session 的实例。可以在初始化方法中设置配置实例。例如，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/2908812-waitsforconnectivity?language=objc">waitsForConnectivity</a> 为<code>YES</code>是个好主意，这样 session 在所要求的连接不可用时会等待适当的连接，而不是直接失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.default</span><br><span class="line">    configuration.waitsForConnectivity <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: configuration,</span><br><span class="line">                      delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了使用这个 session 启动一个 data task 的<code>startLoad()</code>方法，并使用代理回调来处理接收的 data 和 error。这段代码实现了 3 个代理回调：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1410027-urlsession?language=objc">URLSession:dataTask:didReceiveResponse:completionHandler:</a>验证 response 有一个成功的 HTTP 状态码，而且 MIME 类型为<code>text/html</code>或者<code>text/plain</code>。如果任一情况不符合则取消这个 task,否则继续进行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411528-urlsession?language=objc">URLSession:dataTask:didReceiveData:</a>将 task 接收到的每一份 data 实例添加到名为<code>receivedData</code>的缓冲区中。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a>首先检查一下是否有传输级别的错误发生。如果没有就尝试将<code>receivedData</code>转换为一个字符串并将其设置为 webView 的内容。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receivedData: <span class="type">Data</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">startLoad</span>() &#123;</span><br><span class="line">    loadButton.isEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://www.example.com/&quot;</span>)<span class="operator">!</span></span><br><span class="line">    receivedData <span class="operator">=</span> <span class="type">Data</span>()</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: url)</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate methods</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, <span class="params">didReceive</span> <span class="params">response</span>: <span class="type">URLResponse</span>,</span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">URLSession</span>.<span class="type">ResponseDisposition</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(response.statusCode),</span><br><span class="line">        <span class="keyword">let</span> mimeType <span class="operator">=</span> response.mimeType,</span><br><span class="line">        mimeType <span class="operator">==</span> <span class="string">&quot;text/html&quot;</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(.cancel)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, <span class="params">didReceive</span> <span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.receivedData<span class="operator">?</span>.append(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">task</span>: <span class="type">URLSessionTask</span>, <span class="params">didCompleteWithError</span> <span class="params">error</span>: <span class="type">Error</span>?) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.loadButton.isEnabled <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">            handleClientError(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> receivedData <span class="operator">=</span> <span class="keyword">self</span>.receivedData,</span><br><span class="line">            <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">String</span>(data: receivedData, encoding: .utf8) &#123;</span><br><span class="line">            <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: task.currentRequest<span class="operator">?</span>.url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各种各样的代理协议提供了超出上面代码展示的方法。对于处理认证，重定向及其他的情况，在 URLSession 文档的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession?language=occ">Using a URL Session</a>部分讨论了传输过程中的众多回调方法。</p>
<h2 id="上传数据到网站"><a href="#上传数据到网站" class="headerlink" title="上传数据到网站"></a>上传数据到网站</h2><p>从 app 中 post 数据到服务器。</p>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>大多数 app 都与能够接收上传诸如图片或文件，或者使用接收如 JSON 这样结构化数据的网络服务 API 端点的服务器协同工作。想要从 app 中上传数据，要使用一个 NSURLSession 实例创建一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionuploadtask?language=objc">NSURLSessionUploadTask</a> 实例，upload task 使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 实例来描述了上传是如何被执行的。</p>
<h3 id="准备好用于上传的数据"><a href="#准备好用于上传的数据" class="headerlink" title="准备好用于上传的数据"></a>准备好用于上传的数据</h3><p>用于上传的数据可以是文件的内容，一个 stream，或者像下面代码中的数据。</p>
<p>很多网站服务端点接收 JSON 格式的数据，可以通过在如数组和字典这样的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/encodable?language=objc">Encodable</a> 类型上使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/jsonencoder?language=objc">JSONEncoder</a>类来创建。如下代码所示， 你可以声明一个遵循 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/codable?language=objc">Codable</a> 协议的结构体，创建该类型的实例，然后使用<code>JSONEncoder</code>来将实例编码成用于上传的 JSON 数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Order</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> customerId: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> items: [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order <span class="operator">=</span> <span class="type">Order</span>(customerId: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">                  items: [<span class="string">&quot;Cheese pizza&quot;</span>, <span class="string">&quot;Diet soda&quot;</span>])</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> uploadData <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONEncoder</span>().encode(order) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多种方式来创建一个数据实例，例如讲一个图片编码成 JPEG 或者 PNG 数据，或者将一个字符串使用 UTF-8 编码转换成数据。</p>
<h3 id="配置一个上传请求"><a href="#配置一个上传请求" class="headerlink" title="配置一个上传请求"></a>配置一个上传请求</h3><p>Upload task 需要一个 URLRequest 实例，如下代码所示，根据服务器的支持及预期设置请求的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/2011415-httpmethod?language=objc">httpMethod</a> 属性为“POST”或者“PUT”,使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/2011447-setvalue?language=objc">setValue(_:forHTTPHeaderField:)</a> 方法设置任何你想提供的除<code>Content-Length</code>之外的 HTTP header 值。因为 session 会从数据大小中自动计算出内容长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://example.com/post&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">request.httpMethod <span class="operator">=</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">request.setValue(<span class="string">&quot;application/json&quot;</span>, forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建并启动一个上传任务"><a href="#创建并启动一个上传任务" class="headerlink" title="创建并启动一个上传任务"></a>创建并启动一个上传任务</h3><p>要开始上传，需要调用 NSURLSession 类的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411518-uploadtaskwithrequest?language=objc">uploadTaskWithRequest:fromData:completionHandler:</a> 方法创建一个用于上传的 NSURLSessionTask 实例，传入之前设置好的 request 实例与 data 实例。鉴于 task 是以 suspend 状态开始的，你需要通过对 task 调用<code>resume</code>方法来开启一个网络加载过程。下面的代码使用了共享的 URLSession 实例，通过一个 completion handler 接收结果。在 handler 中在使用任何返回数据之前检查传输和服务器端的错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.uploadTask(with: request, from: uploadData) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">        print (<span class="string">&quot;error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(response.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">        print (<span class="string">&quot;server error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mimeType <span class="operator">=</span> response.mimeType,</span><br><span class="line">        mimeType <span class="operator">==</span> <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">        <span class="keyword">let</span> dataString <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">        print (<span class="string">&quot;got data: <span class="subst">\(dataString)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<h3 id="另一种选择，通过设置代理上传"><a href="#另一种选择，通过设置代理上传" class="headerlink" title="另一种选择，通过设置代理上传"></a>另一种选择，通过设置代理上传</h3><p>作为 completion handler 方式的另一种选择，你可以给你配置的 session 设置一个代理，然后使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1409763-uploadtaskwithrequest?language=objc">uploadTaskWithRequest:fromData:</a> 方法创建一个 upload task。在这种方案下，你要实现<code>NSURLSessionDelegate</code>和<code>NSURLSessionTaskDelegate</code>协议中的方法。这些方法会接收服务器的 response 及任何数据或传输错误。</p>
<h2 id="在后台下载文件"><a href="#在后台下载文件" class="headerlink" title="在后台下载文件"></a>在后台下载文件</h2><p>创建一个 task 在 app 处于非活跃状态时下载文件。<br>###概述<br>对应长时间的不紧急的传输任务，你可以创建运行在后台的 task，即使你的 app 已经被 suspended 了，这些任务依然可以运行,并且允许你的 app 恢复运行时访问这些已下载的文件</p>
<blockquote>
<p>注意<br>并不是所有的后台网络活动都必须按照这篇文章中描述的那样使用 background session 来完成，那些声明了合适的 background mode 的 app 可以使用默认的 URLSession 和 data task，就跟在前台运行一样。</p>
</blockquote>
<h3 id="配置-Background-Session"><a href="#配置-Background-Session" class="headerlink" title="配置 Background Session"></a>配置 Background Session</h3><p>按照如下步骤创建一个 background URL session,下面的代码展示了这个过程：</p>
<ol>
<li>提供一个在 app 中唯一的 session 标识符，使用 NSURLSession 的类方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1407496-backgroundsessionconfigurationwi?language=objc">backgroundSessionConfigurationWithIdentifier:</a> 来创建一个 background NSURLSessionConfiguration 对象。因为大部分 app 只需要少数 background session（通常只需要一个）,你可以使用一个固定的字符串作为标识符，而不是动态生成的。这个标识符并不需要全局唯一。</li>
<li>确保 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1617174-sessionsendslaunchevents?language=objc">sessionSendsLaunchEvents</a> 属性被设置为<code>true</code>(默认值)，来保证当任务完成且你的 app 在后台时会被系统唤醒。</li>
<li>对于对时间不敏感的任务，可以设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411552-discretionary?language=objc">discretionary</a> 属性为<code>true</code>，以便于系统在最理想的情况下执行传输任务，例如当设备充电或者连上 Wi-Fi 时。</li>
<li>使用 NSURLSessionConfiguration 实例来创建一个 NSURLSession 实例，这个 session 必须提供一个代理对象，来接收后台传输的各种事件。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> urlSession: <span class="type">URLSession</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> config <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;MySession&quot;</span>)</span><br><span class="line">    config.isDiscretionary <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    config.sessionSendsLaunchEvents <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>想要获取更多关于系统如何调度及执行后台任务，从 Bug 报告<a target="_blank" rel="noopener" href="https://developer.apple.com/bug-reporting/profiles-and-logs/">Profiles and Logs</a>下载并安装后台网络资料到你的 iOS 设备中。</p>
</blockquote>
<h3 id="创建并安排-Download-Task"><a href="#创建并安排-Download-Task" class="headerlink" title="创建并安排 Download Task"></a>创建并安排 Download Task</h3><p>你可以提供一个 URL 使用 session 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411482-downloadtaskwithurl?language=objc">downloadTaskWithURL:</a> 方法创建一个 download task，或者提供一个 URLRequest 实例通过 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411481-downloadtaskwithrequest?language=objc">downloadTaskWithRequest:</a> 创建。你可以设置属性来帮助系统优化 task 的行为。</p>
<ol>
<li>如下代码所示，使用<code>downloadTaskWithURL</code>创建一个 download task。</li>
<li>这一步是可选的，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873413-earliestbegindate?language=objc">earliestBeginDate</a> 属性来安排下载在未来的某个时间点开始，下载并不保证会精确到这个时间进行，但是不会开始的更早。</li>
<li>为帮助系统更有效的安排网络活动，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873401-countofbytesclientexpectstosend?language=objc">countOfBytesClientExpectsToSend</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873414-countofbytesclientexpectstorecei?language=objc">countOfBytesClientExpectsToReceive</a> 属性，这些值是期望传输数据的猜测最接近的上限，而且应该把 header 和 body 数据都计算入内。</li>
<li>调用<code>resume</code>启动这个 task.</li>
</ol>
<p>在下面的代码中，任务被设置为最早一个小时后，而且配置为发送大约 200 字节的数据，接收大约 500 KB 的数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> backgroundTask <span class="operator">=</span> urlSession.downloadTask(with: url)</span><br><span class="line">backgroundTask.earliestBeginDate <span class="operator">=</span> <span class="type">Date</span>().addingTimeInterval(<span class="number">60</span> <span class="operator">*</span> <span class="number">60</span>)</span><br><span class="line">backgroundTask.countOfBytesClientExpectsToSend <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">backgroundTask.countOfBytesClientExpectsToReceive <span class="operator">=</span> <span class="number">500</span> <span class="operator">*</span> <span class="number">1024</span></span><br><span class="line">backgroundTask.resume()</span><br></pre></td></tr></table></figure>
<h3 id="处理-App-挂起"><a href="#处理-App-挂起" class="headerlink" title="处理 App 挂起"></a>处理 App 挂起</h3><p>不同的 app 状态会影响到你的后台下载任务如何与 app 交互。在 iOS 中，你的 app 可能处于 foreground，suspended,或者甚至被系统 terminated。查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/core_app/managing_your_app_s_life_cycle?language=objc">Managing Your App’s Life Cycle</a>获取更多关于 app 状态的信息。</p>
<p>如果你的 app 在 background 状态，当其他进程的下载运行时，系统可能会 suspend 你的 app，这种情况下，当下载完成时，系统会恢复(resume)你的 app 并且调用 UIApplicationDelegate 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application?language=objc">application:handleEventsForBackgroundURLSession:completionHandler:</a> 方法。这个方法接收你前面创建的 session 标识符作为第二个参数。</p>
<p>这个代理方法还接受一个 completion handler 作为其最后一个参数。你应该立即将这个 handler 保存在它有意义的地方。或许作为 app delegate 或者实现了<code>NSURLSessionDownloadDelegate</code>的类的属性。在下面代码中，completion handler 被保存在了 app delegate 的名为<code>backgroundCompletionHandler</code>的属性中了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span><br><span class="line">                 <span class="params">handleEventsForBackgroundURLSession</span> <span class="params">identifier</span>: <span class="type">String</span>,</span><br><span class="line">                 <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        backgroundCompletionHandler <span class="operator">=</span> completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有事件传送完成后，系统会调用<code>NSURLSessionDelegate</code>的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc">URLSessionDidFinishEventsForBackgroundURLSession:</a> 方法，这时，取出保存在 app delegate 中的<code>backgroundCompletionHandler</code>然后执行它。下面的代码展示了这个过程。</p>
<p>注意<code>URLSessionDidFinishEventsForBackgroundURLSession:</code>方法或许会从其他 queue 中被调用，所有需要显式的切换到 main queue 中执行 handler(这个 handler 是从一个 UIKit 方法中接收的)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSessionDidFinishEvents</span>(<span class="params">forBackgroundURLSession</span> <span class="params">session</span>: <span class="type">URLSession</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> appDelegate <span class="operator">=</span> <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as?</span> <span class="type">AppDelegate</span>,</span><br><span class="line">            <span class="keyword">let</span> backgroundCompletionHandler <span class="operator">=</span></span><br><span class="line">            appDelegate.backgroundCompletionHandler <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        backgroundCompletionHandler()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如果-App-被-terminate-了则会重新创建-Session"><a href="#如果-App-被-terminate-了则会重新创建-Session" class="headerlink" title="如果 App 被 terminate 了则会重新创建 Session"></a>如果 App 被 terminate 了则会重新创建 Session</h3><p>如果在 app 处于 suspend 状态时被系统 terminate 了，系统会在后台重启 app。作为启动 的一部分，系统会使用同样的 session 标识符重新创建一个 background session。以便于系统将 download task 与你的 session 重新联系起来。这样不论 app 是被用户还是被系统启动，background session 都已经做好准备了。一旦 app 重新登录，一系列的事件就像上一部分讨论的那样，好像 app 被 suspend 然后 resume 了一样。</p>
<blockquote>
<p>注意<br>假如传输过程是在 app 处于 background 状态时被启动的，session 的配置中<code>discretionary</code>属性会被当做<code>YES</code>。</p>
</blockquote>
<h3 id="处理下载完成和错误"><a href="#处理下载完成和错误" class="headerlink" title="处理下载完成和错误"></a>处理下载完成和错误</h3><p>在 app resume 后（或者在前台了），你的<code>NSURLSessionDownloadDelegate</code>协议方法的实现会接收回调来更新传输的状态。</p>
<p>通过实现 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1411575-urlsession?language=objc">URLSession:downloadTask:didFinishDownloadingToURL:</a> 方法来处理下载完成。检查 download task 的 response 看是否有服务器端的错误如 404 状态码。如果有的话，则并没有得到下载的文件，这时应该退出了。如果下载完成，则最后一个参数是一个存放文件的本地 URL,这个地址只是在这个回调中有效，所以你应该将其转移到其他位置，例如 app 的文档目录下。</p>
<p>下面的代码展示了<code>URLSession:downloadTask:didFinishDownloadingToURL:</code>的实现。这个实现通过检查服务端错误码及移动文件到文档目录下完善了 background download 的过程。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>,</span><br><span class="line">                <span class="params">didFinishDownloadingTo</span> <span class="params">location</span>: <span class="type">URL</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse <span class="operator">=</span> downloadTask.response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">            print (<span class="string">&quot;server error&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> documentsURL <span class="operator">=</span> <span class="keyword">try</span></span><br><span class="line">            <span class="type">FileManager</span>.default.url(for: .documentDirectory,</span><br><span class="line">                                    in: .userDomainMask,</span><br><span class="line">                                    appropriateFor: <span class="literal">nil</span>,</span><br><span class="line">                                    create: <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> savedURL <span class="operator">=</span> documentsURL.appendingPathComponent(</span><br><span class="line">            location.lastPathComponent)</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(at: location, to: savedURL)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        print (<span class="string">&quot;file error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要处理客户端的下载错误，例如连接不到服务器这种，需要实现<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a> 方法。这个方法会在任何 task 完成时被调用；你只需要在最后一个参数不为 nil 的时候处理错误。</p>
<h3 id="遵守后台传输限制"><a href="#遵守后台传输限制" class="headerlink" title="遵守后台传输限制"></a>遵守后台传输限制</h3><p>通过 background session 传输，真正的传输过程是被与你的 app 不同的进程所执行的。因为重启你 app 的进程是相当耗费资源的操作，一些特性会变得不可用，导致如下的限制：</p>
<ul>
<li>Session 必须为每一个事件传递提供一个代理（对于上传或下载，代理与进程内传输表现一致）。</li>
<li>仅支持 HTTP 或者 HTTPS 协议（不支持自定义协议）。</li>
<li>总是会执行重定向，因此即使你实现了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411626-urlsession?language=objc">URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</a> 方法，也不会被调用。</li>
<li>只支持上传文件（上传一个数据实例或者 stream 会在 app 退出后失败）。</li>
</ul>
<h1 id="Requests-和-Responses"><a href="#Requests-和-Responses" class="headerlink" title="Requests 和 Responses"></a>Requests 和 Responses</h1><h2 id="NSURLRequest"><a href="#NSURLRequest" class="headerlink" title="NSURLRequest"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlrequest?language=objc">NSURLRequest</a></h2><h2 id="NSMutableURLRequest"><a href="#NSMutableURLRequest" class="headerlink" title="NSMutableURLRequest"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest?language=objc">NSMutableURLRequest</a></h2><h2 id="NSURLResponse"><a href="#NSURLResponse" class="headerlink" title="NSURLResponse"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlresponse?language=objc">NSURLResponse</a></h2><h2 id="NSHTTPURLResponse"><a href="#NSHTTPURLResponse" class="headerlink" title="NSHTTPURLResponse"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpurlresponse?language=objc">NSHTTPURLResponse</a></h2><h1 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h1><h2 id="获取缓存数据"><a href="#获取缓存数据" class="headerlink" title="获取缓存数据"></a>获取缓存数据</h2><p>控制 URL request 对之前缓存数据的使用。</p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>URL 加载系统会将 response 缓存到内存和磁盘中，以提升性能减少网络阻塞。</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache?language=objc">NSURLCache</a> 类用于从网络资源中缓存 response，你的 app 可以通过 URLCache 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1413377-sharedurlcache?language=objc">sharedURLCache</a> 属性获取到共享的缓存实例，或者也可以，在你的<code>NSURLSessionConfiguration</code>对象上设置不同的 cache 来创建自己的 cache 用于其他用途。</p>
<h3 id="设置-URL-Request-的缓存策略"><a href="#设置-URL-Request-的缓存策略" class="headerlink" title="设置 URL Request 的缓存策略"></a>设置 URL Request 的缓存策略</h3><p>每一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 实例包含一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/cachepolicy?language=objc">URLRequest.CachePolicy</a> 对象来指示是否应该缓存以及缓存应该如何被执行。你可以改变 request 的这个策略来控制它的缓存行为。</p>
<p>方便起见，<code>NSURLSessionConfiguration</code>有一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411655-requestcachepolicy?language=objc">requestCachePolicy</a> 的属性，所有通过使用这个配置的 session 创建的 request 都会从配置中继承这个缓存策略。</p>
<p>各种不同的缓存策略的行为描述在下表中。这个表展示了策略对于直接从缓存中加载还是访问数据源即服务器或本地文件系统的偏好。当前，仅有 HTTP 和 HTTPS response 会被缓存，对于 FTP 或者文件 URL,策略的唯一作用就是决定 request 是否被允许访问数据源。</p>
<table>
<thead>
<tr>
<th align="center">缓存策略</th>
<th align="center">本地缓存</th>
<th align="center">数据源</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NSURLRequestReloadIgnoringLocalCacheData</td>
<td align="center">忽略</td>
<td align="center">Accessed exclusively(不好翻译..)</td>
</tr>
<tr>
<td align="center">NSURLRequestReturnCacheDataDontLoad</td>
<td align="center">Accessed exclusively</td>
<td align="center">忽略</td>
</tr>
<tr>
<td align="center">NSURLRequestReturnCacheDataElseLoad</td>
<td align="center">先试一次</td>
<td align="center">仅在需要时访问</td>
</tr>
<tr>
<td align="center">NSURLRequestUseProtocolCachePolicy</td>
<td align="center">依据协议</td>
<td align="center">依据协议</td>
</tr>
</tbody></table>
<p>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlrequestcachepolicy?language=objc">NSURLRequestCachePolicy</a>获取更多关于 HTTP 和 HTTPS 中是如何实现<code>useProtocolCachePolicy</code>的说明。<code>useProtocolCachePolicy</code>是 URLRequest 对象的默认值。</p>
<blockquote>
<p>注意<br><code>useProtocolCachePolicy</code>将 HTTPS response 缓存到磁盘中，这可能对于保护用户数据安全来说不太理想，你可以通过像在<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/accessing_cached_data#2923215?language=objc">Manage Caching Programmatically</a>描述的一样，手动处理缓存行为来修改这种行为。</p>
</blockquote>
<h3 id="直接获取缓存"><a href="#直接获取缓存" class="headerlink" title="直接获取缓存"></a>直接获取缓存</h3><p>你可以通过 session 的 configuration 对象的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1410148-urlcache?language=objc">URLCache</a> 属性来获取或者设置 URLSession 对象所使用的缓存对象。</p>
<p>对缓存对象调用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1411817-cachedresponseforrequest?language=objc">cachedResponseForRequest:</a> 来查找一个给定 request 的 response 缓存。如果这个 request 的缓存数据存在的话就会返回一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse?language=objc">NSCachedURLResponse</a> 对象，否则返回 nil.</p>
<p>你可以检查 cache 对象所使用的资源，<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1407771-currentdiskusage?language=objc">currentDiskUsage</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1413505-diskcapacity?language=objc">diskCapacity</a> 属性代表了缓存所使用的文件系统资源。<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1408199-currentmemoryusage?language=objc">currentMemoryUsage</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1409781-memorycapacity?language=objc">memoryCapacity</a> 属性代表了缓存所使用的内存。</p>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1415377-removecachedresponseforrequest?language=objc">removeCachedResponseForRequest:</a> 方法来删除单个缓存数据。也可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1415231-removecachedresponsessincedate?language=objc">removeCachedResponsesSinceDate:</a> 来同时删除一个给定时间后的多个缓存数据。或者使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1417802-removeallcachedresponses?language=objc">removeAllCachedResponses</a> 删除整个缓存。</p>
<h3 id="通过写程序来管理缓存过程"><a href="#通过写程序来管理缓存过程" class="headerlink" title="通过写程序来管理缓存过程"></a>通过写程序来管理缓存过程</h3><p>你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1410340-storecachedresponse?language=objc">storeCachedResponse:forRequest:</a> 方法传入一个新的<code>CachedURLResponse</code>对象和一个<code>URLRequest</code>对象通过编写代码来写入缓存。</p>
<p>尤其是<code>URLSessionTask</code>对象处理的 response 的缓存，要在每一个 response 的基础上控制缓存，需要实现<code>NSURLSessionDataDelegate</code>协议的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411612-urlsession?language=objc">URLSession:dataTask:willCacheResponse:completionHandler:</a> 方法。注意这个代理方法只会对 upload task 和 data task 调用，而对于有 background 或 ephemeral（不会翻译了,暂时的？） 配置的 session 并不调用。</p>
<p>这个代理接收两个参数：一个<code>CachedURLResponse</code>对象和一个 completion handler。你的代理实现中必须直接调用这个 completion handler，传入下面的参数之一：</p>
<ul>
<li>提供的<code>CachedURLResponse</code>对象，来照原样缓存 response</li>
<li>nil, 来阻止缓存</li>
<li>一个新创建的<code>CachedURLResponse</code>对象，典型的情况是基于提供的对象，按需求修改一下<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1412269-storagepolicy?language=objc">storagePolicy</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1411900-userinfo?language=objc">userInfo</a> 字典。</li>
</ul>
<p>下面的代码展示了一个<code>urlSession(_:dataTask:willCacheResponse:completionHandler:)</code>的实现代码，其中拦截了 HTTPS 的请求，并且只允许将其缓存存储在内存中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>,</span><br><span class="line">                <span class="params">willCacheResponse</span> <span class="params">proposedResponse</span>: <span class="type">CachedURLResponse</span>,</span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">CachedURLResponse</span>?) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> proposedResponse.response.url<span class="operator">?</span>.scheme <span class="operator">==</span> <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updatedResponse <span class="operator">=</span> <span class="type">CachedURLResponse</span>(response: proposedResponse.response,</span><br><span class="line">                                                data: proposedResponse.data,</span><br><span class="line">                                                userInfo: proposedResponse.userInfo,</span><br><span class="line">                                                storagePolicy: .allowedInMemoryOnly)</span><br><span class="line">        completionHandler(updatedResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(proposedResponse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="认证和证书"><a href="#认证和证书" class="headerlink" title="认证和证书"></a>认证和证书</h1><h2 id="处理认证询问"><a href="#处理认证询问" class="headerlink" title="处理认证询问"></a>处理认证询问</h2><p>当服务器对一个 URL request 询问认证时进行合适的响应。</p>
<h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>当你的 app 使用一个<code>NSURLSessionTask</code>进行请求时，服务器可能会在继续进行前返回一个或多个认证询问。session task 会尝试帮你处理，当处理不了时，会调用你 session 的代理来处理这个问询。</p>
<p>实现这个段落中提到的代理方法来回答与你 app 连接的服务器的询问。如果你不实现这些代理方法，你的 request 可能会被服务器拒绝，你会收到一个包含 HTTP 状态码 401（Forbidden）的 response 而不是你想要的数据。</p>
<h3 id="决定适合的代理方法"><a href="#决定适合的代理方法" class="headerlink" title="决定适合的代理方法"></a>决定适合的代理方法</h3><p>依据你接收到的问询的种类，实现下面的一个，或者两个代理认证方法都实现。</p>
<ul>
<li>实现<code>NSURLSessionDelegate</code>协议的处理整个 session 范围内的认证问询的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1409308-urlsession?language=objc">URLSession:didReceiveChallenge:completionHandler:</a> 方法。这种问询就与传输层安全（TSL）生效一样，一旦你成功的处理了这种问询，那这个 NSURLSession 创建的所有 task 都会持续生效。</li>
<li>实现<code>NSURLSessionTaskDelegate</code>协议的处理指定 task 的问询的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411595-urlsession?language=objc">URLSession:task:didReceiveChallenge:completionHandler:</a> 方法，这种问询是像请求 username&#x2F;password 认证这种。从一个 session 中创建的每个 task 会提出各自的问询。</li>
</ul>
<blockquote>
<p>注意<br>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/nsurlprotectionspace_authentication_method_constants?language=objc">NSURLProtectionSpace Authentication Method Constants</a>了解哪个问询方法是作用于整个 session 的，哪个是针对 task 的。</p>
</blockquote>
<p>一个简单的例子，考虑一下当你请求一个被 HTTP 基本认证保护的 http URL（如<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7617">RFC 7617.</a>中定义的）,因为是一个指定 task 的认证，你需要实现<code>URLSession:task:didReceiveChallenge:completionHandler:</code>方法来处理它。</p>
<blockquote>
<p>注意<br>如果你是通过 https 连接的，你还会接收到一个服务器信任的认证，查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/handling_an_authentication_challenge/performing_manual_server_trust_authentication?language=objc">Performing Manual Server Trust Authentication</a>获取处理这种作用于 session 的认证的信息。</p>
</blockquote>
<p>下图展示了回复 HTTP 基本认证的策略<img src="/images/759d2099-d938-415f-ac8a-1a0cac9dea4b.png" alt="759d2099-d938-415f-ac8a-1a0cac9dea4b"><br>下面的章节描述了这个策略的实现</p>
<h3 id="决定认证问询的种类"><a href="#决定认证问询的种类" class="headerlink" title="决定认证问询的种类"></a>决定认证问询的种类</h3><p>当你接收到一个认证问询时，使用代理方法来决定认证的种类。代理方法接收一个描述所提出的问询<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge?language=objc">NSURLAuthenticationChallenge</a>实例,这个实例包含一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a>属性，它的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1415028-authenticationmethod?language=objc">authenticationMethod</a>属性表明了服务器所提出的认证种类（例如请求一个用户名和密码，或者一个客户端证书）。你使用该值来决定是否能处理这个认证问询。</p>
<p>你通过直接调用传入的 completion handler 来回复这个认证询问，向 handler 中传入一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition?language=objc">NSURLSessionAuthChallengeDisposition</a> 来表明你对认证问询的回复。你可以使用这个 disposition 参数来提供如下选择中合适的：一个认证，取消请求，或者允许默认的处理来进行。</p>
<p>下面代码检查了<code>authenticationMethod</code>是否是所期待的 HTTP 基本类型。如果<code>authenticationMethod</code>属性指明了其他种类的问询，它会调用 completion handler 并传入<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeperformdefaulthandling?language=objc">NSURLSessionAuthChallengePerformDefaultHandling</a>处理参数。告诉 task 使用满足认证问询的默认处理；否则 task 会继续直到下一个认证问询再次调用这个代理方法。这个过程会继续执行直到等到你要处理的 HTTP 基本认证。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> authMethod <span class="operator">=</span> challenge.protectionSpace.authenticationMethod</span><br><span class="line"><span class="keyword">guard</span> authMethod <span class="operator">==</span> <span class="type">NSURLAuthenticationMethodHTTPBasic</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个凭证实例"><a href="#创建一个凭证实例" class="headerlink" title="创建一个凭证实例"></a>创建一个凭证实例</h3><p>你需要依据接收到的认证问询的种类来提交一个合适的凭证来回复认证。对于 HTTP 基本认证和 HTTP 摘要认证，你可以提供一个 username 和 password。下面的代码展示了一个从用户界面创建 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a>实例的帮助方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">credentialsFromUI</span>() -&gt; <span class="type">URLCredential</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> username <span class="operator">=</span> usernameField.text, <span class="operator">!</span>username.isEmpty,</span><br><span class="line">        <span class="keyword">let</span> password <span class="operator">=</span> passwordField.text, <span class="operator">!</span>password.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLCredential</span>(user: username, password: password,</span><br><span class="line">                         persistence: .forSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回的<code>NSURLCredential</code>实例有个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredentialpersistence/nsurlcredentialpersistenceforsession?language=objc">NSURLCredentialPersistenceForSession</a> 持久化策略，所以它只会保存在创建这个 task 的<code>NSURLSession</code>实例中，对于其他 session 实例创建的 task 你需要提供新的<code>NSURLCredential</code>实例，对于 app 以后运行时也需要创建新的实例。</p>
<h3 id="调用-Completion-Handler"><a href="#调用-Completion-Handler" class="headerlink" title="调用 Completion Handler"></a>调用 Completion Handler</h3><p>一旦你尝试创建 credential 实例，你必须要调用 completion handler 来回复认证问询。</p>
<ul>
<li>如果你不能创建一个 credential，或者用户显式的取消了，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengecancelauthenticationchallenge?language=objc">NSURLSessionAuthChallengeCancelAuthenticationChallenge</a> 处理参数。</li>
<li>如果你创建了一个 credential 实例，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeusecredential?language=objc">NSURLSessionAuthChallengeUseCredential</a> 处理参数。</li>
</ul>
<p>下面的代码展示了这两种情况</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> credential <span class="operator">=</span> credentialOrNil <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">completionHandler(.useCredential, credential)</span><br></pre></td></tr></table></figure>
<p>如果你传入了一个服务器接受的凭证，这个 task 会继续执行上传或下载数据。</p>
<blockquote>
<p>重要<br>你可以将 completion handler 传给其他方法或者将其短暂的保存在属性中，用于等待用户完成 username&#x2F;password 输入。但是你最终还是要调用 completion handler 来完成认证使得 task 继续执行，即使你选择像下面的失败情况处理中那样取消认证。</p>
</blockquote>
<h3 id="优雅的处理失败情况"><a href="#优雅的处理失败情况" class="headerlink" title="优雅的处理失败情况"></a>优雅的处理失败情况</h3><p>如果凭证被拒绝，系统会再次调用你的代理方法。这种情况下，回调会将你被拒绝的凭证作为<code>NSURLAuthenticationChallenge</code>参数的属性<a href="proposedCredential">proposedCredential</a>传回给你。这个<code>NSURLAuthenticationChallenge</code>实例中还包含一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1416522-previousfailurecount?language=objc">previousFailureCount</a>属性，这个属性表示你的凭证被拒绝的次数。你可以使用这个参数来决定接下来怎么做。举个例子，如果<code>previousFailureCount</code> 比 0 大，你可以在使用已提交的凭证的字符串来在用户界面上插入一个重新输入 username&#x2F;password 的界面。</p>
<h2 id="执行服务器信任鉴定"><a href="#执行服务器信任鉴定" class="headerlink" title="执行服务器信任鉴定"></a>执行服务器信任鉴定</h2><p>在你的 app 中进行服务器安全凭证的评估。</p>
<h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>当你通过 URL request 使用安全连接时（例如 https）,你的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a>会接收到一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodservertrust?language=objc">NSURLAuthenticationMethodServerTrust</a> 认证类型的认证问询。与其他的服务器要求你的 app 证明自己身份的问询不同，这里是你来鉴定服务器的凭证的机会。</p>
<h3 id="决定何时进行服务器信任鉴定"><a href="#决定何时进行服务器信任鉴定" class="headerlink" title="决定何时进行服务器信任鉴定"></a>决定何时进行服务器信任鉴定</h3><p>大部分情况下，你应该将评估服务器信任度的工作交由 URL 加载系统的默认处理流程去做。当你没有设置代理或者没有处理认证问询时就会执行这些默认的行为。然后在下面这些场景中自己操作评估过程可能会更有用：</p>
<ul>
<li>你想要接受服务端证书而在默认情况下会被系统拒绝的情况。举个例子，你的 app 想要与使用自签名证书的开发服务器之间建立安全连接，而这个证书一般又不会与系统的信任证书的存储中的内容相匹配。</li>
<li>你想要拒绝这个证书而在默认情况下会被系统接受。举个例子，你想要你的 app 固定在几个由你控制的 key 或证书上，而不是接受任何有效的证书。</li>
</ul>
<p>下图展示了你的 app 如何通过提供一个代理方法来处理认证问询来执行手动的证书校验。这样就绕过了系统的默认处理。代理会直接比较服务器证书或公钥与存储在 app bundle 中的 证书或公钥（或哈希值等等）的拷贝。如果代理中判断这个服务器凭证是有效的，他就会信任这个服务器并允许继续连接。<br><img src="/images/851916ce-5c1c-4c23-b45b-c4632dacf24c.png" alt="851916ce-5c1c-4c23-b45b-c4632dacf24c"></p>
<blockquote>
<p>注意<br>如果你要连接的域名开启了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession#1776695?language=objc">App Transport Security (ATS)</a> ,NSURLSession 会强制使用。它应用于证书， TSL 版本，连接用的密码等安全要求。你不能放松一个使用 ATS 保护的域名的服务器的信任要求，但是你可以使用文章中面熟的技术收紧要求。查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247">Information Property List Key Reference</a>文章中的 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/plist/info/NSAppTransportSecurity">NSAppTransportSecurity</a> 获取更详细的信息。</p>
</blockquote>
<h3 id="处理服务器信任认证问询"><a href="#处理服务器信任认证问询" class="headerlink" title="处理服务器信任认证问询"></a>处理服务器信任认证问询</h3><p>实现<code>NSURLSessionDelegate</code>的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1409308-urlsession?language=objc">URLSession:didReceiveChallenge:completionHandler:</a>方法来手动处理服务器信任认证。当这个方法被调用时，你的实现中首先需要检查:</p>
<ul>
<li>问询种类是服务器信任，而不是其他类型的问询。</li>
<li>问询的主机名与你想要处理证书校验的证书匹配。</li>
</ul>
<p>下面的代码展示了这些情况，根据传入<code>URLSession:didReceiveChallenge:completionHandler:</code>的 challenge 参数的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a> 来检查上面列出的两项。首先，从 protection space 中获取 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1415028-authenticationmethod?language=objc">authenticationMethod</a> 检查认证问询的类型是不是 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodservertrust?language=objc">NSURLAuthenticationMethodServerTrust</a>，然后保证 protection space 中的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1418205-host?language=objc">host</a>匹配期待的主机名 <code>example.com</code>,如果这两个条件有一个没有满足，则会调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeperformdefaulthandling?language=objc">NSURLSessionAuthChallengePerformDefaultHandling</a>来让系统采用默认的方法处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protectionSpace <span class="operator">=</span> challenge.protectionSpace</span><br><span class="line"><span class="keyword">guard</span> protectionSpace.authenticationMethod <span class="operator">==</span></span><br><span class="line">    <span class="type">NSURLAuthenticationMethodServerTrust</span>,</span><br><span class="line">    protectionSpace.host.contains(<span class="string">&quot;example.com&quot;</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="校验-Challenge-中的凭证"><a href="#校验-Challenge-中的凭证" class="headerlink" title="校验 Challenge 中的凭证"></a>校验 Challenge 中的凭证</h3><p>获取 protection space 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1409926-servertrust?language=objc">serverTrust</a>属性（<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/security/sectrustref?language=objc">SecTrustRef</a>类的实例）来访问服务器的凭证。下面的代码展示了如何访问服务器凭证并接受或拒绝它。代码首先尝试从 protection space 中获取<code>serverTrust</code>属性，如果为空的话就回退到默认的处理去。然后将服务器凭证传给一个私有方法<code>checkValidity(of:)</code>来比较服务器凭证中的证书或公钥是否有 app bundle 中保存的有效值匹配。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> serverTrust <span class="operator">=</span> protectionSpace.serverTrust <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> checkValidity(of: serverTrust) &#123;</span><br><span class="line">    <span class="keyword">let</span> credential <span class="operator">=</span> <span class="type">URLCredential</span>(trust: serverTrust)</span><br><span class="line">    completionHandler(.useCredential, credential)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Show a UI here warning the user the server credentials are</span></span><br><span class="line">    <span class="comment">// invalid, and cancel the load.</span></span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦代码决定了服务器凭证的有效性，它会采取下面的两个动作：</p>
<ul>
<li>如果服务器认证凭证是有效的，从服务器凭证中创建一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a> 实例然后调用 completion handler 传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeusecredential?language=objc">NSURLSessionAuthChallengeUseCredential</a> 处置方式参数及新创建的凭证，这样会告诉系统接受服务器凭证。</li>
<li>如果平时是无效的，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengecancelauthenticationchallenge?language=objc">NSURLSessionAuthChallengeCancelAuthenticationChallenge</a>处理参数，这样告诉系统拒绝服务器凭证。</li>
</ul>
<blockquote>
<p>Tip<br>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services?language=objc">Certificate, Key, and Trust Services</a> 了解更多关于如何校验<code>SecTrustRef </code>实例或者从中获取证书或公钥。</p>
</blockquote>
<h3 id="创建长期的服务器认证策略"><a href="#创建长期的服务器认证策略" class="headerlink" title="创建长期的服务器认证策略"></a>创建长期的服务器认证策略</h3><p>如果你需要在某些情况下手动验证服务器认证信息，安排好你 app 的工作如果你想要修改服务器凭证，要考虑下列准则：</p>
<ul>
<li>将你的服务器凭证与一个公钥匹配，而不是在 app bundle 中存储一个单独的证书。这允许你对同样的 key 重新发布证书来更新服务器，而不需要更新 app。</li>
<li>比较发布的 certificate authority’s(CA’s) key,而不是比较末端的 key，这样你可以部署包含新 key 的使用同一个 CA 签名的证书。</li>
<li>使用一组 keys 或 CAs ，这样装换服务器凭证时更方便。</li>
</ul>
<h2 id="NSURLAuthenticationChallenge"><a href="#NSURLAuthenticationChallenge" class="headerlink" title="NSURLAuthenticationChallenge"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge?language=objc">NSURLAuthenticationChallenge</a></h2><h2 id="NSURLCredential"><a href="#NSURLCredential" class="headerlink" title="NSURLCredential"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a></h2><h2 id="NSURLCredentialStorage"><a href="#NSURLCredentialStorage" class="headerlink" title="NSURLCredentialStorage"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredentialstorage?language=objc">NSURLCredentialStorage</a></h2><h2 id="NSURLProtectionSpace"><a href="#NSURLProtectionSpace" class="headerlink" title="NSURLProtectionSpace"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace?language=objc">NSURLProtectionSpace</a></h2><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="NSHTTPCookie"><a href="#NSHTTPCookie" class="headerlink" title="NSHTTPCookie"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpcookie?language=objc">NSHTTPCookie</a></h2><h2 id="NSHTTPCookieStorage"><a href="#NSHTTPCookieStorage" class="headerlink" title="NSHTTPCookieStorage"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpcookiestorage?language=objc">NSHTTPCookieStorage</a></h2><h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h1><h2 id="URL-Loading-System-Error-Codes"><a href="#URL-Loading-System-Error-Codes" class="headerlink" title="URL Loading System Error Codes"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/1508628-url_loading_system_error_codes?language=objc">URL Loading System Error Codes</a></h2><h2 id="URL-Loading-System-Error-Info-Keys"><a href="#URL-Loading-System-Error-Info-Keys" class="headerlink" title="URL Loading System Error Info Keys"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/url_loading_system_error_info_keys?language=objc">URL Loading System Error Info Keys</a></h2><h1 id="遗留版本"><a href="#遗留版本" class="headerlink" title="遗留版本"></a>遗留版本</h1><h2 id="Legacy-URL-Loading-Systems"><a href="#Legacy-URL-Loading-Systems" class="headerlink" title="Legacy URL Loading Systems"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/legacy_url_loading_systems?language=objc">Legacy URL Loading Systems</a></h2><p>将你的代码从使用这些遗留版本的对象迁移到新的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
              <a href="/tags/Foundation/" rel="tag"># Foundation</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/15/KVC-KVO%20%E7%AC%94%E8%AE%B0/" rel="prev" title="KVC/KVO 笔记">
      <i class="fa fa-chevron-left"></i> KVC/KVO 笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/07/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Understanding%20JavaScript%20Bind%20()/" rel="next" title="【翻译】Understanding JavaScript Bind ()">
      【翻译】Understanding JavaScript Bind () <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#URL-%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">URL 加载系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#First-Steps"><span class="nav-number">3.</span> <span class="nav-text">First Steps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E7%BD%91%E7%AB%99%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0%E5%86%85%E5%AD%98"><span class="nav-number">3.1.</span> <span class="nav-text">从网站获取数据到内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Completion-Handler-%E6%8E%A5%E6%94%B6%E7%BB%93%E6%9E%9C"><span class="nav-number">3.1.2.</span> <span class="nav-text">使用 Completion Handler 接收结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8E%A5%E6%94%B6%E4%BC%A0%E8%BE%93%E8%AF%A6%E6%83%85%E5%8F%8A%E7%BB%93%E6%9E%9C"><span class="nav-number">3.1.3.</span> <span class="nav-text">使用代理接收传输详情及结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E7%AB%99"><span class="nav-number">3.2.</span> <span class="nav-text">上传数据到网站</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">3.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%A5%BD%E7%94%A8%E4%BA%8E%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.2.</span> <span class="nav-text">准备好用于上传的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E4%B8%8A%E4%BC%A0%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.3.</span> <span class="nav-text">配置一个上传请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E4%B8%8A%E4%BC%A0%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.4.</span> <span class="nav-text">创建并启动一个上传任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E4%BC%A0"><span class="nav-number">3.2.5.</span> <span class="nav-text">另一种选择，通过设置代理上传</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">在后台下载文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-Background-Session"><span class="nav-number">3.3.1.</span> <span class="nav-text">配置 Background Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%AE%89%E6%8E%92-Download-Task"><span class="nav-number">3.3.2.</span> <span class="nav-text">创建并安排 Download Task</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86-App-%E6%8C%82%E8%B5%B7"><span class="nav-number">3.3.3.</span> <span class="nav-text">处理 App 挂起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C-App-%E8%A2%AB-terminate-%E4%BA%86%E5%88%99%E4%BC%9A%E9%87%8D%E6%96%B0%E5%88%9B%E5%BB%BA-Session"><span class="nav-number">3.3.4.</span> <span class="nav-text">如果 App 被 terminate 了则会重新创建 Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-number">3.3.5.</span> <span class="nav-text">处理下载完成和错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%B5%E5%AE%88%E5%90%8E%E5%8F%B0%E4%BC%A0%E8%BE%93%E9%99%90%E5%88%B6"><span class="nav-number">3.3.6.</span> <span class="nav-text">遵守后台传输限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Requests-%E5%92%8C-Responses"><span class="nav-number">4.</span> <span class="nav-text">Requests 和 Responses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLRequest"><span class="nav-number">4.1.</span> <span class="nav-text">NSURLRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSMutableURLRequest"><span class="nav-number">4.2.</span> <span class="nav-text">NSMutableURLRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLResponse"><span class="nav-number">4.3.</span> <span class="nav-text">NSURLResponse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSHTTPURLResponse"><span class="nav-number">4.4.</span> <span class="nav-text">NSHTTPURLResponse</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA"><span class="nav-number">5.</span> <span class="nav-text">缓存行为</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">获取缓存数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">5.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE-URL-Request-%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">5.1.2.</span> <span class="nav-text">设置 URL Request 的缓存策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E7%BC%93%E5%AD%98"><span class="nav-number">5.1.3.</span> <span class="nav-text">直接获取缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%86%99%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.4.</span> <span class="nav-text">通过写程序来管理缓存过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E5%92%8C%E8%AF%81%E4%B9%A6"><span class="nav-number">6.</span> <span class="nav-text">认证和证书</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%AE%A4%E8%AF%81%E8%AF%A2%E9%97%AE"><span class="nav-number">6.1.</span> <span class="nav-text">处理认证询问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">6.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B3%E5%AE%9A%E9%80%82%E5%90%88%E7%9A%84%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.2.</span> <span class="nav-text">决定适合的代理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B3%E5%AE%9A%E8%AE%A4%E8%AF%81%E9%97%AE%E8%AF%A2%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">6.1.3.</span> <span class="nav-text">决定认证问询的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%87%AD%E8%AF%81%E5%AE%9E%E4%BE%8B"><span class="nav-number">6.1.4.</span> <span class="nav-text">创建一个凭证实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-Completion-Handler"><span class="nav-number">6.1.5.</span> <span class="nav-text">调用 Completion Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E6%83%85%E5%86%B5"><span class="nav-number">6.1.6.</span> <span class="nav-text">优雅的处理失败情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E4%BB%BB%E9%89%B4%E5%AE%9A"><span class="nav-number">6.2.</span> <span class="nav-text">执行服务器信任鉴定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">6.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B3%E5%AE%9A%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E4%BB%BB%E9%89%B4%E5%AE%9A"><span class="nav-number">6.2.2.</span> <span class="nav-text">决定何时进行服务器信任鉴定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E4%BB%BB%E8%AE%A4%E8%AF%81%E9%97%AE%E8%AF%A2"><span class="nav-number">6.2.3.</span> <span class="nav-text">处理服务器信任认证问询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C-Challenge-%E4%B8%AD%E7%9A%84%E5%87%AD%E8%AF%81"><span class="nav-number">6.2.4.</span> <span class="nav-text">校验 Challenge 中的凭证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%95%BF%E6%9C%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A4%E8%AF%81%E7%AD%96%E7%95%A5"><span class="nav-number">6.2.5.</span> <span class="nav-text">创建长期的服务器认证策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLAuthenticationChallenge"><span class="nav-number">6.3.</span> <span class="nav-text">NSURLAuthenticationChallenge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLCredential"><span class="nav-number">6.4.</span> <span class="nav-text">NSURLCredential</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLCredentialStorage"><span class="nav-number">6.5.</span> <span class="nav-text">NSURLCredentialStorage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSURLProtectionSpace"><span class="nav-number">6.6.</span> <span class="nav-text">NSURLProtectionSpace</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cookie"><span class="nav-number">7.</span> <span class="nav-text">Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSHTTPCookie"><span class="nav-number">7.1.</span> <span class="nav-text">NSHTTPCookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSHTTPCookieStorage"><span class="nav-number">7.2.</span> <span class="nav-text">NSHTTPCookieStorage</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Errors"><span class="nav-number">8.</span> <span class="nav-text">Errors</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#URL-Loading-System-Error-Codes"><span class="nav-number">8.1.</span> <span class="nav-text">URL Loading System Error Codes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URL-Loading-System-Error-Info-Keys"><span class="nav-number">8.2.</span> <span class="nav-text">URL Loading System Error Info Keys</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%97%E7%95%99%E7%89%88%E6%9C%AC"><span class="nav-number">9.</span> <span class="nav-text">遗留版本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Legacy-URL-Loading-Systems"><span class="nav-number">9.1.</span> <span class="nav-text">Legacy URL Loading Systems</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
