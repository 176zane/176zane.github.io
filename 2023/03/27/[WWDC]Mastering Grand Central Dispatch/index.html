<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言本文是对Mastering Grand Central Dispatch WWDC2011 - Session 210以及 GCD 其他内容的学习笔记。 GCD 按照我的理解就是一个系统级的并发模型，通过这个模型你不再需要直接接触底层的“线程”和“锁”去编写大量的对线程安全要求很高的代码，而是在模型中将“执行任务的 Block”添加进合适的“调度队列（dispatch queue）”中就可以轻">
<meta property="og:type" content="article">
<meta property="og:title" content="【WWDC】Mastering Grand Central Dispatch">
<meta property="og:url" content="http://yoursite.com/2023/03/27/[WWDC]Mastering%20Grand%20Central%20Dispatch/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="前言本文是对Mastering Grand Central Dispatch WWDC2011 - Session 210以及 GCD 其他内容的学习笔记。 GCD 按照我的理解就是一个系统级的并发模型，通过这个模型你不再需要直接接触底层的“线程”和“锁”去编写大量的对线程安全要求很高的代码，而是在模型中将“执行任务的 Block”添加进合适的“调度队列（dispatch queue）”中就可以轻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/Concurrency_vs_Parallelism.png">
<meta property="og:image" content="http://yoursite.com/images/Serial-Queue-Swift.png">
<meta property="og:image" content="http://yoursite.com/images/2018-07-0923_21_23.gif">
<meta property="og:image" content="http://yoursite.com/images/Concurrent-Queue-Swift.png">
<meta property="og:image" content="http://yoursite.com/images/2018-07-1000_02_32.gif">
<meta property="og:image" content="http://yoursite.com/images/Dispatch-Barrier-Swift.png">
<meta property="og:image" content="http://yoursite.com/images/2018-07-1210_40_14.gif">
<meta property="og:image" content="http://yoursite.com/images/targetqueuehierarchy.png">
<meta property="og:image" content="http://yoursite.com/images/jumpthequeue.png">
<meta property="article:published_time" content="2023-03-27T08:33:36.000Z">
<meta property="article:modified_time" content="2023-10-10T03:53:39.651Z">
<meta property="article:author" content="姚七六">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Objective-C">
<meta property="article:tag" content="Foundation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Concurrency_vs_Parallelism.png">

<link rel="canonical" href="http://yoursite.com/2023/03/27/[WWDC]Mastering%20Grand%20Central%20Dispatch/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【WWDC】Mastering Grand Central Dispatch | Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/03/27/[WWDC]Mastering%20Grand%20Central%20Dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【WWDC】Mastering Grand Central Dispatch
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-27 16:33:36" itemprop="dateCreated datePublished" datetime="2023-03-27T16:33:36+08:00">2023-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-10 11:53:39" itemprop="dateModified" datetime="2023-10-10T11:53:39+08:00">2023-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是对<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/210/">Mastering Grand Central Dispatch WWDC2011 - Session 210</a>以及 GCD 其他内容的学习笔记。</p>
<p>GCD 按照我的理解就是一个系统级的并发模型，通过这个模型你不再需要直接接触底层的“线程”和“锁”去编写大量的对线程安全要求很高的代码，而是在模型中将“执行任务的 Block”添加进合适的“调度队列（dispatch queue）”中就可以轻松实现多线程编程。当然它还附赠了例如<code>dispatch_once</code>在线程安全的环境下实现单例等很多好用的功能！</p>
<p>要编写多线程代码，首先要理解下面这些基本的概念：</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="进程（Process）与线程（Thread）"><a href="#进程（Process）与线程（Thread）" class="headerlink" title="进程（Process）与线程（Thread）"></a>进程（Process）与线程（Thread）</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">进程</a>是程序（指令与数据）的真正运行实例。在早期面向进程设计的操作系统中，进程是程序的基本执行实体；而现代面向线程设计的操作系统中，进程本身不是基本运行单位而是线程的容器。计算机可以同时运行多个进程，有前台进程也有后台进程。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B">线程</a>是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h2 id="并行（Parallelism）与并发（Concurrency）"><a href="#并行（Parallelism）与并发（Concurrency）" class="headerlink" title="并行（Parallelism）与并发（Concurrency）"></a>并行（Parallelism）与并发（Concurrency）</h2><p><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">Grand Central Dispatch Tutorial for Swift 3: Part 1&#x2F;2</a>中的这张图很清晰的解释了两者的区别：</p>
<p><img src="/images/Concurrency_vs_Parallelism.png" alt="Concurrency_vs_Parallelism"><br>在单核 CPU 中通过“上下文切换”（即保存 CPU 的寄存器等信息到各自路径专用的内存块中，从切换目标路径专用的内存块中复原寄存器等信息，继续执行目标路径的命令列的过程）在某个线程与其他线程间反复执行，并发的看上去像是同时执行多个线程一样。而在多核 CPU 中则可以通过并行真正的同时执行多个线程。</p>
<p>GCD 是建立在线程的基础之上的，在下层系统维护着一个共享的线程池，你只需要将执行任务的 block 或者函数添加进 dispatch queues 中，然后由 GCD 来决定在哪个线程上面执行它。GCD 根据系统状态及可用资源来决定进行多大程度的并行。留意并行要求必须是并发的，但是并发并不能保证一定并行！</p>
<h2 id="分发队列（Dispatch-Queue）"><a href="#分发队列（Dispatch-Queue）" class="headerlink" title="分发队列（Dispatch Queue）"></a>分发队列（Dispatch Queue）</h2><p>Dispatch Queue 是管理你添加的要执行任务的队列，它按照先进先出（FIFO）的顺序执行处理。Dispatch Queue 是线程安全的，也就意味着你可以同时在多个线程访问它。Dispatch Queue 分为 Serial Queue和 Concurrent Queue 两种（注：下面部分图片来自 Ray 家的教程）：</p>
<h3 id="串行队列（Serial-Queue）"><a href="#串行队列（Serial-Queue）" class="headerlink" title="串行队列（Serial Queue）"></a>串行队列（Serial Queue）</h3><p><img src="/images/Serial-Queue-Swift.png" alt="Serial-Queue-Swift"><br>Serial Queue 保证在任何时间同时只能执行一个任务，它会等待当前正在进行的任务结束之后再处理其他任务。由 GCD 来控制任务的执行时机，两个任务之间会有多久的间隔也是不确定的。一旦生成 Serial Queue 并添加了任务进去，系统对于一个 Serial Queue 就只生成并使用一个线程。但是多个 Serial Queue 对应各自不同的线程，因此他们之间是可以并行执行的。Serial Queue 与线程的关系可以看下面的gif图（注：图片截取自 WWDC 视频）：</p>
<p><img src="/images/2018-07-0923_21_23.gif" alt="2018-07-09 23_21_23"></p>
<h3 id="并发队列（Concurrent-Queue）"><a href="#并发队列（Concurrent-Queue）" class="headerlink" title="并发队列（Concurrent Queue）"></a>并发队列（Concurrent Queue）</h3><p><img src="/images/Concurrent-Queue-Swift.png" alt="Concurrent-Queue-Swift"></p>
<p>Concurrent Queue 允许同时执行多个任务，其中的任务会按照被添加的顺序出队开始执行，但是它不会等待正在执行的任务结束就可以开始下一个任务。任务结束的顺序及同一时刻正在执行的任务数量是不确定的。一个 Concurrent Queue 可以使用多个线程同时执行多个处理。什么时候开始执行一个任务，在多核环境下是使用“上下文切换”还是在另一个核心上运行这些都是由 GCD 决定的。Concurrent Queue 与线程的对应关系可以看下图：</p>
<p><img src="/images/2018-07-1000_02_32.gif" alt="2018-07-10 00_02_32"></p>
<h1 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h1><h2 id="dispatch-get-main-queue-dispatch-get-global-queue"><a href="#dispatch-get-main-queue-dispatch-get-global-queue" class="headerlink" title="dispatch_get_main_queue&#x2F;dispatch_get_global_queue"></a>dispatch_get_main_queue&#x2F;dispatch_get_global_queue</h2><p>有两种途径得到Dispatch Queue：</p>
<ol>
<li>获取系统标准提供的 Main Queue&#x2F;Global Queues</li>
<li>通过<code>dispatch_queue_create</code>函数生成的 Custom Queues</li>
</ol>
<p>Main Queue 中的任务是在主线程 Runloop 中执行的,因为主线程只有一个，Main Queue 自然也就是一个 Serial Queue。由于在主线程中执行，因此要将用户界面的更新等必须在主线程中执行的任务添加到 Main Queue 中。可以通过<code>dispatch_get_main_queue()</code>函数获取。</p>
<p>Global Queue 是整个系统共享的 Concurrent Queue,它包含四个不同优先级的队列：high, default, low, 和 background。在 iOS 8.0 之前，只需要将任务提交到对应执行优先级的 Global Queue 中即可保证任务执行的优先级顺序。例如获取一个高优先级队列的函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数 flag 是为未来保留的，现在传入 0 即可。</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> highGlobalQue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>现在你不需要直接指定 Queue 的优先级了，而是指定一个 Quality of Service (QoS) 级别来暗示任务的重要性，然后 GCD 通过这个值来决定使用哪个优先级的队列。Qos 级别有以下几种：</p>
<ul>
<li><code>QOS_CLASS_USER_INTERACTIVE</code>: 这个级别代表任务需要尽快执行以便提供良好的用户体验，主要用于 UI 刷新，处理事件等需要低延迟的任务。这个级别的任务应该在主线程执行。</li>
<li><code>QOS_CLASS_USER_INITIATED</code>: 这个级别代表任务是从 UI 线程初始化的，可以异步执行，主要用于尽快的得到执行结果，这个级别被映射到了高优先级队列。</li>
<li><code>QOS_CLASS_DEFAULT</code>: 默认的任务级别。映射到默认优先级队列。</li>
<li><code>QOS_CLASS_UTILITY</code>: 这个级别的任务通常是耗时的，主要用于计算，磁盘IO,网路通信等，它被设置为尽量节省能源的。这个级别被映射到了低优先级队列。</li>
<li><code>QOS_CLASS_BACKGROUND</code>:这个级别的任务大多是用户感知不到的，会被映射到后台优先级队列</li>
<li><code>QOS_CLASS_UNSPECIFIED</code>:这个级别表示服务质量缺失。</li>
</ul>
<p>获取一个<code>QOS_CLASS_USER_INITIATED</code>级别的队列方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> userInitiatedQue = dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数&quot;com.zane.serialQueue&quot;用来标记这个队列，在 Instruments 中调试时作为队列的名字。第二个参数使用 NULL/DISPATCH_QUEUE_SERIAL 表示生成串行队列，使用 DISPATCH_QUEUE_CONCURRENT 表示生成并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customeConcurrentQue = dispatch_queue_create(<span class="string">&quot;com.zane.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码创建的 Serial Queue,在往这个队列中提交了任务之后，系统就会为它生成一个线程。使用这个方法创建多少个 Serial Queue，就会对应生成多少个相互间并行的线程，因此如果创建大量的 Serial Queue 就会消耗大量内存，引起大量上下文切换，使得程序性能降低</strong>因此只应该在多个线程更新共享资源会导致数据竞争时，使用一个 Serial Queue.</p>
<p>上面创建的 Concurrent Queue，不管创建多少个，系统都只会为其使用有效管理的几个线程。</p>
<p>早期通过这个方法生成的 Queue 还需要使用<code>dispatch_release()</code>函数释放它，iOS 6 之后，系统通过ARC 来管理生成的 Queue，提交进 Queue 的 block 会持有一个该 Queue 的引用，所以只有在 Queue 中所有的 block 执行完之后才会释放。</p>
<h2 id="dispatch-sync-dispatch-async"><a href="#dispatch-sync-dispatch-async" class="headerlink" title="dispatch_sync&#x2F;dispatch_async"></a>dispatch_sync&#x2F;dispatch_async</h2><p>可以通过下面两个常用的函数向 Queue 中添加任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="type">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async</code>函数是非同步（asynchronous）的，他将 block 添加进 queue 中，不做任何等待立即返回，这样不会阻碍当前执行的线程，可以继续进行下一行函数，常用于处理后台任务。<code>dispatch_async</code>函数内部会先将 block 拷贝到堆中，避免 block 执行前就被销毁。</p>
<p><code>dispatch_sync</code>函数是同步（synchronous）的，它将 block “同步的”添加进 queue 中，在添加进的这个 block 任务执行完成之前，<code>dispatch_sync</code>函数会一直等待，该函数会处于调用状态而不返回。也就是说当前线程是停止的。当 block 中的任务执行结束之后，函数返回，当前线程继续进行下一行函数。</p>
<p>与<code>dispatch_async</code>不同，<code>dispatch_sync</code>不会对该 queue 执行 retain 操作,它从调用者那里“借来”一个对 queue 的引用，而且也不会对 block 做<code>Block_copy</code>操作。</p>
<p><code>dispatch_sync</code>函数的特性导致其很容易引起死锁的情况，<strong>如在执行一个 Serial Queue 的任务的线程中，将一个任务 block 同步添加到这个 Serial Queue 中时，就会发生死锁。</strong>因为该线程中正在执行这个函数，它已经处于调用状态而不返回，也就无法执行 block 中的任务，两者互相等待，形成死锁。实例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(customeSerialQue, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(customeSerialQue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实还有相对应的<code>xxx_f</code>的直接提交函数任务的 API，上面的两个函数实现中其实也是封装调用了下面的函数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当提交的 work 函数调用时，context 作为第一个参数传递给 work 函数，表示上下文数据。work 函数不能为空。</span></span><br><span class="line"><span class="type">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> *context, dispatch_function_t work);</span><br><span class="line"><span class="type">void</span> dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-sync-dispatch-barrier-async"><a href="#dispatch-barrier-sync-dispatch-barrier-async" class="headerlink" title="dispatch_barrier_sync&#x2F;dispatch_barrier_async"></a>dispatch_barrier_sync&#x2F;dispatch_barrier_async</h2><p>这个函数通常用于处理“读者写者”的问题。当多个线程同时对一份数据进行操作时，这时就很容易出现“线程不安全”的问题，在 GCD 出现之前我们通常使用<code>@synchronized()</code>锁或者<code>NSLock</code>锁来提供同步机制。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法会给对象<code>self</code>自动创建一个锁，等块中的代码执行完毕后就释放这个锁。它的缺点在于如果你代码中有大量的<code>@synchronized(self)</code>时，他们都共用同一个锁，程序可能会等待另一段于此无关的代码执行完毕。</p>
<p>有 GCD 之后，我们可以使用 Serial Queue 来提供替代方案，将读取与写入操作都写入同一个 Serial Queue 中，即可保证数据同步。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *tempString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeSerialQue, ^&#123;</span><br><span class="line">        tempString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tempString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="comment">//注：其实设置方法也可以使用 dispatch_async,因为这里并不需要等待返回值。</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeSerialQue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，我们可以发现这个问题中，多个读取方法是可以并发执行的，但是读取方法与写入方法之间不能并行执行。这时就可以请出<code>dispatch_barrier_sync</code>&#x2F;<code>dispatch_barrier_async</code>方法了。他们在 Concurrent Queue 上工作时提供了一个串行式的瓶颈，在队列中，通过他们提交的任务必须单独执行，这就意味着在 barrier 之前提交的任务必须先全部完成，然后再单独执行 barrier 提交的任务，执行完成后，队列又恢复正常的并发状态。<strong>这些特性意味着该方法只对 Concurrent Queue 有意义，因为 Serial Queue 本身就是一次执行一个任务的。</strong></p>
<p><img src="/images/Dispatch-Barrier-Swift.png" alt="Dispatch-Barrier-Swift"><br>再看一个动图,加深理解：<br><img src="/images/2018-07-1210_40_14.gif" alt="2018-07-12 10_40_14"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_customeConcurrentQue =dispatch_queue_create(<span class="string">&quot;com.zane.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *tempString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeConcurrentQue, ^&#123;</span><br><span class="line">        tempString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tempString;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    dispatch_barrier_async(_customeConcurrentQue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“读者写者问题”的实例代码如上，<strong>还有一点需要留意的是在上述代码中我们使用了<code>dispatch_queue_create</code>生成的自定义的并发队列，而没有使用<code>dispatch_get_global_queue</code>获取系统的全局并发队列，这是因为全局并发队列是系统资源，他不喜欢你来操纵它，所以<code>dispatch_barrier_async</code>函数用在它上面是没有效果的</strong>，效果跟使用<code>dispatch_async</code>函数一样。同理，可以暂时挂起队列和恢复队列执行的<code>dispatch_suspend/dispatch_resume</code>对于全局并发队列也是没有效果的。</p>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p><code>dispatch_after</code>用于一个任务的延后执行。它并不是在指定的时间执行，而是在指定的时间异步的将任务添加进 queue 中。它的一个简单的示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码与 3 秒后使用<code>dispatch_async</code>函数将 block 添加进 Main Queue 中的效果是一样的。它的第一个参数是<code>dispatch_time_t</code>类型的值，一般通过<code>dispatch_time</code>函数或者<code>dispatch_walltime</code>函数获取，前者通常用于计算相对时间，后者用于计算绝对时间。这个参数传入<code>DISPATCH_TIME_NOW </code>的话，倒不如直接使用<code>dispatch_async</code>函数。传入<code>DISPATCH_TIME_FOREVER</code>结果是未定义的。</p>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p><code>dispatch_once</code>是用来保证在应用程序中只执行一次处理的 API。它是线程安全的操作，因此几乎成了 Objctive-C 中实现单例的标准方法了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> SomeClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_once</code>的第一个参数是一个指向<code>dispatch_once_t</code>的指针，用来测试 block 中的任务是否已经完成。对于只需执行一次的任务来说，每次调用传入的该标记值应该完全相同。所以该指针指向的变量应该为静态变量或者全局变量。</p>
<h2 id="调度组（Dispatch-Group）"><a href="#调度组（Dispatch-Group）" class="headerlink" title="调度组（Dispatch Group）"></a>调度组（Dispatch Group）</h2><p>Dispatch Group 涉及到集合的同步化，你将多个任务添加到一个分组之后，就可以等待所有的任务执行完毕，或者提供一个回调函数后继续往下执行，当所有任务执行完毕后收到通知，执行回调函数。更厉害的是你提交的任务可以属于不同的 Queue。这种特性常用于必须在指定的任务都完成的情况下才能继续的情况。</p>
<p>先看一个简单的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_UTILITY, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//1生成一个 group</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">//2异步添加任务  </span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3挂起线程，等待任务完成或超时</span></span><br><span class="line"><span class="type">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)<span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;working&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先通过<code>dispatch_group_create</code>方法生成一个 group， 然后通过<code>dispatch_group_async</code>函数将 block 添加进 queue 中并与 group 联系起来之后，group 就会保持一个其中未完成任务的数量值，连接一个任务时增加该值，任务完成后减少该值。后面的<code>dispatch_group_wait</code>和<code>dispatch_group_notify</code>函数就是使用这个数量值来判断与这个 group 连接起来的所有任务是否完成。</p>
<p><code>dispatch_group_async</code>函数与<code>dispatch_async</code>相似，只是多了将任务 block 与 group 联系起来的作用。</p>
<p><strong>在这里我们使用了<code>dispatch_group_wait</code>函数，它会一直处于调用状态而不返回，从而阻塞了当前线程，直到 group 中的所有任务执行完成或者到达指定的时间。</strong>返回时若所有任务都执行完成，这个函数的返回值为 0，否则不为 0。你也可以指定时间参数为<code>DISPATCH_TIME_FOREVER</code>让它一直等待直到全部任务完成。</p>
<p>除了上面这种同步等待的方式，<strong>还可以使用<code>dispatch_group_notify</code>来异步的获取通知，它的调用不会阻塞当前线程，直接返回。</strong>在检测到队列中的所有任务完成时，<code>dispatch_group_notify</code>会将执行结束处理的 block 添加到 它指定的 queue 中。上例中的注释 3 后的部分可以替换成下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一个特殊的需求，试想：如果我们打算在任务 block 中添加一个想要异步执行的任务，比如下载一张图片等等，这个时候若使用下面这种方式添加任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;/images/thehitchhiker2.png&quot;</span>];</span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;download done!&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可能不会达到期望的效果，程序可能会在打印了<code>work done!</code>之后再打印<code>download done!</code>，这是因为连接在 group 上的任务是异步的，它的 block 程序已经执行完了，但是它的实际下载并没有完成，<strong>而如果我们想观察的是下载任务的结束的话就需要请出<code>dispatch_group_enter</code>与<code>dispatch_group_leave</code>的组合了</strong>。实例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;/images/thehitchhiker2.png&quot;</span>];</span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done&quot;</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>
<p>这样就能达到我们的目的了。<code>dispatch_group_enter</code>函数表示一个任务进入这个 group 了，会增加队列中未完成任务的数量值，<code>dispatch_group_leave</code>表示一个任务已经完成，会减少队列中未完成任务的数量值。这两个函数的组合使得我们可以更合理的控制 group 中未完成任务的个数，从而达到更精确的控制。<code>dispatch_group_enter</code>与<code>dispatch_group_leave</code>应该彼此对应，如果 enter 了而没有 leave，那么这一组任务将永远不会完成。</p>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> (^block)(size_t));</span><br></pre></td></tr></table></figure>
<p>这个 API 会将带参数的 block 提交到 queue 中，用于多次调用。调用次数由第一个参数 iterations 决定，并且他会阻塞当前线程等待任务的迭代次数完成后才返回。若 queue 参数是 Concurrent queue 的话，那么这些迭代任务可以并发执行。<strong>若是 Serial queue 的话，且该 queue 对应的线程是当前正在运行的线程，则会与<code>disparch_sync</code>一样发生死锁的情况。</strong>注意若迭代次数过多或者执行任务很简单的话，该函数所带来的并发收益不能抵消创建线程等其他开销，这种情况下最好还是使用<code>for</code>循环。</p>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_set_target_queue(dispatch_object_t object, <span class="built_in">dispatch_queue_t</span> queue);</span><br></pre></td></tr></table></figure>
<p>这个 API 可以为一个 object 设置 target queue,这个 object 可以是 dispatch queue、dispatch source或者 dispatch io 等等，target queue 最终决定了 object 所包含的任务会在哪个 queue 被调用。</p>
<p>queue 之间会形成一套层级体系，除了 Global queue 之外其他的 queue 都有其 target queue, queue 中的任务最终会在其 target queue 中执行。Global queue 在这个层级的最上层，沿着这个层级体系，所有的 queue 最终其 target queue 都会指向 Global queue和 Main queue。由 Global queue 的优先级（上文中讲到 Global queue 有如下优先级：high, default, low, 和 background）决定最终的执行优先级。使用<code>dispatch_queue_create</code>生成的 queue, 不管是 Serial queue 还是 Concurrent queue 其 target queue 默认都是 default 优先级的 Global queue。</p>
<p><code>dispatch_set_target_queue</code> 的过程是类似<code>dispatch_barrier_async</code>，所以它不会影响已经添加在 queue 中的任务的执行过程，只会影响设置完 target queue 之后添加的任务。要留意设置 target queue 时不要形成循环。</p>
<p>修改一个 object 的 target queue 会影响它原本的行为：</p>
<ul>
<li>Dispatch queues:将一个 queue 的 target queue 设置为 Serial queue 会同步化这个 queue。例如下图中的层级体系中（图片来自Effective Objective-C 2.0），排在 queue B与 queue C 中的 block 会在 queue A 中依次执行。于是排列在 queue A、B、C中的 block 总会错开串行执行（他们之间没有固定排序）。但是 queue A 与 queue D 中的 block 则可以并行执行。<img src="/images/targetqueuehierarchy.png" alt="target queue hierarchy">当然，如果你将一个 concurrent queue 的 target queue 指向 serial queue，那么其中的任务会串行的执行。</li>
<li>Dispatch sources: dispatch source 的 target queue 决定了它的事件处理的 block 将会被被提交到哪个 queue 中。</li>
<li>Dispatch I&#x2F;O channels:如果一个 Dispatch I&#x2F;O 的 target queue 被设置为 background 优先级的 Global queue 时，<code>dispatch_io_read</code>和<code>dispatch_io_write</code>这些操作将会被节流。</li>
</ul>
<p>若你有向一个 Serial queue 的前端添加任务的需求的话，使用<code>dispatch_set_target_queue</code>也可以满足你的需求：<br><img src="/images/jumpthequeue.png" alt="jump the queue"></p>
<h2 id="dispatch-queue-set-specific-dispatch-get-specific"><a href="#dispatch-queue-set-specific-dispatch-get-specific" class="headerlink" title="dispatch_queue_set_specific&#x2F;dispatch_get_specific"></a>dispatch_queue_set_specific&#x2F;dispatch_get_specific</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_queue_set_specific(<span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">void</span> *context, dispatch_function_t destructor);</span><br><span class="line"><span class="type">void</span> * dispatch_get_specific(<span class="keyword">const</span> <span class="type">void</span> *key);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_set_specific</code>适用于将任意数据以键值对的形式关联到指定的 queue 中。留意与<code>NSDictionary</code>中的对象比较不同的是这个函数中的 key 比较的是指针值，而不是指针所指向的对象。所以可以使用一个静态变量的指针来传入这个参数。不建议直接传入一个字符串常量。context 参数是与 key 关联的上下文参数，可以为 NULL。在 destructor 参数中可以释放前面的 context 参数,当队列释放时，或者有新的值与该 key 关联时，原有的值就会被移除，这个析构函数就会被调用。</p>
<p><code>dispatch_get_specific</code>这个函数需要在一个执行于 queue 中的 block 中调用，用以获取这个 queue 关联的数据，若不是在 queue 中运行的代码中调用则会返回 NULL。需要注意的是这个函数如果在指定的 queue 中查找不到 key 对应的数据，则会沿着 queue 的层级体系一直向上查找，直到找到数据或者达到根队列位置。要是传入的 queue 是 Global queue 也会返回 NULL。</p>
<p><code>dispatch_get_specific</code>的特性<strong>可以用于解决一个 queue 层级间的同步化导致死锁</strong>的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueueA = dispatch_queue_create(<span class="string">&quot;com.zane.serialQueueA&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueueB = dispatch_queue_create(<span class="string">&quot;com.zane.serialQueueB&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">dispatch_set_target_queue(serialQueueB, serialQueueA);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> kQueueSpecific;</span><br><span class="line"><span class="built_in">CFStringRef</span> stringValue = <span class="built_in">CFSTR</span>(<span class="string">&quot;queueA&quot;</span>);</span><br><span class="line"><span class="comment">//析构函数只能带有一个指针参数且返回值为空，这里可以使用 CFRelease 作为析构函数</span></span><br><span class="line">dispatch_queue_set_specific(serialQueueA, &amp;kQueueSpecific, (<span class="type">void</span> *)stringValue, (dispatch_function_t)<span class="built_in">CFRelease</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过 queue 特有关联数据，判断若在 queueA 中则直接执行 block，若不在则同步到 queueA 中执行，以此避免同步队列的死锁。</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueueB, ^&#123;</span><br><span class="line">    dispatch_block_t block = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);&#125;;</span><br><span class="line">    <span class="comment">//dispatch_get_specific 在 queueB 中找不到，再去它的 target queue 中寻找。</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> specificValue = dispatch_get_specific(&amp;kQueueSpecific);</span><br><span class="line">    <span class="keyword">if</span> (specificValue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(serialQueueA, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="信号量（Dispatch-Semaphore）"><a href="#信号量（Dispatch-Semaphore）" class="headerlink" title="信号量（Dispatch Semaphore）"></a>信号量（Dispatch Semaphore）</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>是一个同步对象，用于保持在 0 至指定最大值之间的一个计数值。当线程完成一次对该 semaphore 对象的等待（wait）时，该计数值减一；当线程完成一次对 semaphore 对象的释放（release）时，计数值加一。当计数值为0，则线程等待该 semaphore 对象不再能成功直至该 semaphore 对象变成 signaled 状态。semaphore 对象的计数值大于 0，为 signaled 状态；计数值等于0，为 nonsignaled 状态。</p>
<p>我们通过下面的例子看看 GCD 中的信号量怎么用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建一个信号量，初始值为1  </span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">//当信号量大于等于1时，dispatch_semaphore_wait 会将信号量减 1 ，并返回。若信号量小于1 ，则会一直等待，直到信号量大于1或者超时。该函数的返回值与 dispatch_group_wait 函数一样。</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [mutableArray addObject:@(i)];</span><br><span class="line">        <span class="comment">//在执行完需要同步的任务后，将信号量的值加 1，使得其他线程中最先等待该信号量的代码继续执行。</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要留意的是当信号量变量还在使用时，对该变量进行重新赋值或者置空会释放之前的信号量，从而引起崩溃！</p>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>Dispatch Source 是 BSD 系统内核惯有功能 kqueue 的包装，kqueue是在 XNU 内核中发生各种系统事件（例如 Unix 信号、文件描述符、Mach 端口事件、定时器等等）时，在应用程序编程方执行处理的技术。其内存占用小，尽量不占用资源，可以说是应用程序处理 XNU 内核中发生的各种时间的方法中最优秀的一种。</p>
<p>Dispatch Source 可以在这些事件发生时，在指定的 queue 中执行事件的处理。下面我们通过一个使用 Dispatch Source 设置定时器的例子看看他的简单用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 dispatch source 来监控底层系统事件，当事件发生时，将相应的 handler block 提交到指定 queue 中。第一个参数为监控的时间类型，第二个参数是与第一个参数有关的信号编号，地灿哥参数也是与第一个参数有关的特定时间标志，第四个参数为提交 handler block 的 queue。这个创建过程是异步执行的。</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line"><span class="comment">//设置定时器，第三个参数为间隔时间，这里设置为 DISPATCH_TIME_FOREVER 表示不需要重复。第四个参数为允许系统延迟的时间。注意即使该值为0，系统也可能会延迟这个定时器的执行。</span></span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), DISPATCH_TIME_FOREVER, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">//定时器指定时间所需要提交到 queue 中执行的任务 block</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer fired!&quot;</span>);</span><br><span class="line">    <span class="comment">//可以使用 dispatch_source_cancel 来取消一个 dispatch source </span></span><br><span class="line">    dispatch_source_cancel(timer);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//设置取消 dispatch source 时的处理，这个函数是异步执行的，取消之后就不会再有更多的 event 事件被传递，但是已经加入 queue 中的处理可以继续执行。</span></span><br><span class="line">dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer canceled&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch source 创建后是处于 suspend 状态的，在设置完 event handler 等属性之后需要调用 dispatch_resume 开启</span></span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>Dispatch source 是不可重入的，任何在 dispatch source 处于 suspend 状态或者 event handler 正在执行的时候接收的事件都会被合并，并在 dispatch source resume 之后或者 handler 返回后被提交。</p>
<p>Dispatch Source 与 Dispatch Queue 不同的是它是可以取消的，而且可以设置取消时的 handler。</p>
<p>需要留意的一点是 dispatch source 在 suspend 状态下，如果直接设置 source &#x3D; nil 或者重新创建 source 都会造成崩溃。正确的方式是在 resume 状态下调用<code>dispatch_source_cancel</code>后再重新创建。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>本文主要讨论了一些常用的 API,着重描述了使用时的一些注意点，容易导致问题的地方。阅读完会对iOS中使用 GCD 进行多线程编程有一个大概的认识。还有在一些其他情况下，诸如读取大文件等等也可使用 Dispatch I&#x2F;O及 Dispatch Data 等，可以用时再去研究。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">Grand Central Dispatch Tutorial for Swift 3: Part 1&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148515/grand-central-dispatch-tutorial-swift-3-part-2">Grand Central Dispatch Tutorial for Swift 3: Part 2&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/210/">Mastering Grand Central Dispatch WWDC2011 - Session 210</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/dispatch?language=objc">Dispatch</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
              <a href="/tags/Foundation/" rel="tag"># Foundation</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/05/AV%20Foundation%E7%AC%94%E8%AE%B0-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" rel="prev" title="AV Foundation笔记-音视频基础入门">
      <i class="fa fa-chevron-left"></i> AV Foundation笔记-音视频基础入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E7%AC%94%E8%AE%B0/" rel="next" title="《数据结构与算法之美》笔记-线性表数据结构">
      《数据结构与算法之美》笔记-线性表数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89%E4%B8%8E%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">进程（Process）与线程（Thread）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallelism%EF%BC%89%E4%B8%8E%E5%B9%B6%E5%8F%91%EF%BC%88Concurrency%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">并行（Parallelism）与并发（Concurrency）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%98%9F%E5%88%97%EF%BC%88Dispatch-Queue%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">分发队列（Dispatch Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%EF%BC%88Serial-Queue%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">串行队列（Serial Queue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%EF%BC%88Concurrent-Queue%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">并发队列（Concurrent Queue）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="nav-number">3.</span> <span class="nav-text">常用 API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-get-main-queue-dispatch-get-global-queue"><span class="nav-number">3.1.</span> <span class="nav-text">dispatch_get_main_queue&#x2F;dispatch_get_global_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-queue-create"><span class="nav-number">3.2.</span> <span class="nav-text">dispatch_queue_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-sync-dispatch-async"><span class="nav-number">3.3.</span> <span class="nav-text">dispatch_sync&#x2F;dispatch_async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-barrier-sync-dispatch-barrier-async"><span class="nav-number">3.4.</span> <span class="nav-text">dispatch_barrier_sync&#x2F;dispatch_barrier_async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-after"><span class="nav-number">3.5.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-once"><span class="nav-number">3.6.</span> <span class="nav-text">dispatch_once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%BB%84%EF%BC%88Dispatch-Group%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">调度组（Dispatch Group）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-apply"><span class="nav-number">3.8.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number">3.9.</span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-queue-set-specific-dispatch-get-specific"><span class="nav-number">3.10.</span> <span class="nav-text">dispatch_queue_set_specific&#x2F;dispatch_get_specific</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Dispatch-Semaphore%EF%BC%89"><span class="nav-number">3.11.</span> <span class="nav-text">信号量（Dispatch Semaphore）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Source"><span class="nav-number">3.12.</span> <span class="nav-text">Dispatch Source</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">参考：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
