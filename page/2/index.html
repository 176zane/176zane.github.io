<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:type" content="website">
<meta property="og:title" content="Deep Thought">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="姚七六">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/iOS%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/iOS%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">iOS 中的字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 11:30:06" itemprop="dateCreated datePublished" datetime="2021-04-22T11:30:06+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:42:01" itemprop="dateModified" datetime="2023-09-15T14:42:01+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机是 0 和 1 的世界，为了表示文本，我们就需要指定字符到数字的映射，这个映射就叫做编码。</p>
<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>ASCII（American Standard Code for Information Interchange:美国信息交换标准代码）是由美国国家标准协会制定的单字节字符编码方案。一个字节（8位）可以表示 256 种状态，ASCII 只使用到了一个字节中的 7 位，它将英文字母，数字 0-9 以及一些标点符号和控制字符映射为 0-127 这些整型，所以其最高位一直为 0。</p>
<p>随后，人们基于 ASCII 创建了各种编码系统，并使用了其没有使用的第八位来编码其他字符以期处理英语外的其他语言。但是由于 8 位空间的局限性以及这些编码系统的不兼容性使得一个统一的，全世界每个字符都有一个对应编码的编码标准的出现成为众望所归的事情。它就是 Unicode。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode 标准几乎为世界上各种书写系统里的每一个字符或符号定义了一个唯一的数字。这个数字叫做<strong>码点（code points）</strong>，以 U+xxxx 这样的格式写成，格式里的 xxxx 代表四到六个十六进制的数。</p>
<p>最初，Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。后来，Unicode 编码扩展到了 21 位（从 U+0000 到 U+10FFFF）。<strong>注意现在的 Unicode 不是 16 位的编码！它是 21 位的。</strong> 这 21 位提供了 1,114,112 个码点。编码空间被分为 17 个平面。每个平面有 65,536 个字符。0 号平面叫做<strong>基本多文种平面（Basic Multilingual Plane, BMP）</strong>，涵盖了几乎所有你能遇到的字符，除了 emoji。其它平面叫做补充平面，大多是空的。</p>
<h1 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h1><p>字符和码点之间的映射只完成了一半工作，还需要定义另一种编码来确定码点在内存和硬盘中要如何表示。Unicode 标准为此定义了几种映射，叫做 Unicode 转换格式（Unicode Transformation Formats，简称 UTF）。</p>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32 是一种固定长度的 Unicode 转换格式。每个码点都使用 32 位存储空间，因为太占用空间了从而在实际中很少使用。</p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16 本身是一种长度可变的编码。它是根据有 16 位固定长度的<strong>码元（code units）</strong>定义的。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做<strong>代理对（surrogate pair）</strong>。</p>
<p>和所有多字节长度的编码系统一样，UTF-16（以及 UTF-32）还得解决字节顺序的问题。在硬盘里存储或者通过网络传输字符串时，UTF-16 允许在字符串的开头插入一个<strong>字节顺序标记（Byte Order Mask,BOM）</strong>。字节顺序标记是一个值为 U+FEFF 的码元，通过检查文件的头两个字节，解码器就可以识别出其字节顺序。字节顺序标记不是必须的，Unicode 标准把大端顺序（big-endian byte order）定为默认情况。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序。有效空间利用及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p>
<h1 id="OC-中的-NSString"><a href="#OC-中的-NSString" class="headerlink" title="OC 中的 NSString"></a>OC 中的 NSString</h1><p><strong>NSString 对象代表的其实是用 UTF-16 编码的码元组成的数组。</strong> 因为在 <code>NSString</code> 开发的时候（它最初是作为 Foundation Kit 的一部分在 1994 年发布的），Unicode 还是 16 位的。</p>
<p>默认情况下，Clang 会把源文件看作以 UTF-8 编码的。只要你确保 Xcode 以 UTF-8 编码保存文件，你就可以直接用字符显示程序插入任意字符。如果你更喜欢用码点，最大到 U+FFFF 这个范围内的码点你可以以 @”\u266A”（♪）的方式输入，BMP 外其它平面的码点则以 @”\U0001F340”（🍀）的方式输入。有意思的是，C99 不允许标准 C 字符集里的字符用通用字符名（universal character name）来指定，因此不能这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">//NSString *s = @&quot;\u0041&quot;;</span><br></pre></td></tr></table></figure>

<p><code>NSString</code> 代表的是用 UTF-16 编码的文本，长度、索引和范围都基于 UTF-16 的码元。因此 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsstring/1414212-length?language=objc">length</a> 方法返回的是字符串中码元的数量而不是字符个数。 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/unichar?language=objc">unichar</a> 类型和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsstring/1414645-characteratindex?language=objc">characterAtIndex:</a>方法说的都是码元。</p>
<p><code>-[NSString length]</code> 返回字符串里 <code>unichar</code> 的个数。对于基本多文种平面（BMP）里所有的字符在 UTF-16 里都可以用一个码元表示。但是随着 emoji （在 1 号平面）的流行，实际使用中就会发现代理对，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *s = @&quot;\U0001F30D&quot;; // 🌭  </span><br><span class="line">NSLog(@&quot;%lu&quot;,[s length]);// 2</span><br></pre></td></tr></table></figure>
<p>由于这些组合字符序列的存在，会导致很多不便，幸而， <code>NSString</code> 提供了<code>enumerateSubstringsInRange:options:usingBlock: </code>方法，当参数为<code>NSStringEnumerationByComposedCharacterSequences</code>时，可以对真正的 Unicode 字符进行遍历。</p>
<h1 id="Swift-中的-String"><a href="#Swift-中的-String" class="headerlink" title="Swift 中的 String"></a>Swift 中的 String</h1><p>Swift 中的<code>String</code>类型字符串是例如<code>&quot;hello, world&quot;</code>，<code>&quot;albatross&quot;</code>这样的<strong>有序的 <code>Character</code> 类型的值的集合</strong>。每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 转换格式（UTF）。</p>
<p><strong>Swift 中每个<code>Character</code>类型的值代表一个可扩展的字形群</strong>。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。例如字母 é 可以用单一的 Unicode 标量 é(U+00E9)来表示。然而一个标准的字母 e(U+0065) 加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母 é。这个急促重音的标量形象的将 e 转换成了 é。在这两种情况中，字母 é 代表了一个单一的 Swift 的<code>Character</code>值，同时代表了一个可扩展的字形群。在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;E9&#125;</span>&quot;</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;65&#125;</span><span class="subst">\u&#123;301&#125;</span>&quot;</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 也是同一个单一的 Character值 é</span></span><br></pre></td></tr></table></figure>

<p>可扩展的字符群集可以由一个或者多个 Unicode 标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。</p>
<p>如果想要获得一个字符串中 Character 值的数量，可以使用<code>count</code>属性。需要注意的是通过 <code>count</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91URL%20Loading%20System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91URL%20Loading%20System/" class="post-title-link" itemprop="url">【翻译】URL Loading System</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-03 20:45:54" itemprop="dateCreated datePublished" datetime="2021-04-03T20:45:54+08:00">2021-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:41:36" itemprop="dateModified" datetime="2022-05-12T21:41:36+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc">URL Loading System</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>南峰子大佬之前有翻译过这个专题:<a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/07/11/url-load-system-1/">URL加载系统之一：基本结构</a>，但是随着官方文档的更新，这篇编程指南的原文也从苹果的文档中删除了，因此为复习一下网络框架，就顺手把这篇翻译了，以下开始正文。</p>
<h1 id="URL-加载系统"><a href="#URL-加载系统" class="headerlink" title="URL 加载系统"></a>URL 加载系统</h1><p>使用标准的网络协议通过与 URLs 交互，来与服务器进行交流。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>URL 加载系统通过使用标准的协议如 https 或者创建的自定义协议提供被 URLs 标识的特定资源的访问。加载是异步执行的，因此你的 app 可以保持响应并且在即将到来的数据或错误信息抵达时做出处理。</p>
<p>使用一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 实例来创建一个或多个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc">NSURLSessionTask</a> 实例,它可以用于给你的 app 获取和返回数据，下载文件，或者上传数据和文件到远程地址。你需要使用一个可以控制诸如如何使用 caches 和 cookies 或者是否允许使用蜂窝网络连接等行为的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">NSURLSessionConfiguration</a> 对象来配置这个 session 实例。</p>
<p>你可以使用一个 session 重复的创建多个任务，举个例子：一个网页浏览器可能会有不同的 session 用于正常访问和隐私访问，在隐私访问的 session 中并不缓存数据。图 1 展示了使用这些配置的两个 session 如何创建多个任务。</p>
<p><strong>图 1</strong> 使用 URL session 创建任务<img src="/images/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png" alt="6789dd96-afdc-4c18-b8eb-01f9012dc04d"></p>
<p>每个 session 都会与一个代理关联起来用于接收周期性的更新（或者 errors）。默认的代理调用你提供的处理任务完成 completion block；如果你创建了自定义的代理，就不会调用这个 block 了。</p>
<p>你可以配置一个运行在 background 的 session，这样当你的 app 挂起时，系统会代表你下载数据并且唤醒你的 app 来传递结果。</p>
<h1 id="First-Steps"><a href="#First-Steps" class="headerlink" title="First Steps"></a>First Steps</h1><h2 id="从网站获取数据到内存"><a href="#从网站获取数据到内存" class="headerlink" title="从网站获取数据到内存"></a>从网站获取数据到内存</h2><p>通过从 URL session 中创建一个 data task 直接接收数据到内存。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>对于与远程服务器的简单交互，你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatatask?language=objc">NSURLSessionDataTask</a> 类将数据接收到内存中（使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask?language=objc">NSURLSessionDownloadTask</a> 则不同，它会将数据直接保存到文件系统）。一个 data task 对于访问 web 服务端点来说是很完美的。</p>
<p>使用一个 URL session 来创建 task。如果你的需求很简单，就可以直接使用 NSURLSession 类的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1409000-sharedsession?language=objc">sharedSession</a> 单例对象。如果你想通过代理回调与传输过程交互的话，需要创建一个 session 而不是使用 sharedSession 单例。创建一个 session 时需要一个 NSURLSessionConfiguration 实例，同时还需传入一个实现了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a> 或其子协议的类。Session 可以被重用于创建多个 task，因此可以对每一个独特的配置创建一个 session 并将其作为属性存储到 session 实例中。</p>
<blockquote>
<p>注意<br>注意不要创建超出需求的 session，举例来说，如果你的 app 中几个部分需要差不多配置的 session，只需要创建一个并且共享它就可以了。</p>
</blockquote>
<p>一旦有了 session，就可以使用<code>dataTask()</code>的相关方法中的一个来创建 data task 了，新创建的 task 是处于 suspended 状态的，需要通过调用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/1411121-resume?language=objc">resume</a> 方法来启动它。</p>
<h3 id="使用-Completion-Handler-接收结果"><a href="#使用-Completion-Handler-接收结果" class="headerlink" title="使用 Completion Handler 接收结果"></a>使用 Completion Handler 接收结果</h3><p>获取数据最简单的方法是使用创建一个使用 completion handler 的 data task。这样 task 会传递服务器端的 response，data 也可能是 error 给你提供的 completion handler。下图展示了 session 和 task 之间的关系，以及结果如何传递到 completion handler 中。</p>
<p><img src="/images/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt="bf4501ff-82b2-4dd4-9ec3-243ef0e70d21"></p>
<p>要创建一个使用 completion handler 的 data task，需要调用 URLSession 的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411554-datataskwithurl?language=objc">dataTaskWithURL:</a>方法,在 completion handler 中要做 3 件事情：</p>
<ol>
<li>验证 error 参数是否为空，如果不是则说明传输发生错误；处理错误并退出。</li>
<li>检查 response 参数，验证代表成功的状态码及 MIME 类型是否是预期值，若不是，则处理服务器错误并退出。</li>
<li>按需求使用 data 实例。</li>
</ol>
<p>下面的代码展示了获取 URL 内容的<code>startLoad()</code>方法。通过使用 NSURLSession 类的共享单例创建一个 data task 用于传递结果给 completion handler。在检查了本地和服务端错误后，在 handler 中将数据转化为一个字符串，并用于插入代码到 WKWebView 中。当然，你的 app 可能会将数据用于其他用途，例如解析到数据模型中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">startLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://www.example.com/&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">            <span class="keyword">self</span>.handleClientError(error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">            (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.handleServerError(response)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> mimeType <span class="operator">=</span> httpResponse.mimeType, mimeType <span class="operator">==</span> <span class="string">&quot;text/html&quot;</span>,</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">            <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: url)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要<br>completion handler 是在与创建 task 不同的 GCD queue 中被调用的。因此任何使用 data 或 error 信息来更新 UI ，像更新 webView 的操作，应该像上例中被显式的放到 main queue 中去。</p>
</blockquote>
<h3 id="使用代理接收传输详情及结果"><a href="#使用代理接收传输详情及结果" class="headerlink" title="使用代理接收传输详情及结果"></a>使用代理接收传输详情及结果</h3><p>为了更进一步随着 task 的运行获取它的状态，你可以在创建一个 data task 时给 session 设置一个代理，而不是提供一个 completion handler。下图展示了这种方案：</p>
<p><img src="/images/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt="730c8e1b-654f-4eb9-9c63-d439a69ac5d2"></p>
<p>通过这种方式，一份份的数据随着他们的抵达会提供到 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate?language=objc">NSURLSessionDataDelegate</a> 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411528-urlsession?language=objc"> URLSession:dataTask:didReceiveData:</a>方法，直到传输完成或者失败。随着数据的传输过程代理对象还接收其他的事件。</p>
<p>当你使用这种方式时，你需要创建一个自己的 URLSession 实例,而不是使用共享的单例。创建一个新的 session 允许你设置自己的类作为其代理。正如下面的代码中展示的。</p>
<p>声明你的类实现了一个或多个代理协议（<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate?language=objc">NSURLSessionTaskDelegate</a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate?language=objc">NSURLSessionDataDelegate</a>, 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate?language=objc">NSURLSessionDownloadDelegate</a>）。然后使用初始化方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411597-sessionwithconfiguration?language=objc">sessionWithConfiguration:delegate:delegateQueue:</a> 来创建 URL session 的实例。可以在初始化方法中设置配置实例。例如，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/2908812-waitsforconnectivity?language=objc">waitsForConnectivity</a> 为<code>YES</code>是个好主意，这样 session 在所要求的连接不可用时会等待适当的连接，而不是直接失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.default</span><br><span class="line">    configuration.waitsForConnectivity <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: configuration,</span><br><span class="line">                      delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了使用这个 session 启动一个 data task 的<code>startLoad()</code>方法，并使用代理回调来处理接收的 data 和 error。这段代码实现了 3 个代理回调：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1410027-urlsession?language=objc">URLSession:dataTask:didReceiveResponse:completionHandler:</a>验证 response 有一个成功的 HTTP 状态码，而且 MIME 类型为<code>text/html</code>或者<code>text/plain</code>。如果任一情况不符合则取消这个 task,否则继续进行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411528-urlsession?language=objc">URLSession:dataTask:didReceiveData:</a>将 task 接收到的每一份 data 实例添加到名为<code>receivedData</code>的缓冲区中。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a>首先检查一下是否有传输级别的错误发生。如果没有就尝试将<code>receivedData</code>转换为一个字符串并将其设置为 webView 的内容。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receivedData: <span class="type">Data</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">startLoad</span>() &#123;</span><br><span class="line">    loadButton.isEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://www.example.com/&quot;</span>)<span class="operator">!</span></span><br><span class="line">    receivedData <span class="operator">=</span> <span class="type">Data</span>()</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: url)</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate methods</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, <span class="params">didReceive</span> <span class="params">response</span>: <span class="type">URLResponse</span>,</span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">URLSession</span>.<span class="type">ResponseDisposition</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(response.statusCode),</span><br><span class="line">        <span class="keyword">let</span> mimeType <span class="operator">=</span> response.mimeType,</span><br><span class="line">        mimeType <span class="operator">==</span> <span class="string">&quot;text/html&quot;</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(.cancel)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, <span class="params">didReceive</span> <span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.receivedData<span class="operator">?</span>.append(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">task</span>: <span class="type">URLSessionTask</span>, <span class="params">didCompleteWithError</span> <span class="params">error</span>: <span class="type">Error</span>?) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.loadButton.isEnabled <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">            handleClientError(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> receivedData <span class="operator">=</span> <span class="keyword">self</span>.receivedData,</span><br><span class="line">            <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">String</span>(data: receivedData, encoding: .utf8) &#123;</span><br><span class="line">            <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: task.currentRequest<span class="operator">?</span>.url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各种各样的代理协议提供了超出上面代码展示的方法。对于处理认证，重定向及其他的情况，在 URLSession 文档的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession?language=occ">Using a URL Session</a>部分讨论了传输过程中的众多回调方法。</p>
<h2 id="上传数据到网站"><a href="#上传数据到网站" class="headerlink" title="上传数据到网站"></a>上传数据到网站</h2><p>从 app 中 post 数据到服务器。</p>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>大多数 app 都与能够接收上传诸如图片或文件，或者使用接收如 JSON 这样结构化数据的网络服务 API 端点的服务器协同工作。想要从 app 中上传数据，要使用一个 NSURLSession 实例创建一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionuploadtask?language=objc">NSURLSessionUploadTask</a> 实例，upload task 使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 实例来描述了上传是如何被执行的。</p>
<h3 id="准备好用于上传的数据"><a href="#准备好用于上传的数据" class="headerlink" title="准备好用于上传的数据"></a>准备好用于上传的数据</h3><p>用于上传的数据可以是文件的内容，一个 stream，或者像下面代码中的数据。</p>
<p>很多网站服务端点接收 JSON 格式的数据，可以通过在如数组和字典这样的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/encodable?language=objc">Encodable</a> 类型上使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/jsonencoder?language=objc">JSONEncoder</a>类来创建。如下代码所示， 你可以声明一个遵循 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/codable?language=objc">Codable</a> 协议的结构体，创建该类型的实例，然后使用<code>JSONEncoder</code>来将实例编码成用于上传的 JSON 数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Order</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> customerId: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> items: [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order <span class="operator">=</span> <span class="type">Order</span>(customerId: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">                  items: [<span class="string">&quot;Cheese pizza&quot;</span>, <span class="string">&quot;Diet soda&quot;</span>])</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> uploadData <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONEncoder</span>().encode(order) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多种方式来创建一个数据实例，例如讲一个图片编码成 JPEG 或者 PNG 数据，或者将一个字符串使用 UTF-8 编码转换成数据。</p>
<h3 id="配置一个上传请求"><a href="#配置一个上传请求" class="headerlink" title="配置一个上传请求"></a>配置一个上传请求</h3><p>Upload task 需要一个 URLRequest 实例，如下代码所示，根据服务器的支持及预期设置请求的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/2011415-httpmethod?language=objc">httpMethod</a> 属性为“POST”或者“PUT”,使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/2011447-setvalue?language=objc">setValue(_:forHTTPHeaderField:)</a> 方法设置任何你想提供的除<code>Content-Length</code>之外的 HTTP header 值。因为 session 会从数据大小中自动计算出内容长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://example.com/post&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">request.httpMethod <span class="operator">=</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">request.setValue(<span class="string">&quot;application/json&quot;</span>, forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建并启动一个上传任务"><a href="#创建并启动一个上传任务" class="headerlink" title="创建并启动一个上传任务"></a>创建并启动一个上传任务</h3><p>要开始上传，需要调用 NSURLSession 类的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411518-uploadtaskwithrequest?language=objc">uploadTaskWithRequest:fromData:completionHandler:</a> 方法创建一个用于上传的 NSURLSessionTask 实例，传入之前设置好的 request 实例与 data 实例。鉴于 task 是以 suspend 状态开始的，你需要通过对 task 调用<code>resume</code>方法来开启一个网络加载过程。下面的代码使用了共享的 URLSession 实例，通过一个 completion handler 接收结果。在 handler 中在使用任何返回数据之前检查传输和服务器端的错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.uploadTask(with: request, from: uploadData) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">        print (<span class="string">&quot;error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(response.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">        print (<span class="string">&quot;server error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mimeType <span class="operator">=</span> response.mimeType,</span><br><span class="line">        mimeType <span class="operator">==</span> <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">        <span class="keyword">let</span> dataString <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">        print (<span class="string">&quot;got data: <span class="subst">\(dataString)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<h3 id="另一种选择，通过设置代理上传"><a href="#另一种选择，通过设置代理上传" class="headerlink" title="另一种选择，通过设置代理上传"></a>另一种选择，通过设置代理上传</h3><p>作为 completion handler 方式的另一种选择，你可以给你配置的 session 设置一个代理，然后使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1409763-uploadtaskwithrequest?language=objc">uploadTaskWithRequest:fromData:</a> 方法创建一个 upload task。在这种方案下，你要实现<code>NSURLSessionDelegate</code>和<code>NSURLSessionTaskDelegate</code>协议中的方法。这些方法会接收服务器的 response 及任何数据或传输错误。</p>
<h2 id="在后台下载文件"><a href="#在后台下载文件" class="headerlink" title="在后台下载文件"></a>在后台下载文件</h2><p>创建一个 task 在 app 处于非活跃状态时下载文件。<br>###概述<br>对应长时间的不紧急的传输任务，你可以创建运行在后台的 task，即使你的 app 已经被 suspended 了，这些任务依然可以运行,并且允许你的 app 恢复运行时访问这些已下载的文件</p>
<blockquote>
<p>注意<br>并不是所有的后台网络活动都必须按照这篇文章中描述的那样使用 background session 来完成，那些声明了合适的 background mode 的 app 可以使用默认的 URLSession 和 data task，就跟在前台运行一样。</p>
</blockquote>
<h3 id="配置-Background-Session"><a href="#配置-Background-Session" class="headerlink" title="配置 Background Session"></a>配置 Background Session</h3><p>按照如下步骤创建一个 background URL session,下面的代码展示了这个过程：</p>
<ol>
<li>提供一个在 app 中唯一的 session 标识符，使用 NSURLSession 的类方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1407496-backgroundsessionconfigurationwi?language=objc">backgroundSessionConfigurationWithIdentifier:</a> 来创建一个 background NSURLSessionConfiguration 对象。因为大部分 app 只需要少数 background session（通常只需要一个）,你可以使用一个固定的字符串作为标识符，而不是动态生成的。这个标识符并不需要全局唯一。</li>
<li>确保 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1617174-sessionsendslaunchevents?language=objc">sessionSendsLaunchEvents</a> 属性被设置为<code>true</code>(默认值)，来保证当任务完成且你的 app 在后台时会被系统唤醒。</li>
<li>对于对时间不敏感的任务，可以设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411552-discretionary?language=objc">discretionary</a> 属性为<code>true</code>，以便于系统在最理想的情况下执行传输任务，例如当设备充电或者连上 Wi-Fi 时。</li>
<li>使用 NSURLSessionConfiguration 实例来创建一个 NSURLSession 实例，这个 session 必须提供一个代理对象，来接收后台传输的各种事件。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> urlSession: <span class="type">URLSession</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> config <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;MySession&quot;</span>)</span><br><span class="line">    config.isDiscretionary <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    config.sessionSendsLaunchEvents <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>想要获取更多关于系统如何调度及执行后台任务，从 Bug 报告<a target="_blank" rel="noopener" href="https://developer.apple.com/bug-reporting/profiles-and-logs/">Profiles and Logs</a>下载并安装后台网络资料到你的 iOS 设备中。</p>
</blockquote>
<h3 id="创建并安排-Download-Task"><a href="#创建并安排-Download-Task" class="headerlink" title="创建并安排 Download Task"></a>创建并安排 Download Task</h3><p>你可以提供一个 URL 使用 session 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411482-downloadtaskwithurl?language=objc">downloadTaskWithURL:</a> 方法创建一个 download task，或者提供一个 URLRequest 实例通过 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession/1411481-downloadtaskwithrequest?language=objc">downloadTaskWithRequest:</a> 创建。你可以设置属性来帮助系统优化 task 的行为。</p>
<ol>
<li>如下代码所示，使用<code>downloadTaskWithURL</code>创建一个 download task。</li>
<li>这一步是可选的，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873413-earliestbegindate?language=objc">earliestBeginDate</a> 属性来安排下载在未来的某个时间点开始，下载并不保证会精确到这个时间进行，但是不会开始的更早。</li>
<li>为帮助系统更有效的安排网络活动，设置 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873401-countofbytesclientexpectstosend?language=objc">countOfBytesClientExpectsToSend</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873414-countofbytesclientexpectstorecei?language=objc">countOfBytesClientExpectsToReceive</a> 属性，这些值是期望传输数据的猜测最接近的上限，而且应该把 header 和 body 数据都计算入内。</li>
<li>调用<code>resume</code>启动这个 task.</li>
</ol>
<p>在下面的代码中，任务被设置为最早一个小时后，而且配置为发送大约 200 字节的数据，接收大约 500 KB 的数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> backgroundTask <span class="operator">=</span> urlSession.downloadTask(with: url)</span><br><span class="line">backgroundTask.earliestBeginDate <span class="operator">=</span> <span class="type">Date</span>().addingTimeInterval(<span class="number">60</span> <span class="operator">*</span> <span class="number">60</span>)</span><br><span class="line">backgroundTask.countOfBytesClientExpectsToSend <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">backgroundTask.countOfBytesClientExpectsToReceive <span class="operator">=</span> <span class="number">500</span> <span class="operator">*</span> <span class="number">1024</span></span><br><span class="line">backgroundTask.resume()</span><br></pre></td></tr></table></figure>
<h3 id="处理-App-挂起"><a href="#处理-App-挂起" class="headerlink" title="处理 App 挂起"></a>处理 App 挂起</h3><p>不同的 app 状态会影响到你的后台下载任务如何与 app 交互。在 iOS 中，你的 app 可能处于 foreground，suspended,或者甚至被系统 terminated。查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/core_app/managing_your_app_s_life_cycle?language=objc">Managing Your App’s Life Cycle</a>获取更多关于 app 状态的信息。</p>
<p>如果你的 app 在 background 状态，当其他进程的下载运行时，系统可能会 suspend 你的 app，这种情况下，当下载完成时，系统会恢复(resume)你的 app 并且调用 UIApplicationDelegate 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application?language=objc">application:handleEventsForBackgroundURLSession:completionHandler:</a> 方法。这个方法接收你前面创建的 session 标识符作为第二个参数。</p>
<p>这个代理方法还接受一个 completion handler 作为其最后一个参数。你应该立即将这个 handler 保存在它有意义的地方。或许作为 app delegate 或者实现了<code>NSURLSessionDownloadDelegate</code>的类的属性。在下面代码中，completion handler 被保存在了 app delegate 的名为<code>backgroundCompletionHandler</code>的属性中了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span><br><span class="line">                 <span class="params">handleEventsForBackgroundURLSession</span> <span class="params">identifier</span>: <span class="type">String</span>,</span><br><span class="line">                 <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        backgroundCompletionHandler <span class="operator">=</span> completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有事件传送完成后，系统会调用<code>NSURLSessionDelegate</code>的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc">URLSessionDidFinishEventsForBackgroundURLSession:</a> 方法，这时，取出保存在 app delegate 中的<code>backgroundCompletionHandler</code>然后执行它。下面的代码展示了这个过程。</p>
<p>注意<code>URLSessionDidFinishEventsForBackgroundURLSession:</code>方法或许会从其他 queue 中被调用，所有需要显式的切换到 main queue 中执行 handler(这个 handler 是从一个 UIKit 方法中接收的)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSessionDidFinishEvents</span>(<span class="params">forBackgroundURLSession</span> <span class="params">session</span>: <span class="type">URLSession</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> appDelegate <span class="operator">=</span> <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as?</span> <span class="type">AppDelegate</span>,</span><br><span class="line">            <span class="keyword">let</span> backgroundCompletionHandler <span class="operator">=</span></span><br><span class="line">            appDelegate.backgroundCompletionHandler <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        backgroundCompletionHandler()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如果-App-被-terminate-了则会重新创建-Session"><a href="#如果-App-被-terminate-了则会重新创建-Session" class="headerlink" title="如果 App 被 terminate 了则会重新创建 Session"></a>如果 App 被 terminate 了则会重新创建 Session</h3><p>如果在 app 处于 suspend 状态时被系统 terminate 了，系统会在后台重启 app。作为启动 的一部分，系统会使用同样的 session 标识符重新创建一个 background session。以便于系统将 download task 与你的 session 重新联系起来。这样不论 app 是被用户还是被系统启动，background session 都已经做好准备了。一旦 app 重新登录，一系列的事件就像上一部分讨论的那样，好像 app 被 suspend 然后 resume 了一样。</p>
<blockquote>
<p>注意<br>假如传输过程是在 app 处于 background 状态时被启动的，session 的配置中<code>discretionary</code>属性会被当做<code>YES</code>。</p>
</blockquote>
<h3 id="处理下载完成和错误"><a href="#处理下载完成和错误" class="headerlink" title="处理下载完成和错误"></a>处理下载完成和错误</h3><p>在 app resume 后（或者在前台了），你的<code>NSURLSessionDownloadDelegate</code>协议方法的实现会接收回调来更新传输的状态。</p>
<p>通过实现 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1411575-urlsession?language=objc">URLSession:downloadTask:didFinishDownloadingToURL:</a> 方法来处理下载完成。检查 download task 的 response 看是否有服务器端的错误如 404 状态码。如果有的话，则并没有得到下载的文件，这时应该退出了。如果下载完成，则最后一个参数是一个存放文件的本地 URL,这个地址只是在这个回调中有效，所以你应该将其转移到其他位置，例如 app 的文档目录下。</p>
<p>下面的代码展示了<code>URLSession:downloadTask:didFinishDownloadingToURL:</code>的实现。这个实现通过检查服务端错误码及移动文件到文档目录下完善了 background download 的过程。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>,</span><br><span class="line">                <span class="params">didFinishDownloadingTo</span> <span class="params">location</span>: <span class="type">URL</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse <span class="operator">=</span> downloadTask.response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>,</span><br><span class="line">        (<span class="number">200</span><span class="operator">...</span><span class="number">299</span>).contains(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">            print (<span class="string">&quot;server error&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> documentsURL <span class="operator">=</span> <span class="keyword">try</span></span><br><span class="line">            <span class="type">FileManager</span>.default.url(for: .documentDirectory,</span><br><span class="line">                                    in: .userDomainMask,</span><br><span class="line">                                    appropriateFor: <span class="literal">nil</span>,</span><br><span class="line">                                    create: <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> savedURL <span class="operator">=</span> documentsURL.appendingPathComponent(</span><br><span class="line">            location.lastPathComponent)</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(at: location, to: savedURL)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        print (<span class="string">&quot;file error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要处理客户端的下载错误，例如连接不到服务器这种，需要实现<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a> 方法。这个方法会在任何 task 完成时被调用；你只需要在最后一个参数不为 nil 的时候处理错误。</p>
<h3 id="遵守后台传输限制"><a href="#遵守后台传输限制" class="headerlink" title="遵守后台传输限制"></a>遵守后台传输限制</h3><p>通过 background session 传输，真正的传输过程是被与你的 app 不同的进程所执行的。因为重启你 app 的进程是相当耗费资源的操作，一些特性会变得不可用，导致如下的限制：</p>
<ul>
<li>Session 必须为每一个事件传递提供一个代理（对于上传或下载，代理与进程内传输表现一致）。</li>
<li>仅支持 HTTP 或者 HTTPS 协议（不支持自定义协议）。</li>
<li>总是会执行重定向，因此即使你实现了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411626-urlsession?language=objc">URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</a> 方法，也不会被调用。</li>
<li>只支持上传文件（上传一个数据实例或者 stream 会在 app 退出后失败）。</li>
</ul>
<h1 id="Requests-和-Responses"><a href="#Requests-和-Responses" class="headerlink" title="Requests 和 Responses"></a>Requests 和 Responses</h1><h2 id="NSURLRequest"><a href="#NSURLRequest" class="headerlink" title="NSURLRequest"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlrequest?language=objc">NSURLRequest</a></h2><h2 id="NSMutableURLRequest"><a href="#NSMutableURLRequest" class="headerlink" title="NSMutableURLRequest"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest?language=objc">NSMutableURLRequest</a></h2><h2 id="NSURLResponse"><a href="#NSURLResponse" class="headerlink" title="NSURLResponse"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlresponse?language=objc">NSURLResponse</a></h2><h2 id="NSHTTPURLResponse"><a href="#NSHTTPURLResponse" class="headerlink" title="NSHTTPURLResponse"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpurlresponse?language=objc">NSHTTPURLResponse</a></h2><h1 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h1><h2 id="获取缓存数据"><a href="#获取缓存数据" class="headerlink" title="获取缓存数据"></a>获取缓存数据</h2><p>控制 URL request 对之前缓存数据的使用。</p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>URL 加载系统会将 response 缓存到内存和磁盘中，以提升性能减少网络阻塞。</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache?language=objc">NSURLCache</a> 类用于从网络资源中缓存 response，你的 app 可以通过 URLCache 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1413377-sharedurlcache?language=objc">sharedURLCache</a> 属性获取到共享的缓存实例，或者也可以，在你的<code>NSURLSessionConfiguration</code>对象上设置不同的 cache 来创建自己的 cache 用于其他用途。</p>
<h3 id="设置-URL-Request-的缓存策略"><a href="#设置-URL-Request-的缓存策略" class="headerlink" title="设置 URL Request 的缓存策略"></a>设置 URL Request 的缓存策略</h3><p>每一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 实例包含一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlrequest/cachepolicy?language=objc">URLRequest.CachePolicy</a> 对象来指示是否应该缓存以及缓存应该如何被执行。你可以改变 request 的这个策略来控制它的缓存行为。</p>
<p>方便起见，<code>NSURLSessionConfiguration</code>有一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411655-requestcachepolicy?language=objc">requestCachePolicy</a> 的属性，所有通过使用这个配置的 session 创建的 request 都会从配置中继承这个缓存策略。</p>
<p>各种不同的缓存策略的行为描述在下表中。这个表展示了策略对于直接从缓存中加载还是访问数据源即服务器或本地文件系统的偏好。当前，仅有 HTTP 和 HTTPS response 会被缓存，对于 FTP 或者文件 URL,策略的唯一作用就是决定 request 是否被允许访问数据源。</p>
<table>
<thead>
<tr>
<th align="center">缓存策略</th>
<th align="center">本地缓存</th>
<th align="center">数据源</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NSURLRequestReloadIgnoringLocalCacheData</td>
<td align="center">忽略</td>
<td align="center">Accessed exclusively(不好翻译..)</td>
</tr>
<tr>
<td align="center">NSURLRequestReturnCacheDataDontLoad</td>
<td align="center">Accessed exclusively</td>
<td align="center">忽略</td>
</tr>
<tr>
<td align="center">NSURLRequestReturnCacheDataElseLoad</td>
<td align="center">先试一次</td>
<td align="center">仅在需要时访问</td>
</tr>
<tr>
<td align="center">NSURLRequestUseProtocolCachePolicy</td>
<td align="center">依据协议</td>
<td align="center">依据协议</td>
</tr>
</tbody></table>
<p>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlrequestcachepolicy?language=objc">NSURLRequestCachePolicy</a>获取更多关于 HTTP 和 HTTPS 中是如何实现<code>useProtocolCachePolicy</code>的说明。<code>useProtocolCachePolicy</code>是 URLRequest 对象的默认值。</p>
<blockquote>
<p>注意<br><code>useProtocolCachePolicy</code>将 HTTPS response 缓存到磁盘中，这可能对于保护用户数据安全来说不太理想，你可以通过像在<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/accessing_cached_data#2923215?language=objc">Manage Caching Programmatically</a>描述的一样，手动处理缓存行为来修改这种行为。</p>
</blockquote>
<h3 id="直接获取缓存"><a href="#直接获取缓存" class="headerlink" title="直接获取缓存"></a>直接获取缓存</h3><p>你可以通过 session 的 configuration 对象的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1410148-urlcache?language=objc">URLCache</a> 属性来获取或者设置 URLSession 对象所使用的缓存对象。</p>
<p>对缓存对象调用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1411817-cachedresponseforrequest?language=objc">cachedResponseForRequest:</a> 来查找一个给定 request 的 response 缓存。如果这个 request 的缓存数据存在的话就会返回一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse?language=objc">NSCachedURLResponse</a> 对象，否则返回 nil.</p>
<p>你可以检查 cache 对象所使用的资源，<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1407771-currentdiskusage?language=objc">currentDiskUsage</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1413505-diskcapacity?language=objc">diskCapacity</a> 属性代表了缓存所使用的文件系统资源。<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1408199-currentmemoryusage?language=objc">currentMemoryUsage</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1409781-memorycapacity?language=objc">memoryCapacity</a> 属性代表了缓存所使用的内存。</p>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1415377-removecachedresponseforrequest?language=objc">removeCachedResponseForRequest:</a> 方法来删除单个缓存数据。也可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1415231-removecachedresponsessincedate?language=objc">removeCachedResponsesSinceDate:</a> 来同时删除一个给定时间后的多个缓存数据。或者使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1417802-removeallcachedresponses?language=objc">removeAllCachedResponses</a> 删除整个缓存。</p>
<h3 id="通过写程序来管理缓存过程"><a href="#通过写程序来管理缓存过程" class="headerlink" title="通过写程序来管理缓存过程"></a>通过写程序来管理缓存过程</h3><p>你可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcache/1410340-storecachedresponse?language=objc">storeCachedResponse:forRequest:</a> 方法传入一个新的<code>CachedURLResponse</code>对象和一个<code>URLRequest</code>对象通过编写代码来写入缓存。</p>
<p>尤其是<code>URLSessionTask</code>对象处理的 response 的缓存，要在每一个 response 的基础上控制缓存，需要实现<code>NSURLSessionDataDelegate</code>协议的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411612-urlsession?language=objc">URLSession:dataTask:willCacheResponse:completionHandler:</a> 方法。注意这个代理方法只会对 upload task 和 data task 调用，而对于有 background 或 ephemeral（不会翻译了,暂时的？） 配置的 session 并不调用。</p>
<p>这个代理接收两个参数：一个<code>CachedURLResponse</code>对象和一个 completion handler。你的代理实现中必须直接调用这个 completion handler，传入下面的参数之一：</p>
<ul>
<li>提供的<code>CachedURLResponse</code>对象，来照原样缓存 response</li>
<li>nil, 来阻止缓存</li>
<li>一个新创建的<code>CachedURLResponse</code>对象，典型的情况是基于提供的对象，按需求修改一下<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1412269-storagepolicy?language=objc">storagePolicy</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1411900-userinfo?language=objc">userInfo</a> 字典。</li>
</ul>
<p>下面的代码展示了一个<code>urlSession(_:dataTask:willCacheResponse:completionHandler:)</code>的实现代码，其中拦截了 HTTPS 的请求，并且只允许将其缓存存储在内存中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>,</span><br><span class="line">                <span class="params">willCacheResponse</span> <span class="params">proposedResponse</span>: <span class="type">CachedURLResponse</span>,</span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">CachedURLResponse</span>?) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> proposedResponse.response.url<span class="operator">?</span>.scheme <span class="operator">==</span> <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updatedResponse <span class="operator">=</span> <span class="type">CachedURLResponse</span>(response: proposedResponse.response,</span><br><span class="line">                                                data: proposedResponse.data,</span><br><span class="line">                                                userInfo: proposedResponse.userInfo,</span><br><span class="line">                                                storagePolicy: .allowedInMemoryOnly)</span><br><span class="line">        completionHandler(updatedResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(proposedResponse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="认证和证书"><a href="#认证和证书" class="headerlink" title="认证和证书"></a>认证和证书</h1><h2 id="处理认证询问"><a href="#处理认证询问" class="headerlink" title="处理认证询问"></a>处理认证询问</h2><p>当服务器对一个 URL request 询问认证时进行合适的响应。</p>
<h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>当你的 app 使用一个<code>NSURLSessionTask</code>进行请求时，服务器可能会在继续进行前返回一个或多个认证询问。session task 会尝试帮你处理，当处理不了时，会调用你 session 的代理来处理这个问询。</p>
<p>实现这个段落中提到的代理方法来回答与你 app 连接的服务器的询问。如果你不实现这些代理方法，你的 request 可能会被服务器拒绝，你会收到一个包含 HTTP 状态码 401（Forbidden）的 response 而不是你想要的数据。</p>
<h3 id="决定适合的代理方法"><a href="#决定适合的代理方法" class="headerlink" title="决定适合的代理方法"></a>决定适合的代理方法</h3><p>依据你接收到的问询的种类，实现下面的一个，或者两个代理认证方法都实现。</p>
<ul>
<li>实现<code>NSURLSessionDelegate</code>协议的处理整个 session 范围内的认证问询的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1409308-urlsession?language=objc">URLSession:didReceiveChallenge:completionHandler:</a> 方法。这种问询就与传输层安全（TSL）生效一样，一旦你成功的处理了这种问询，那这个 NSURLSession 创建的所有 task 都会持续生效。</li>
<li>实现<code>NSURLSessionTaskDelegate</code>协议的处理指定 task 的问询的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411595-urlsession?language=objc">URLSession:task:didReceiveChallenge:completionHandler:</a> 方法，这种问询是像请求 username&#x2F;password 认证这种。从一个 session 中创建的每个 task 会提出各自的问询。</li>
</ul>
<blockquote>
<p>注意<br>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/nsurlprotectionspace_authentication_method_constants?language=objc">NSURLProtectionSpace Authentication Method Constants</a>了解哪个问询方法是作用于整个 session 的，哪个是针对 task 的。</p>
</blockquote>
<p>一个简单的例子，考虑一下当你请求一个被 HTTP 基本认证保护的 http URL（如<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7617">RFC 7617.</a>中定义的）,因为是一个指定 task 的认证，你需要实现<code>URLSession:task:didReceiveChallenge:completionHandler:</code>方法来处理它。</p>
<blockquote>
<p>注意<br>如果你是通过 https 连接的，你还会接收到一个服务器信任的认证，查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/handling_an_authentication_challenge/performing_manual_server_trust_authentication?language=objc">Performing Manual Server Trust Authentication</a>获取处理这种作用于 session 的认证的信息。</p>
</blockquote>
<p>下图展示了回复 HTTP 基本认证的策略<img src="/images/759d2099-d938-415f-ac8a-1a0cac9dea4b.png" alt="759d2099-d938-415f-ac8a-1a0cac9dea4b"><br>下面的章节描述了这个策略的实现</p>
<h3 id="决定认证问询的种类"><a href="#决定认证问询的种类" class="headerlink" title="决定认证问询的种类"></a>决定认证问询的种类</h3><p>当你接收到一个认证问询时，使用代理方法来决定认证的种类。代理方法接收一个描述所提出的问询<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge?language=objc">NSURLAuthenticationChallenge</a>实例,这个实例包含一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a>属性，它的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1415028-authenticationmethod?language=objc">authenticationMethod</a>属性表明了服务器所提出的认证种类（例如请求一个用户名和密码，或者一个客户端证书）。你使用该值来决定是否能处理这个认证问询。</p>
<p>你通过直接调用传入的 completion handler 来回复这个认证询问，向 handler 中传入一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition?language=objc">NSURLSessionAuthChallengeDisposition</a> 来表明你对认证问询的回复。你可以使用这个 disposition 参数来提供如下选择中合适的：一个认证，取消请求，或者允许默认的处理来进行。</p>
<p>下面代码检查了<code>authenticationMethod</code>是否是所期待的 HTTP 基本类型。如果<code>authenticationMethod</code>属性指明了其他种类的问询，它会调用 completion handler 并传入<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeperformdefaulthandling?language=objc">NSURLSessionAuthChallengePerformDefaultHandling</a>处理参数。告诉 task 使用满足认证问询的默认处理；否则 task 会继续直到下一个认证问询再次调用这个代理方法。这个过程会继续执行直到等到你要处理的 HTTP 基本认证。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> authMethod <span class="operator">=</span> challenge.protectionSpace.authenticationMethod</span><br><span class="line"><span class="keyword">guard</span> authMethod <span class="operator">==</span> <span class="type">NSURLAuthenticationMethodHTTPBasic</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个凭证实例"><a href="#创建一个凭证实例" class="headerlink" title="创建一个凭证实例"></a>创建一个凭证实例</h3><p>你需要依据接收到的认证问询的种类来提交一个合适的凭证来回复认证。对于 HTTP 基本认证和 HTTP 摘要认证，你可以提供一个 username 和 password。下面的代码展示了一个从用户界面创建 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a>实例的帮助方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">credentialsFromUI</span>() -&gt; <span class="type">URLCredential</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> username <span class="operator">=</span> usernameField.text, <span class="operator">!</span>username.isEmpty,</span><br><span class="line">        <span class="keyword">let</span> password <span class="operator">=</span> passwordField.text, <span class="operator">!</span>password.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLCredential</span>(user: username, password: password,</span><br><span class="line">                         persistence: .forSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回的<code>NSURLCredential</code>实例有个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredentialpersistence/nsurlcredentialpersistenceforsession?language=objc">NSURLCredentialPersistenceForSession</a> 持久化策略，所以它只会保存在创建这个 task 的<code>NSURLSession</code>实例中，对于其他 session 实例创建的 task 你需要提供新的<code>NSURLCredential</code>实例，对于 app 以后运行时也需要创建新的实例。</p>
<h3 id="调用-Completion-Handler"><a href="#调用-Completion-Handler" class="headerlink" title="调用 Completion Handler"></a>调用 Completion Handler</h3><p>一旦你尝试创建 credential 实例，你必须要调用 completion handler 来回复认证问询。</p>
<ul>
<li>如果你不能创建一个 credential，或者用户显式的取消了，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengecancelauthenticationchallenge?language=objc">NSURLSessionAuthChallengeCancelAuthenticationChallenge</a> 处理参数。</li>
<li>如果你创建了一个 credential 实例，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeusecredential?language=objc">NSURLSessionAuthChallengeUseCredential</a> 处理参数。</li>
</ul>
<p>下面的代码展示了这两种情况</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> credential <span class="operator">=</span> credentialOrNil <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">completionHandler(.useCredential, credential)</span><br></pre></td></tr></table></figure>
<p>如果你传入了一个服务器接受的凭证，这个 task 会继续执行上传或下载数据。</p>
<blockquote>
<p>重要<br>你可以将 completion handler 传给其他方法或者将其短暂的保存在属性中，用于等待用户完成 username&#x2F;password 输入。但是你最终还是要调用 completion handler 来完成认证使得 task 继续执行，即使你选择像下面的失败情况处理中那样取消认证。</p>
</blockquote>
<h3 id="优雅的处理失败情况"><a href="#优雅的处理失败情况" class="headerlink" title="优雅的处理失败情况"></a>优雅的处理失败情况</h3><p>如果凭证被拒绝，系统会再次调用你的代理方法。这种情况下，回调会将你被拒绝的凭证作为<code>NSURLAuthenticationChallenge</code>参数的属性<a href="proposedCredential">proposedCredential</a>传回给你。这个<code>NSURLAuthenticationChallenge</code>实例中还包含一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1416522-previousfailurecount?language=objc">previousFailureCount</a>属性，这个属性表示你的凭证被拒绝的次数。你可以使用这个参数来决定接下来怎么做。举个例子，如果<code>previousFailureCount</code> 比 0 大，你可以在使用已提交的凭证的字符串来在用户界面上插入一个重新输入 username&#x2F;password 的界面。</p>
<h2 id="执行服务器信任鉴定"><a href="#执行服务器信任鉴定" class="headerlink" title="执行服务器信任鉴定"></a>执行服务器信任鉴定</h2><p>在你的 app 中进行服务器安全凭证的评估。</p>
<h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>当你通过 URL request 使用安全连接时（例如 https）,你的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a>会接收到一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodservertrust?language=objc">NSURLAuthenticationMethodServerTrust</a> 认证类型的认证问询。与其他的服务器要求你的 app 证明自己身份的问询不同，这里是你来鉴定服务器的凭证的机会。</p>
<h3 id="决定何时进行服务器信任鉴定"><a href="#决定何时进行服务器信任鉴定" class="headerlink" title="决定何时进行服务器信任鉴定"></a>决定何时进行服务器信任鉴定</h3><p>大部分情况下，你应该将评估服务器信任度的工作交由 URL 加载系统的默认处理流程去做。当你没有设置代理或者没有处理认证问询时就会执行这些默认的行为。然后在下面这些场景中自己操作评估过程可能会更有用：</p>
<ul>
<li>你想要接受服务端证书而在默认情况下会被系统拒绝的情况。举个例子，你的 app 想要与使用自签名证书的开发服务器之间建立安全连接，而这个证书一般又不会与系统的信任证书的存储中的内容相匹配。</li>
<li>你想要拒绝这个证书而在默认情况下会被系统接受。举个例子，你想要你的 app 固定在几个由你控制的 key 或证书上，而不是接受任何有效的证书。</li>
</ul>
<p>下图展示了你的 app 如何通过提供一个代理方法来处理认证问询来执行手动的证书校验。这样就绕过了系统的默认处理。代理会直接比较服务器证书或公钥与存储在 app bundle 中的 证书或公钥（或哈希值等等）的拷贝。如果代理中判断这个服务器凭证是有效的，他就会信任这个服务器并允许继续连接。<br><img src="/images/851916ce-5c1c-4c23-b45b-c4632dacf24c.png" alt="851916ce-5c1c-4c23-b45b-c4632dacf24c"></p>
<blockquote>
<p>注意<br>如果你要连接的域名开启了 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsession#1776695?language=objc">App Transport Security (ATS)</a> ,NSURLSession 会强制使用。它应用于证书， TSL 版本，连接用的密码等安全要求。你不能放松一个使用 ATS 保护的域名的服务器的信任要求，但是你可以使用文章中面熟的技术收紧要求。查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247">Information Property List Key Reference</a>文章中的 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/plist/info/NSAppTransportSecurity">NSAppTransportSecurity</a> 获取更详细的信息。</p>
</blockquote>
<h3 id="处理服务器信任认证问询"><a href="#处理服务器信任认证问询" class="headerlink" title="处理服务器信任认证问询"></a>处理服务器信任认证问询</h3><p>实现<code>NSURLSessionDelegate</code>的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1409308-urlsession?language=objc">URLSession:didReceiveChallenge:completionHandler:</a>方法来手动处理服务器信任认证。当这个方法被调用时，你的实现中首先需要检查:</p>
<ul>
<li>问询种类是服务器信任，而不是其他类型的问询。</li>
<li>问询的主机名与你想要处理证书校验的证书匹配。</li>
</ul>
<p>下面的代码展示了这些情况，根据传入<code>URLSession:didReceiveChallenge:completionHandler:</code>的 challenge 参数的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a> 来检查上面列出的两项。首先，从 protection space 中获取 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1415028-authenticationmethod?language=objc">authenticationMethod</a> 检查认证问询的类型是不是 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodservertrust?language=objc">NSURLAuthenticationMethodServerTrust</a>，然后保证 protection space 中的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1418205-host?language=objc">host</a>匹配期待的主机名 <code>example.com</code>,如果这两个条件有一个没有满足，则会调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeperformdefaulthandling?language=objc">NSURLSessionAuthChallengePerformDefaultHandling</a>来让系统采用默认的方法处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protectionSpace <span class="operator">=</span> challenge.protectionSpace</span><br><span class="line"><span class="keyword">guard</span> protectionSpace.authenticationMethod <span class="operator">==</span></span><br><span class="line">    <span class="type">NSURLAuthenticationMethodServerTrust</span>,</span><br><span class="line">    protectionSpace.host.contains(<span class="string">&quot;example.com&quot;</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="校验-Challenge-中的凭证"><a href="#校验-Challenge-中的凭证" class="headerlink" title="校验 Challenge 中的凭证"></a>校验 Challenge 中的凭证</h3><p>获取 protection space 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1409926-servertrust?language=objc">serverTrust</a>属性（<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/security/sectrustref?language=objc">SecTrustRef</a>类的实例）来访问服务器的凭证。下面的代码展示了如何访问服务器凭证并接受或拒绝它。代码首先尝试从 protection space 中获取<code>serverTrust</code>属性，如果为空的话就回退到默认的处理去。然后将服务器凭证传给一个私有方法<code>checkValidity(of:)</code>来比较服务器凭证中的证书或公钥是否有 app bundle 中保存的有效值匹配。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> serverTrust <span class="operator">=</span> protectionSpace.serverTrust <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> checkValidity(of: serverTrust) &#123;</span><br><span class="line">    <span class="keyword">let</span> credential <span class="operator">=</span> <span class="type">URLCredential</span>(trust: serverTrust)</span><br><span class="line">    completionHandler(.useCredential, credential)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Show a UI here warning the user the server credentials are</span></span><br><span class="line">    <span class="comment">// invalid, and cancel the load.</span></span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦代码决定了服务器凭证的有效性，它会采取下面的两个动作：</p>
<ul>
<li>如果服务器认证凭证是有效的，从服务器凭证中创建一个 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a> 实例然后调用 completion handler 传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeusecredential?language=objc">NSURLSessionAuthChallengeUseCredential</a> 处置方式参数及新创建的凭证，这样会告诉系统接受服务器凭证。</li>
<li>如果平时是无效的，调用 completion handler 并传入 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengecancelauthenticationchallenge?language=objc">NSURLSessionAuthChallengeCancelAuthenticationChallenge</a>处理参数，这样告诉系统拒绝服务器凭证。</li>
</ul>
<blockquote>
<p>Tip<br>查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services?language=objc">Certificate, Key, and Trust Services</a> 了解更多关于如何校验<code>SecTrustRef </code>实例或者从中获取证书或公钥。</p>
</blockquote>
<h3 id="创建长期的服务器认证策略"><a href="#创建长期的服务器认证策略" class="headerlink" title="创建长期的服务器认证策略"></a>创建长期的服务器认证策略</h3><p>如果你需要在某些情况下手动验证服务器认证信息，安排好你 app 的工作如果你想要修改服务器凭证，要考虑下列准则：</p>
<ul>
<li>将你的服务器凭证与一个公钥匹配，而不是在 app bundle 中存储一个单独的证书。这允许你对同样的 key 重新发布证书来更新服务器，而不需要更新 app。</li>
<li>比较发布的 certificate authority’s(CA’s) key,而不是比较末端的 key，这样你可以部署包含新 key 的使用同一个 CA 签名的证书。</li>
<li>使用一组 keys 或 CAs ，这样装换服务器凭证时更方便。</li>
</ul>
<h2 id="NSURLAuthenticationChallenge"><a href="#NSURLAuthenticationChallenge" class="headerlink" title="NSURLAuthenticationChallenge"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge?language=objc">NSURLAuthenticationChallenge</a></h2><h2 id="NSURLCredential"><a href="#NSURLCredential" class="headerlink" title="NSURLCredential"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a></h2><h2 id="NSURLCredentialStorage"><a href="#NSURLCredentialStorage" class="headerlink" title="NSURLCredentialStorage"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlcredentialstorage?language=objc">NSURLCredentialStorage</a></h2><h2 id="NSURLProtectionSpace"><a href="#NSURLProtectionSpace" class="headerlink" title="NSURLProtectionSpace"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace?language=objc">NSURLProtectionSpace</a></h2><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="NSHTTPCookie"><a href="#NSHTTPCookie" class="headerlink" title="NSHTTPCookie"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpcookie?language=objc">NSHTTPCookie</a></h2><h2 id="NSHTTPCookieStorage"><a href="#NSHTTPCookieStorage" class="headerlink" title="NSHTTPCookieStorage"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nshttpcookiestorage?language=objc">NSHTTPCookieStorage</a></h2><h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h1><h2 id="URL-Loading-System-Error-Codes"><a href="#URL-Loading-System-Error-Codes" class="headerlink" title="URL Loading System Error Codes"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/1508628-url_loading_system_error_codes?language=objc">URL Loading System Error Codes</a></h2><h2 id="URL-Loading-System-Error-Info-Keys"><a href="#URL-Loading-System-Error-Info-Keys" class="headerlink" title="URL Loading System Error Info Keys"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/url_loading_system_error_info_keys?language=objc">URL Loading System Error Info Keys</a></h2><h1 id="遗留版本"><a href="#遗留版本" class="headerlink" title="遗留版本"></a>遗留版本</h1><h2 id="Legacy-URL-Loading-Systems"><a href="#Legacy-URL-Loading-Systems" class="headerlink" title="Legacy URL Loading Systems"></a><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url_loading_system/legacy_url_loading_systems?language=objc">Legacy URL Loading Systems</a></h2><p>将你的代码从使用这些遗留版本的对象迁移到新的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Understanding%20JavaScript%20Bind%20()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Understanding%20JavaScript%20Bind%20()/" class="post-title-link" itemprop="url">【翻译】Understanding JavaScript Bind ()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-07 10:53:02" itemprop="dateCreated datePublished" datetime="2021-03-07T10:53:02+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-16 17:30:54" itemprop="dateModified" datetime="2023-09-16T17:30:54+08:00">2023-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">前端笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/#top">Understanding JavaScript Bind ()</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>稍微写多点儿 JS 的人应该都见过<code>var self = this</code>这种写法，它是为了解决在不同函数调用时，<code>this</code>所指向的上下文参数变化的问题，你可以通过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN this</a>这篇文章先了解一下 JS 中的<code>this</code>。下文提供了将函数与其想要的<code>this</code>绑定的方法，以下是翻译正文。</p>
<h1 id="理解-JS-中的-Bind"><a href="#理解-JS-中的-Bind" class="headerlink" title="理解 JS 中的 Bind()"></a>理解 JS 中的 Bind()</h1><p>当你初学 JavaScript 时你可能并不关心函数绑定的问题，但是当你需要一个在其他函数中保持<code>this</code>内容的解决方案时，你可能并没有意识到你真正需要的就是<code>Function.prototype.bind()</code>函数。</p>
<p>第一次遇到这个问题时，当你切换上下文时可能会将<code>this</code>赋值给一个可以引用的变量。大多数人会选择<code>self</code>，<code>_this</code>或<code>context</code>作为变量名，这种方法是可用的，并不会出错，但是还有一种更好、更优雅的方式。</p>
<p><a target="_blank" rel="noopener" href="https://twitter.com/jaffathecake/">Jake Archibald</a>发推讨论过捕获<code>this</code>的问题：</p>
<blockquote>
<p>Ohhhh I would do anything for scope, but I won’t do that &#x3D; this — Jake Archibald (@jaffathecake) February 20, 2013</p>
</blockquote>
<p>当<a target="_blank" rel="noopener" href="https://twitter.com/sindresorhus/">Sindre Sorhus</a>讨论这个问题时，答案已经很显然了：</p>
<blockquote>
<p>@benhowdle $this for jQuery, for plain JS i don’t, use .bind() — Sindre Sorhus (@sindresorhus) February 22, 2013</p>
</blockquote>
<p>但是我却忽略了好几个月。</p>
<h1 id="我们想要解决什么问题？"><a href="#我们想要解决什么问题？" class="headerlink" title="我们想要解决什么问题？"></a>我们想要解决什么问题？</h1><p>在下面的代码中，将上下文对象赋值给一个变量是情有可原的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">specialFunction</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">anotherSpecialFunction</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">getAsyncData</span>: <span class="keyword">function</span> (<span class="params">cb</span>) &#123;</span><br><span class="line">        <span class="title function_">cb</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAsyncData</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            that.<span class="title function_">specialFunction</span>();</span><br><span class="line">            that.<span class="title function_">anotherSpecialFunction</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure>
<p>如果我们在上面的代码中直接调用<code>this.specialFunction()</code>，那么就会看到如下的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Object [object global] has no method &#x27;specialFunction&#x27;</span><br></pre></td></tr></table></figure>
<p>我们需要持有<code>myObj</code>对象的上下文用于回调函数的调用，调用<code>that.specialFunction()</code>函数使我们持有上下文并且正确的执行我们的函数。但是使用<code>Function.prototype.bind()</code>是更优雅的方法。</p>
<p>我们写个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAsyncData</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">specialFunction</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">anotherSpecialFunction</span>();</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="上例中做了什么？"><a href="#上例中做了什么？" class="headerlink" title="上例中做了什么？"></a>上例中做了什么？</h1><p><code>.bing()</code>只是创建了一个新的函数，当它被调用时会将<code>this</code>关键字设置为之前提供的值。这样我们就可以向<code>.bind()</code>函数传入期望的上下文参数即<code>this</code>（在这里就是<code>myObj</code>），然后当回调函数执行时，<code>this</code>就引用了<code>myObj</code>对象。</p>
<p>如果你想看看<code>Function.prototype.bind()</code>这个函数内部是如何运行的，可以看下面这个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">scope</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(scope);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是个简单的用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> boundFunc = bar.<span class="title function_">bind</span>(foo);</span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>我们创建了一个新的函数，其执行时会将<code>this</code>设置为<code>foo</code>对象，而不是像例子中直接调用<code>bar()</code>时，<code>this</code>默认指向的全局对象。</p>
<h1 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h1><table>
<thead>
<tr>
<th align="center">浏览器</th>
<th align="center">支持的版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Chrome</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">Firefox(Gecko)</td>
<td align="center">4.2(2)</td>
</tr>
<tr>
<td align="center">Internet Explore0</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">11.60</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">5.1.4</td>
</tr>
</tbody></table>
<p>如上所示，在 Internet Explorer 8 及以下版本中并不支持<code>Function.prototype.bind()</code>函数，所以你需要一个备用方案。</p>
<p>幸好，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a>提供了一个可靠的备选方案，用于没有在本地实现<code>.bind()</code>方法的浏览器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="variable language_">this</span>,</span><br><span class="line">        fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">        fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">                                 ? <span class="variable language_">this</span></span><br><span class="line">                                 : oThis,</span><br><span class="line">                    aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用法范例"><a href="#用法范例" class="headerlink" title="用法范例"></a>用法范例</h1><p>我发现当学习东西时，不仅要透彻的学习它的概念，还要将它用在实践中。幸好，下面的几个例子可以用于你的代码中或者解决你的问题。</p>
<h2 id="点击事件处理"><a href="#点击事件处理" class="headerlink" title="点击事件处理"></a>点击事件处理</h2><p>通常用于记录点击事件（或者点击后执行一个动作），这时就需要将信息保存在一个对象中，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">updateCount</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可能会像下面这样添加点击事件处理，在其中调用<code>logger</code>对象的<code>updateCount()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    logger.<span class="title function_">updateCount</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是为使得<code>updateCount()</code>函数中的<code>this</code>关键字表示正确的值，我们需要创建一个并不必须的匿名函数。</p>
<p>可以像下面这样优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, logger.<span class="property">updateCount</span>.<span class="title function_">bind</span>(logger));</span><br></pre></td></tr></table></figure>
<p>我们可以使用方便的<code>.bind()</code>函数来创建一个新的函数，然后将作用域设置的绑定到<code>logger</code>对象。</p>
<h2 id="SetTimeout"><a href="#SetTimeout" class="headerlink" title="SetTimeout"></a>SetTimeout</h2><p>如果你尝试过模板引擎（例如Handlebars）或者某种 MV* 框架（如 Backbone.js）,你可能会碰到这样的问题：当你渲染模板时，在调用了渲染方法后，想要立即获取新的 DOM 节点可能就会出错。</p>
<p>假设我们再初始化一个 jQuery 插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myView = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;/* a template string containing our &lt;select /&gt; */&#x27;</span>,</span><br><span class="line">    <span class="attr">$el</span>: $(<span class="string">&#x27;#content&#x27;</span>),</span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">afterRender</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myView.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure>
<p>你可能会发现这段代码可以正常运行，但并不总是这样。问题就在这里，它产生了一种竞争的情况：有时候渲染先执行完成，有时候插件的初始化先执行完成。</p>
<p>有些人可能不知道，我们可以通过使用<code>setTimeout()</code>函数来解决问题。</p>
<p>像下面这样简单的修改下代码，使得我们可以在 DOM 节点展示完成后立马安全的初始化我们的 jQuery 插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">afterRender</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>然而，我们会看到找不到<code>.afterRender()</code>函数的报错信息。</p>
<p>是时候祭出我们的<code>.bind()</code>方法了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">afterRender</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>现在，我们的<code>afterRender()</code>函数就会执行在正确的上下文环境中了。</p>
<h2 id="整理通过-querySelectorAll-绑定的事件"><a href="#整理通过-querySelectorAll-绑定的事件" class="headerlink" title="整理通过 querySelectorAll 绑定的事件"></a>整理通过 querySelectorAll 绑定的事件</h2><p>自从添加了诸如<code>querySelector</code>,<code>querySelectorAll</code>和<code>classList</code>等有用的方法后，DOM API 提升了很多。</p>
<p>然而，到目前为止并没有一个原生的方法来对一个<code>NodeList</code>中的所有节点添加事件，因此我们还需要使用<code>Array.prototype</code>中的<code>forEach</code>方法来循环添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.klasses&#x27;</span>), <span class="keyword">function</span>(<span class="params">el</span>)&#123;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, someFunction);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用<code>.bind()</code>方法来优化一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundForEach = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>,</span><br><span class="line">    forEach = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(unboundForEach);</span><br><span class="line"></span><br><span class="line"><span class="title function_">forEach</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.klasses&#x27;</span>), <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, someFunction);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在我们有一个整齐的方法来循环我们的 DOM 节点了。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如你所见，JS 的<code>bind()</code>函数可以巧妙的用于各种用途或者代码的整理。期望你能在需要时将<code>.bind()</code>添加进你的代码中来驾驭<code>this</code>值转换的能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/" class="post-title-link" itemprop="url">博客收藏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 14:56:19" itemprop="dateCreated datePublished" datetime="2020-03-09T14:56:19+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-16 01:18:29" itemprop="dateModified" datetime="2023-09-16T01:18:29+08:00">2023-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a target="_blank" rel="noopener" href="https://github.com/soapyigu/LeetCode-Swift">LeetCode-Swift</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QnAT-gnsx-3Yok4js5G_3A">【图解数据结构】 目录（持续更新）</a><br><a target="_blank" rel="noopener" href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/efce1a2a95ab">swift-algorithm-club翻译</a></p>
<h1 id="TCP-IP及网络相关"><a href="#TCP-IP及网络相关" class="headerlink" title="TCP&#x2F;IP及网络相关"></a>TCP&#x2F;IP及网络相关</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">TCP 协议简介</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html">协议森林</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d9c284b518825095879e7a5">面试官，不要再问我三次握手和四次挥手</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-10-6/">IP，TCP 和 HTTP</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿 上</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿 下</a><br><a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/WebSocket/iOS_WebSocket.md">微信,QQ这类IM app怎么做——谈谈Websocket</a><br><a target="_blank" rel="noopener" href="https://draven.co/whys-the-design/">为什么这么设计系列文章</a><br><a target="_blank" rel="noopener" href="http://www.52im.net/thread-1003-1-1.html">不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)</a><br><a target="_blank" rel="noopener" href="http://blog.p2hp.com/archives/4950">TCP&#x2F;IP指南</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/19395.html">HTTP API 认证授权术</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/21708.html">网络数字身份认证术</a><br><a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/23">HTTP2简介和基于HTTP2的Web优化</a></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p><a target="_blank" rel="noopener" href="http://awhisper.github.io/2017/02/26/%E6%89%AF%E6%B7%A1%EF%BC%9A%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E8%81%8A%E7%BC%96%E8%AF%91%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/">扯淡：大白话聊聊编译那点事儿</a><br><a target="_blank" rel="noopener" href="https://github.com/bestswifter/blog/blob/master/articles/compile-and-language.md">大前端开发者需要了解的基础编译原理和语言知识</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/86840">链接器：符号是怎么绑定到地址上的？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-wgBhE11xEXDS7Hqgq3FjA">iOS 微信编译速度优化分享</a><br><a target="_blank" rel="noopener" href="https://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM</a><br><a target="_blank" rel="noopener" href="https://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM 直播的 Slides</a><br><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thin-csapp-4/2016/04/16/">肆 链接 - 不同的代码如何协同</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-6-3/">Mach-O 可执行文件</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-6-2/">编译器</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XIcAdy6E3M45RoF6PDyqHg">iOS端数据库解决方案分析</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/58ff4c7544d9040069fb061e">微信客户端 SQLite 数据库修复实践</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/S51JaEOH98e2AzjejKn0kw">在 iOS 的 SQLite 数据库中应用 FMDB 库</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&mid=2650264198&idx=1&sn=35c6d49a70294c80bc028ed4d4fddce4&chksm=f40683b3c3710aa53a7c2f2e7185da72db59d1b66a1c3dd5aef4365ed02e0e990ae71d548f94&scene=0#wechat_redirect">iOS端数据库解决方案分析</a><br><a target="_blank" rel="noopener" href="https://github.com/Tencent/MMKV/wiki/iOS_tutorial_cn">MMKV for iOS&#x2F;macOS</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/By3fNvSF175a6rg9ke_QoQ">iOS 开发者应该掌握些 C++ 知识</a></p>
<h1 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tppYsCNS57i00RpQKAU5Yw">C 语言中的指针与数组</a></p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/i8hB_g8rJPl6QDi8Hf9y_w">8D85-8D8A-6280-672F ？</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-9-1/">NSString 与 Unicode</a></p>
<h1 id="OPENGL"><a href="#OPENGL" class="headerlink" title="OPENGL"></a>OPENGL</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/B4GxcNz9bybC6aUcnclVLw">20分钟让你了解OpenGL ——OpenGL全流程详细解读</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kRGfCQH91FGgD6AB9JMEkg">从零讲解 iOS 中 OpenGL ES 的纹理渲染</a><br><a target="_blank" rel="noopener" href="https://niyaoyao.github.io/2018/05/23/learning_opengl(es)_opengl_model_pipeline_and_practices/">Learning OpenGL(ES) —— OpenGL Model, Pipeline and Practices</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/nb/2135411">OpenGL ES落影合集</a></p>
<h1 id="计算机程序的构造与解释"><a href="#计算机程序的构造与解释" class="headerlink" title="计算机程序的构造与解释"></a>计算机程序的构造与解释</h1><p><a target="_blank" rel="noopener" href="https://github.com/DeathKing/Learning-SICP">Learning-SICP</a></p>
<h1 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h1><p><a target="_blank" rel="noopener" href="https://vc2tea.com/whats-shadowsocks/">写给非专业人士看的 Shadowsocks 简介</a><br><a target="_blank" rel="noopener" href="https://github.com/haoel/haoel.github.io">科学上网</a><br><a target="_blank" rel="noopener" href="https://manual.nssurge.com/book/understanding-surge/cn/">Surge 官方中文指引：理解 Surge 原理</a></p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a><br><a target="_blank" rel="noopener" href="https://github.com/geeeeeeeeek/git-recipes">🥡Git 菜单</a></p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><a target="_blank" rel="noopener" href="http://billie66.github.io/TLCL/book/">The Linux Commond Line</a></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn-regex</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a><br><a target="_blank" rel="noopener" href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a><br><a target="_blank" rel="noopener" href="https://academy.realm.io/posts/nspredicate-cheatsheet/">NSPredicate Cheatsheet</a></p>
<h1 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24339995">机器学习原来这么有趣！第一章：全世界最简单的机器学习入门指南</a><br><a target="_blank" rel="noopener" href="https://microsoft.github.io/ML-For-Beginners">https://microsoft.github.io/ML-For-Beginners</a></p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ihg_WjwkDRr-UppiFkFTzw">6k 字总结 flexbox 布局 ，收藏就行</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xIhkfOMiis6YWeQBv_i3Og">JavaScript权威面试指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/Objective-C%20%E5%9B%9E%E5%BF%86%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/22/Objective-C%20%E5%9B%9E%E5%BF%86%E5%BD%95/" class="post-title-link" itemprop="url">Objective-C 回忆录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-22 13:48:14" itemprop="dateCreated datePublished" datetime="2019-10-22T13:48:14+08:00">2019-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:40:44" itemprop="dateModified" datetime="2022-05-12T21:40:44+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：这篇基本上是重新翻看《Objective-C 基础教程》时的一些阅读笔记，内容偏入门级。熟悉 ObjC 的就不需要翻啦(ー&#96;´ー)。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>早在 20 世纪 80 年代初，Brad Cox 为了融合流行的、可移植的 C 语言和优雅的 Smalltalk 语言的优势，设计出了 Objective-C 语言，它是 C 语言的一个扩展集。1985年，Steve Jobs 创立了 NeXT 公司，他们使用 Objective-C 语言基于 Unix 开发了 NeXTSTEP 操作系统。而在 Apple 收购了 NeXT 之后，从 NeXTSTEP 和 OPENSTEP 编程环境演化出来了著名的 Cocoa 编程工具箱，从此 Cocoa 和 Objective-C 就成了 Apple 公司 OS X 和 iOS 操作系统的核心。</p>
<h2 id="Objective-C-小知识点"><a href="#Objective-C-小知识点" class="headerlink" title="Objective-C 小知识点"></a>Objective-C 小知识点</h2><ul>
<li>Xcode 通过 .m 扩展名来表示文件使用的时 Objective-C 代码，应由 Objective-C 编译器处理。而 C 编译器处理 .c 文件，C++ 编译器处理 .cpp 文件。所有这些编译工作默认由 LLVM 处理。（扩展名 .m 表示 message）</li>
<li>通过<code>#import</code>导入的头文件使用<strong>预编译头文件</strong>（压缩的、摘要形式的头文件）的方式来加快读取速度。</li>
<li>导入头文件使头文件和源文件之间建立了一种紧密的依赖关系。如果头文件有任何变化，那么所以依赖 它的文件都得重新编译。</li>
<li>头文件中的<code>@class</code>指令用于创建一个前向引用，在编译器只需要知道这是一个类，后面只会通过指针去引用它时提供了一个缩短编译时间的好方法，此外，还可以有效解决两个类之间循环依赖的问题。但是在诸如继承时则不能使用，因为编译器需要知道所有超类的信息才能成功为其子类编译<code>@interface</code>部分。</li>
<li><code>@selector()</code>返回一个指向有特定名称的选择器的 SEL 指针。什么是选择器呢？选择器只是一个方法名称，但它以 Objective-C 运行时使用的特殊方式编码，以快速的执行查询，可以使用<code>@selector()</code>编译指令圆括号中的方法名称来指定选择器。</li>
<li><code>@protocol()</code>返回一个指向有特定名称的协议的 Protocol * 指针。</li>
<li>Objective-C 运行时生成一个类的时候，会创建一个代表该类的类对象。类对象包含了指向超类、类名和类方法列表的指针，还包含一个 long 型的数据，为新创建的实例对象指定大小。用来创建新对象的类方法称为工厂方法。</li>
</ul>
<p><img src="/images/SEL-Methods-IMP.png" alt="SEL-Methods-IMP"></p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>在早期的 32 位系统下，<code>BOOL</code>实际上是一种对带符号的字符类型（<code>signed char</code>）的<code>typedef</code>，它使用 8 位的存储空间，通过<code>#define</code>指令把<code>YES</code>定义为 1，<code>NO</code>定义为 0。编译器只将<code>BOOL</code>认作 8 位二进制数，所以将大于 1 字节的整型值赋给一个<code>BOOL</code>变量，那么只有低位字节会被用作<code>BOOL</code>值。<br><img src="/images/Objective-C%E4%B8%AD%E7%9A%84%E7%9C%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E5%80%BC.png" alt="Objective-C中的真值类型和数值">图：<a target="_blank" rel="noopener" href="http://nshipster.cn/bool/">BOOL &#x2F; bool &#x2F; Boolean &#x2F; NSCFBoolean</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/bool?language=objc">目前在64位 iOS, tvOS, watchOS 系统中 BOOL 其实是 bool 的 typedef</a>，也就是说 BOOL 只有0（NO）,1(YES)两个值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS, tvOS, watchOS:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="type">BOOL</span>;</span><br><span class="line"><span class="comment">// macOS</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">BOOL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>OOP 是一种编程架构，可构建由多个对象组成的软件。软件就好比存在于计算机中的小零件，它们通过互相传递信息来完成工作。<br>过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。数据可以通过间接方式引用代码，代码可以对数据进行操作。<br>对象到底是什么呢？<strong>对象是一种包含值和指向其类的隐藏指针的结构体。类是一种能够实例化成对象的结构体，类含有一个指针用于指向实现某个功能的代码。（类对象有什么用呢？让每个对象直接指向各自的代码不是更简单嘛？确实是更简单一些，而且某些 OOP 系统也是这样做的。但是拥有类对象会具备极大的优势，如果在运行时改变某个类，则该类的所有对象都会自动继承这些变化。）</strong><br>在 Objective-C 中调用方法时，一个名为 self 的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象，例如，在代码<code>[circle setFillColor:kRedColor]</code>中，方法将 circle 作为 self 参数进行传递。由此方法可以使用此隐藏的 self 参数查找并操作对象的数据。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="方法调度"><a href="#方法调度" class="headerlink" title="方法调度"></a>方法调度</h3><p>对象在收到消息时，如何知道要执行哪个方法呢？当代码发送消息时，Objective-C 的方法调度机制将在当前类中搜索相应的方法，如果无法在接受消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E5%BA%A6.png" alt="支持继承程序中的方法调度"></p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RoundedRectangle</span> : <span class="title">Shape</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>下图展示了RoundedRectangle对象的内存布局。<br><img src="/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="对象中实例变量的布局"><br>最上面是 NSObject 对象声明的名为 isa 的实例变量，它保存着指向对象当前类的指针，接下来是由 Shape 类声明的两个实例变量 fillColor 和 bounds，最后是由 RoundedRectangle 类声明的实例变量 radius。<br>每个方法调用都获得了一个名为 self 的隐藏参数，它是一个指向接收消息的对象的指针，self 指向继承链中第一个类的第一个实例变量，如上图所示也就是 isa 变量。因为编译器已经看到了所有这些类的 @interface 声明，也就知道了对象中的实例变量的布局，根据这个<strong>基地址再加上偏移地址</strong>，编译器就可以查找其他实例变量的位置了。<br><strong>脆弱的基类问题</strong>：在 Snow Leopard 和 iOS4.0 系统中引入 64 位的 Objective-C 运行时之前，即使苹果工程师想在 NSObject 中添加其他的实例变量也是无法做到的，因为在编译器生成的程序中，那些<strong>偏移位置是通过硬编码</strong>实现的。在引入运行时之后它使用<strong>间接寻址方式</strong>确定了变量的位置（把<strong>实例变量当做一种存储偏移量所用的特殊变量</strong>，交由<strong>类对象</strong>管理，偏移量会在运行时查找，如果类的定义变了，那么存储的偏移量也就变了。因此任何时候都能访问到实例变量正确的偏移量，甚至可以在运行时向类中新增实例变量,这就是<strong>稳固的 ABI</strong> 机制，通过这个机制我们可以在类扩展或实现文件中定义实例变量），从而解决了这个问题。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>为了调用继承的方法在父类中的实现，需要使用 super 作为方法调用的目标。super 既不是参数也不是实例变量。<strong>当你向 super 发送消息时，实际上是在请求 Objective-C 向该类的超类发送消息。</strong> 如果超类中没有定义该消息，Objective-C 会和平常一样继续在继承链上一级中查找。<br><img src="/images/%E8%B0%83%E7%94%A8%E8%B6%85%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95-1.png" alt="调用超类的方法"></p>
<h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>如果要对其他对象中的属性进行操作，应该尽量使用对象提供的存取方法，绝对不能直接改变对象里面的值，例如：<code>main()</code>函数不应该直接访问 Car 类的 engine 实例变量（通过<code>car-&gt;engine</code>的方法）来改变 engine 的属性，而应该使用 setter 方法进行更改。<br><strong>在 Objective-C 中所有对象间的交互都是通过指针实现的。</strong></p>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p>为什么诸如 CGRect, CGPoint, CGSize 等数据类型是 C 的 struct 而不是对象呢？原因在于性能！GUI 程序通常会使用许多临时的坐标、大小和矩形区域来完成工作。但是所有的 Objective-C对象都是动态分配的，而动态分配是一个代价较大的操作，它会消耗大量的时间。</p>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><p>C 字符串是将字符串作为简单的字符数组进行处理，并且在数组最后添加尾部的零字节作为结束标志。<br>NSString 的 length 实例方法能够精确无误的处理各种语言的字符串。因为一个字符占用的可能多余一个字节。这样在 C 语言的<code>strlen()</code>函数只能计算字节数，就会返回错误的数值。</p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><p>NSArray 是用来存储对象的有序列表，你可以在 NSArray 中放入<strong>任意类型</strong>的对象，但是它只能存储 Objective-C 对象，而不能存储原始的 C 语言基础数据类型，如 int， float, enum, struct 和 NSArray 中的随机指针。此外，它还不能存储 nil。<br>没有创建 NSMutableArray 和 NSMutableDictionary 的字面量语法。<br>对可变数组进行枚举操作时，需要注意<strong>不能通过添加或删除这类方式来改变数组的容量</strong>。<br>NSArray 中添加了通过代码块来枚举对象的方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>为什么有了快速枚举还要代码块枚举呢？因为通过代码块可以让循环操作并发执行，而通过快速枚举，执行操作要一项项地线性完成。</p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>为什么不用数组存储而要用字典呢？ 因为字典（也被称为散列表）使用的是键查询的优化方式，可以立即找出要查询的数据而不需要遍历整个数组。<br>尽量不要创建 NSString， NSArray， NSDictionary 的子类，因为它们都是以类簇的方式实现的。</p>
<h3 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h3><p>NSValue 可以封装任意值。</p>
<h3 id="NSPredicate-（谓词）"><a href="#NSPredicate-（谓词）" class="headerlink" title="NSPredicate （谓词）"></a>NSPredicate （谓词）</h3><p>NSPredicate用于指定数据被过滤的条件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> horsepower;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Engine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">Engine *engine = [[Engine alloc] init];</span><br><span class="line">engine.horsepower = <span class="number">300</span>;</span><br><span class="line">Car *car = [[Car alloc]init];</span><br><span class="line">car.engine = engine;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower &gt;= 120&quot;</span>];</span><br><span class="line"><span class="type">BOOL</span> match = [predicate evaluateWithObject:car];</span><br></pre></td></tr></table></figure>
<p><code>-evaluateWithObject:</code>计算指定对象 car 是否满足谓词 predicate 中的条件。本类的谓词中使用 engine.horsepower 作为键路径，对 car 对象应用<code>valueForKeyPath:</code>方法获取引擎的马力。然后比较其是否大于等于 120。<br>NSPredicate 一般用于对集合类中数据的过滤，使用方法可以参考 NSHipster 的这篇文章：<a target="_blank" rel="noopener" href="http://nshipster.cn/nspredicate/">NSPredicate</a>。另外，在谓词字符串中可以使用 <code>LIKE</code> 如：<code>&quot;name LIKE &#39;???er*&#39;&quot;</code> 将会匹配 er 前有3个字符，后面还有一些字符的 name 字符串变量。 也可以是使用 <code>MATCHES</code> 运算符类赋给它一个正则表达式，从而来选择匹配的值。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>如果一个对象内有指针指向其他对象的实例变量，则称该对象拥有这些对象。如果一个函数创建了一个对象，则称该函数拥有这个对象。“拥有一个对象”意味着该实体要负责确保对其所有的对象进行清理。<br>NSObject 类提供了一个<code>-(id)autorelease;</code>的方法，当给一个对象发送 autorelease 消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送 release 消息。例子如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;I am %d years old&quot;</span>,<span class="number">4</span>]];</span><br><span class="line">    <span class="keyword">return</span> [description autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存管理规则：</p>
<ol>
<li>使用 new 、 alloc 和 copy 方法创建一个对象时，该对象的引用计数值为 1，当不再使用该对象时，你应该想该对象发送一条 release 或 autorelease 消息。这样对象将在使用寿命结束时被销毁。</li>
<li>当使用其他方法获得一个对象时，则假设该对象的保留计数器值为 1，而且已经被设置为自动释放了。</li>
<li>如果你保留了某个对象，就需要释放或者自动释放该对象，必须保持 retain 方法和 release 方法的使用次数相等。</li>
</ol>
<p><strong>自动释放池的释放时间是完全确定的：要么是在代码中自己手动销毁，要么是使用 AppKit 时在时间循环结束时销毁。</strong>自动释放池以栈的形式实现：当你创建了一个新的自动释放池时，它就被添加到栈顶。接收 autorelease 消息的对象将被放入最顶端的自动释放池中。<br>Objective-C 的垃圾回收器是新型的垃圾回收器，它定期检查变量和对象并且跟踪它们之间的指针，当发现没有任何变量指向某个对象时，就将该对象视为应该丢弃的垃圾。与自动释放池一样，垃圾回收也是在时间循环结束时触发的。</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>iOS 无法使用垃圾回收，垃圾回收期在运行时工作，通过返回的代码来定期检查对象。ARC 是在编译时进行工作的。它在代码中插入了合适的 retain 和 release 语句。<br>ARC 只对可保留的对象指针有效，主要有三种：</p>
<ul>
<li>代码块指针</li>
<li>Objective-C 对象指针</li>
<li>通过 _<em>attribute</em>((NSObject)) 类型定义的指针</li>
</ul>
<p>声明变量时使用 __weak 关键字或对属性使用 weak 特性的归零弱引用会在指向的对象释放之后，将这些弱引用设置为零（nil）。<br>使用 ARC 时要注意：</p>
<ul>
<li>属性名称不能以 new 开头。</li>
<li>@property 声明的对象其内存管理特性默认为 assign。</li>
</ul>
<h3 id="拥有者权限"><a href="#拥有者权限" class="headerlink" title="拥有者权限"></a>拥有者权限</h3><p>ARC 中的可保留对象指针可以与非可保留对象指针通过<strong>桥接转换</strong>的 C 语言技术来进行转换并对其指针的所有权进行管理。</p>
<ul>
<li><code>__bridge type</code> 操作符：可以使 <code>void *</code> 和 <code>id</code> 对象指针相互转换，这个类型转换会传递指针但是不会传递它的所有权。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *nsString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge <span class="built_in">CFStringRef</span>)nsString;</span><br><span class="line"><span class="comment">//cfString接收了指针，但指针的所有权仍然由 nsString 保留，使用完 cfString 变量之后不需要调用 CFRelease 函数去释放它。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_retained CF type</code> 操作符：这个类型转换会使要转换赋值的变量也持有所赋值的对象。会给对象的保留计数器加 1。__bridge_retained 转换与 retain 类似。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *nsString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)nsString;</span><br><span class="line"><span class="built_in">CFRelease</span>(cfString);</span><br><span class="line"><span class="comment">//cfString 和 nsString 同时持有对象。使用完后 nsString 由 ARC 负责释放，但是 cfString 需要你调用 CFRelease() 函数释放。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_transfer Objective-C type</code> 操作符，与上一个执行相反的操作，被转换的变量所持有的对象在该变量被赋值给转换目标后随之释放。__bridge_transfer 转换与 release 相似。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span> *cString = <span class="string">&quot;cString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreateWithCString</span>(<span class="literal">NULL</span>, cString, kCFStringEncodingASCII);        </span><br><span class="line"><span class="built_in">NSString</span> *nsString = (__bridge_transfer <span class="built_in">NSString</span> *)cfString;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,nsString);</span><br><span class="line"><span class="comment">//nsString 持有该对象，使用完后 nsString 由 ARC 负责释放, cfString 在转换完成后释放。</span></span><br></pre></td></tr></table></figure>
<p><strong>在 struct 和 union 中是不能使用保留对象的。</strong>可以通过使用 void* 和桥接转换来解决这个问题。</p>
<h3 id="记录一些疑惑："><a href="#记录一些疑惑：" class="headerlink" title="记录一些疑惑："></a>记录一些疑惑：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *ocString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line">        <span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)ocString;</span><br><span class="line">        <span class="built_in">CFShow</span>(cfString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码按照上面的理解，cfString 和 ocString 都是持有了对象的，但是用 Xcode9 的 analyze 来分析并没有曝出内存泄露问题？ 不太能理解，希望看到的大神讲解一下。求教育！</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><h3 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h3><p>向某个类发送 alloc 消息就是从操作系统获得一块内存，并将其指定为存放对象的实例变量的位置。alloc 方法还顺便将这块内存区域全部初始化为 0，如 BOOL 类型变量初始化为 NO, float类型变量初始化为 0.0,指针初始化为 nil。刚分配的对象不能立即使用，需要先初始化，不然会出现奇怪的行为。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>为什么要<strong>嵌套调用</strong> alloc 和 init 方法？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br></pre></td></tr></table></figure>
<p>而不是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [Car alloc]；</span><br><span class="line">[car init];</span><br></pre></td></tr></table></figure>
<p>因为<strong>初始化方法返回的对象可能与分配的对象不同。</strong>像 NSString 和 NSArray 这样的类事件上是以<strong>类簇</strong>的方式实现的，所以 init 方法可以检查它的参数，并决定返回另一个类的对象更合适。<br>我们经常这样写初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">//自定义初始化行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中调用了<code>[super init]</code>，其作用是让超类完成自身的初始化工作。由于 self 参数是通过固定的距离来寻找实例变量所在的内存位置的，如果从 init 方法返回一个新对象，则需要更新 self,以便其后的实例变量的引用可以被映射到正确的内存位置。而且这个赋值操作只影响该 init 方法中 self 的值，而不影响该方法范围以外的任何内容。如果在初始化一个对象时出现问题，则 init 方法可能会返回 nil。</p>
<h3 id="指定初始化函数"><a href="#指定初始化函数" class="headerlink" title="指定初始化函数"></a>指定初始化函数</h3><p>类中某个初始化函数被指派为初始化函数，该类的所有初始化方法都使用指定初始化函数执行初始化操作，而子类使用其超类的指定初始化函数进行超类的初始化，通常接受参数最多的初始化方法是最终的指定初始化方法。<br>如果创建了一个指定初始化函数，则一定要在你自己的指定初始化函数中调用超类的指定初始化函数。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>@property 预编译指令的作用是自动声明属性的 setter 和 getter 方法。</li>
<li>@synthesize 预编译指令的作用是实现该属性的访问方法。所有属性都是基于变量的，当在 synthesize getter 和 setter 方法时，编译器会自动创建适当类型的实例变量，并且在属性名前加下划线，作为实例变量的名字。如果你没有声明这些变量，编译器也会声明的。注：Xcode 4.5 之后，可以不必使用 synthesize 了。</li>
<li>@dynamic 预编译指令告诉编译器不要自动生成任何代码或创建相应的实例变量。我们可以自己去写实现方法。</li>
</ul>
<p>实例变量的声明可以放在头文件和实现文件中，区别在于若有一个子类，并且要从子类直接通过属性访问变量，那么变量就必须声明在头文件中。<br>在使用属性时，同时可以指定其各种特性，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">CGRect</span> size;</span><br></pre></td></tr></table></figure>
<p>展示了属性的默认的一些特性，其中比较重要的是这些内存管理语义的：</p>
<ul>
<li>assign “设置方法”只会执行针对 scalar type 的简单复制操作，如： CGFloat, NSInter</li>
<li>strong 定义了一种”拥有关系“，设置方法会先保留新值，并释放旧值，然后将新值设置上去。</li>
<li>weak 定义了一种”非拥有关系，设置方法与 assign 类似，但是在属性所指的对象释放时，属性值也会被设置为 nil。</li>
<li>unsafe_unretained 语义与 assign 相同，但它适用于 object type ，表示“非拥有关系”，而且在目标对象释放时，属性值也不会被设置为 nil,所以是 unsafe 的。</li>
<li>copy 所属关系与 strong 类似，然而设置方法并不保留新值，而是拷贝它。通常用于 NSString, NSArray, NSDictionaty 及其子类。当源字符串是 NSString 时, copy 操作只是做了次浅拷贝，当源字符串是 NSMutableString 时， copy 操作是深拷贝，属性值指向拷贝生成的新对象。</li>
</ul>
<p>在对象之外访问实例变量时，总是应该通过属性来做，然而在对象内部既可以使用“点语法”通过存取方法来访问实例变量，也可以直接访问实例变量。这两种方法有以下区别：</p>
<ol>
<li>直接访问实例变量不经过 Objective-C 的方法派发，因此速度比较快。</li>
<li>直接访问实例变量，不会调用其“设置方法”，因此绕过了相关属性所定义的“内存管理语义”。</li>
<li>直接访问实例变量，不会触发“键值观察”。</li>
</ol>
<p>因此在对象内部写入实例变量时，应该通过其“设置方法”来做，而在读取实例变量时，直接访问它。例外情况是在初始化方法及 dealloc 方法中应该总是直接访问实例变量。因为子类可能会 override 设置方法。这时在基类中通过设置方法来访问实例变量时将会调用子类的设置方法。（但是若使用了惰性初始化技术，则必须通过存取方法来访问属性）。</p>
<h2 id="类别（Category）"><a href="#类别（Category）" class="headerlink" title="类别（Category）"></a>类别（Category）</h2><p>利用 Objective-C 的动态运行时分配机制，可以为现有的类添加新方法。可以在类别中添加属性（必须是 @dynamic 类型的），但是不能添加实例变量，<strong>类别没有空间容纳实例变量</strong>，添加属性的好处在于可以通过点语法调用 setter 和 getter 方法。<br><strong>使用类别时要注意避免命名冲突，当发生命名冲突时，类别具有更高的优先级，类别方法将完全取代初始方法。</strong><br>类别主要有三个用途：</p>
<ol>
<li>将类的实现代码分散到多个不同的文件或框架中（使用分类中方法时要引入分类的头文件。有时编写程序库时，将分类的头文件不随程序库一起公开，从而使用者就不知道库里还有这些私有方法）。</li>
<li>创建对私有方法的前向引用（在类别中声明该私有方法，然后将该类别置于实现文件的最前端，编译器就知道该方法已经存在，不会发出警告了。主要用于不方便在类的 @interface 部分列出方法或者使用的是尚未发布的私有方法。）。</li>
<li><strong>向对象添加非正式协议，用于实现委托</strong>（创建一个 NSObject 的类别，然后在你的类中实现想要实现的方法。这也意味着只要对象实现了委托方法，任何类的对象都可以成为委托对象。）</li>
</ol>
<p><strong>类扩展是唯一能声明实例变量的分类</strong>，也可以改变属性的读写权限等，类扩展必须定义在其所接续的那个类的实现文件里，而且它没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。与其他分类不同，它没有名字。<br>为什么能在类扩展中定义方法和实例变量呢？因为有<strong>“稳固的 ABI 机制”</strong>，使得我们无需知道对象大小即可使用它，由于类的使用者无需知道实例变量的内存布局，所以他们就不必须定义在公共接口中了。<br>实例变量也可以定义在“实现块”里，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _anInstansceVariable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从语法上来说，这与直接添加到类扩展中等效。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Objective-C 不支持多重继承，但是我们可以通过协议这种方式描述接口，让类遵循协议，然后实现协议中的方法来扩展类的功能。协议最常见的用途是实现<strong>委托模式</strong>，不过也有其他用法。</p>
<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p><strong>“委托模式”</strong>是一种实现对象间通信的编程设计模式，该模式的主旨是：定义一套接口，某对象若想要接受另一个对象的委托，则需遵从此接口，以便称为其“委托对象”（delegate）。而“另一个对象“则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。<br>有了协议之后，类就可以用一个属性来存放其委托对象了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;XXXDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这个属性一般都定义为 weak， 因为通常情况下扮演 delegate 的那个对象也要持有本对象，因此为了避免 retain cycle，存放委托对象的那个属性就得定义为weak 或者 unsafe_unretained。<br>在调用 delegate 对象的方法时，总是应该把发起委托的实例也一并传入方法中（通过协议方法的声明），这样， delegate 对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。<br>有时候需要优化委托对象是否能响应某个协议方法时（调用<code>if([delegate respondsToSelector:@selector(xxx)])</code>），可以将此信息缓存在某个结构体实例变量中。</p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>有时候对象类型并不重要，重要的是对象有没有实现某些方法，在这种情况下可以用<strong>”匿名对象“</strong>来表达这一概念。如：<code>id&lt;XXXDelegate&gt;</code>,不需要知道此对象所属的类型，只有遵循 XXXDelegate 协议就好了。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>数据持久化就是将内存中的数据模型转换为存储模型,以及将存储模型转换为内存中的数据模型的统称。数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。iOS 开发中常用的数据持久化技术有：plist 文件，NSKeyedArchiver，SQLite3，NSUserDefaults，CoreData 等。</p>
<h3 id="plist-文件"><a href="#plist-文件" class="headerlink" title="plist 文件"></a>plist 文件</h3><p>plist 文件可以存储 NSArray, NSDictionary, NSString, NSNumber, NSData, NSDate类及其可变类的对象。一般有两种方式进行读写操作：</p>
<ul>
<li>NSArray, NSDictionary, NSData及其子类可以直接调用<code>writeToFile:atomically:</code>方法将对象写入 plist 文件。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [path stringByAppendingPathComponent:<span class="string">@&quot;test.plist&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,<span class="string">@&quot;string&quot;</span>];</span><br><span class="line">[array writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//... 读取</span></span><br><span class="line"><span class="built_in">NSArray</span> *otherArray = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,otherArray);</span><br></pre></td></tr></table></figure>
<ul>
<li>NSPropertyListSerialization 类可以为存储和加载 plist 的行为提供很多设定项（比如修改数据的为可变类型的），它可以将 plist 的数据内容以二进制的形式写入文件，因此其提供的其实是 NSArray 和 NSDictionary 与 NSData 之间的转换功能。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic =@&#123;<span class="string">@&quot;one&quot;</span>:<span class="string">@&quot;1&quot;</span>,<span class="string">@&quot;two&quot;</span>:@<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSData</span> *serializedData = [<span class="built_in">NSPropertyListSerialization</span> dataWithPropertyList:dic format:<span class="built_in">NSPropertyListBinaryFormat_v1_0</span> options:<span class="number">0</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (serializedData) &#123;</span><br><span class="line">    [serializedData writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...读取 </span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *otherDic = [<span class="built_in">NSPropertyListSerialization</span> propertyListWithData:serializedData options:<span class="built_in">NSPropertyListMutableContainersAndLeaves</span> format:<span class="literal">NULL</span> error:&amp;error];</span><br></pre></td></tr></table></figure>
<h3 id="NSKeyedArchiver-和-NSKeyedUnarchiver"><a href="#NSKeyedArchiver-和-NSKeyedUnarchiver" class="headerlink" title="NSKeyedArchiver 和 NSKeyedUnarchiver"></a>NSKeyedArchiver 和 NSKeyedUnarchiver</h3><p>遵循 NSCoding 协议并实现了其方法的对象都可以将它的实例变量和其他数据编码为数据块，然后保存在磁盘中，需要的时候再读会内存中创建新对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZAThing</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *subThings;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZAThing</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _name = [aDecoder decodeObjectForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">        _number = [aDecoder decodeIntegerForKey:<span class="string">@&quot;number&quot;</span>];</span><br><span class="line">        _subThings = [aDecoder decodeObjectForKey:<span class="string">@&quot;subThings&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">    [aCoder encodeInteger:<span class="keyword">self</span>.number forKey:<span class="string">@&quot;number&quot;</span>];</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.subThings forKey:<span class="string">@&quot;subThings&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZAThing *thing = [[ZAThing alloc] init];</span><br><span class="line">thing.name = <span class="string">@&quot;111&quot;</span>;</span><br><span class="line">thing.number = <span class="number">222</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *things = @[@<span class="number">1</span>,@<span class="number">2</span>];</span><br><span class="line">thing.subThings = [things mutableCopy];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing];</span><br><span class="line">ZAThing *otherThing = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在对象中还有嵌套的对象时，如上面的 subThings，在归档和反归档时会递归调用嵌套对象的 encode 和 decode 方法。（注：如果 subThings 中包含 thing 对象，这样循环包含的话，Cocoa 的归档和反归档也可以对其进行处理，但是不要用试图 NSLog 来打印， NSLog 不够智能不能处理这种情况）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/SDWebImage%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/SDWebImage%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SDWebImage 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 09:42:15" itemprop="dateCreated datePublished" datetime="2019-03-19T09:42:15+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-13 21:34:33" itemprop="dateModified" datetime="2022-05-13T21:34:33+08:00">2022-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="How-is-SDWebImage-better-than-X"><a href="#How-is-SDWebImage-better-than-X" class="headerlink" title="How is SDWebImage better than X?"></a>How is SDWebImage better than X?</h2><p>开篇，我先翻译一下 SDWebImage 官方介绍中的这篇文章：<a target="_blank" rel="noopener" href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F">How is SDWebImage better than X?</a></p>
<ul>
<li><p>从 iOS5.0 开始 NSURLCache 会处理磁盘缓存，那么使用 SDWebImage 相比于单纯使用 NSURLRequest 强在哪里呢？</p>
<blockquote>
<p>确实从iOS5.0开始，NSURLCache 会在内存及磁盘中缓存 HTTP 响应的原始数据。但是每次缓存命中，应用都需要数据解析（HTTP 原始数据是编码的）、内存拷贝等大量的操作将原生的缓存数据转换进UIImage对象中。<br>另一方面，SDWebImage 在内存中缓存了 UIImage 对象，并在磁盘中存储了图片文件的原始压缩数据（已解码）。UIImage 对象使用 NSCache 按原样存储在内存中，所以在使用时并不需要拷贝，而且可以在应用或系统需要时随时释放内存。<br>除此之外，SDWebImageDecoder 将 UIImageView 首次使用 UIImage 对象的解压缩工作放在了后台线程中而不是通常的主线程中，可以减少主线程堵塞。<br>最后，SDWebImage 完全绕过了复杂且易出错的 HTTP 缓存控制配置，从而极大的加速了缓存查找。</p>
</blockquote>
</li>
<li><p>既然 AFNetworking 为 UIImageView 提供了相似的功能，SDWebImage 还有用嘛？</p>
<blockquote>
<p>大概没啥用，AFNetworking 也是利用了基于 Foundation 框架的 URL 加载系统缓存:NSURLCache，还为 UIImageView 和 UIButton 提供了默认使用 NSCached 的可配置内存缓存。缓存行为可以根据相应的 NSURLRequest 来配置。AFNetworking 还提供了图片数据的后台解压缩等 SDWebImage 的特性。<br>因此如果你已经使用了 AFNetworking，而且只想要简单的异步图片加载分类，内置的 UIKIT 框架也够用了。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/13/%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/13/%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">小记：七牛云测试域名回收问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-13 17:08:30" itemprop="dateCreated datePublished" datetime="2018-07-13T17:08:30+08:00">2018-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 22:34:38" itemprop="dateModified" datetime="2023-09-15T22:34:38+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>月初收到七牛云的邮件扫了一眼大概是关于测试域名回收的问题，由于我只是用到了七牛云存储来做博客图床也就没在意。今天一上博客发现有些图片已经刷不出来了，请求图片的链接返回:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>error<span class="punctuation">:</span> <span class="string">&quot;no such domain&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这不就很蛋疼了嘛，上后台一看，果然是测试域名的问题：<a target="_blank" rel="noopener" href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules">测试域名使用规范</a>，图片上传后生成域名以 clouddn.com 结尾的 URL 在域名回收后自然不能访问了。</p>
<p>官方给出的解决途径是绑定自定义域名，然而这个域名是需要在公安网备案的，对我来说为使用图床还得搞个备案的域名未免太麻烦，索性先不用七牛云的图床了。当我尝试点击下载文件时：</p>
<p><img src="/images/yun.png" alt="yun"></p>
<p>网页的顶端给了我一个错误提示：</p>
<p><img src="/images/bucket_error.png" alt="bucket_error"></p>
<p>这就很尴尬了，域名被回收了直接下载都下载不了，怎么破呢？只好祭出 google 大法。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>搜索后发现原来七牛云提供了<a target="_blank" rel="noopener" href="https://developer.qiniu.com/kodo/tools/1300/qrsctl">命令行辅助工具qrsctl</a>来对存储资源进行操作，下载下来通过命令<code>chmod +x qrsctl</code>为文件添加可执行权限。然后使用如下命令进行操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录</span></span><br><span class="line">./qrsctl login &lt;User&gt; &lt;Passwd&gt;</span><br><span class="line"><span class="comment">#登录成功后查看所有存放资源的空间（buckets）</span></span><br><span class="line">./qrsctl buckets</span><br><span class="line"><span class="comment">#列出bucket中以prefix开头的所有资源</span></span><br><span class="line">./qrsctl listprefix &lt;bucket&gt; &lt;prefix&gt;                </span><br></pre></td></tr></table></figure>
<p>因为我们要获取所有的图片资源，所以prefix参数使用了<code>&#39;&#39;</code>空字符串，所得结果如下图所示：</p>
<p><img src="/images/terminal_buckets.png" alt="terminal_buckets"></p>
<p>在获取到所有资源名称后，就可以调用<code>qrsctl</code>下载资源的接口了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key为资源文件的名称 destFile为下载的目标路径</span></span><br><span class="line">./qrsctl get &lt;Bucket&gt; &lt;Key&gt; &lt;DestFile&gt;</span><br></pre></td></tr></table></figure>
<p>使用下面的脚本来完成下载任务更加方便：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#``反引号是命令替换，可以先执行其中的命令并暂时保存在变量 imgs 中,``的替换操作也可使用$()操作</span></span><br><span class="line">imgs=`./qrsctl listprefix 176zane <span class="string">&#x27;&#x27;</span>`</span><br><span class="line">i=0 </span><br><span class="line"><span class="comment">#打印$imgs执行结果 然后使用管道符合 | 将结果传给 tr 命令将空格转化为换行符,再将结果逐行读取到 line 变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$imgs</span> | <span class="built_in">tr</span> <span class="string">&quot; &quot;</span> <span class="string">&quot;\n&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#(())用于算数运算比较，此处的判断用于将上面结果中第一行的 ‘marker:‘这个非资源名的信息打印过滤掉</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$i</span>&gt;<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line">        ./qrsctl get 176zane <span class="variable">$line</span> ./<span class="variable">$line</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>虽然对<code>shell</code>脚本不是太熟悉，但是上面的逻辑还是挺简单的，尝试一下很简单就把图片资源下载下来了，但是检查了一下就发现并没有下载完所有的资源，其实这里面还有一个坑：<code>tr &quot; &quot; &quot;\n&quot;</code>命令将之前处理结果分成一行一行的字符串时也将文件名中带有空格的如上图中用绿框框起来的文件名给破坏了，在后台中删除了该文件命名中的空格后重新运行脚本就搞定了。当然这是简单的做法，当你有很多资源名中含有空格时，可以在获取资源名后，在后续的命令中对文件名加上引号来下载：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qrsctl get 176zane <span class="string">&#x27;2018-07-12 10_40_14.gif&#x27;</span> ./<span class="string">&#x27;2018-07-12 10_40_14.gif&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就拿回了所有保存在七牛云上的图片资源，鉴于暂时没找到合适的图床，索性就直接用 github 来保存吧，虽然加载速度会慢点，但还是比较可靠的。全局替换图床链接<code>http://oztca4xvs.bkt.clouddn.com/</code>为本地地址<code>/images/</code>后，将图片复制到<code>source/images/</code>目录下，重新部署即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/21/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/" class="post-title-link" itemprop="url">黑客与画家</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-21 17:30:29" itemprop="dateCreated datePublished" datetime="2017-10-21T17:30:29+08:00">2017-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-03-27 14:07:14" itemprop="dateModified" datetime="2018-03-27T14:07:14+08:00">2018-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B4%A7%E9%93%BA%E5%AD%90/" itemprop="url" rel="index"><span itemprop="name">杂货铺子</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>黑客与画家的共同之处，在于他们都是创作者。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
