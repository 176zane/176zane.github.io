<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:type" content="website">
<meta property="og:title" content="Deep Thought">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="姚七六">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/15/Block%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/Block%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Block 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-15 10:36:38" itemprop="dateCreated datePublished" datetime="2020-09-15T10:36:38+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-04 20:49:18" itemprop="dateModified" datetime="2023-04-04T20:49:18+08:00">2023-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h1><p>Blocks 是 C 语言的扩展功能，是带有<strong>自动变量（局部变量）</strong>的<strong>匿名函数</strong>。这一概念在其他程序语言中也称为闭包（Closure）、Lambda等。<br>C 语言标准不允许不带有名称的函数，想要不通过函数名来调用函数可以如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> (*funcptr)(<span class="type">int</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> result = (*funcptr)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>但是其实在赋值函数指针时，还是用到了函数的名称。</p>
<p>C语言的函数中使用的变量有一下几种：</p>
<ul>
<li>函数的参数 - 存储在栈中</li>
<li>自动变量（局部变量）- 存储在栈中</li>
<li>静态变量（静态局部变量）- 作用域与局部变量相同，但是改变了存储方式，从而改变了生存周期</li>
<li>全局变量</li>
<li>静态全局变量 - 与全局变量一样是静态存储方式，但是将其作用域限制在了定义该变量的源文件内</li>
</ul>
<p><img src="/images/%E5%A0%86%E6%A0%88.png" alt="进程在虚拟内存中的结构"></p>
<p>能够在函数的多次调用中传递值的变量有：静态局部变量、静态全局变量和全局变量，这几种变量虽然作用域不同，但是在整个程序中，一个变量总是保持在一个内存区域中，函数对其多次访问也是访问同一个值。</p>
<p><strong>Blocks</strong> 提供了类似 C++ 和 Objective-C 类生成实例或对象来保持变量值的方法，它保持局部变量的值。同时避免了声明类的大量代码，也没有使用静态变量、静态全局变量或全局变量时，访问的总是同一个值的问题。</p>
<h2 id="Blocks的语法"><a href="#Blocks的语法" class="headerlink" title="Blocks的语法"></a>Blocks的语法</h2><p>我们看一个简单的Block的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="type">int</span> (<span class="type">int</span> count)&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其实它与一般的C语言函数只有两点不同：1、返回值类型前面带有”^”符合，2、返回值类型后面没有函数名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testFunc</span> <span class="params">(<span class="type">int</span> count)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>我们在通常使用中会省略Block的返回值类型，所以上面的表达式通常写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="type">int</span> count)&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>在省略返会在类型时，如果表达式中没有<code>return</code>语句，就使用<code>void</code>类型，有<code>return</code>语句就使用该返回值的类型，若有多个<code>return</code>语句，那么所有的语句返回值类型应该相同。<br>如果不使用参数的话，参数列表也可以省略。</p>
<h3 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h3><p>在 Block 语法下，可将 Block 语法赋值给声明为 Block 类型的变量中。即源代码中一旦使用 Block 语法就相当于生成了可赋值给 Block 类型变量的“值”。Block 类型变量完全可以与一般的 C 语言变量一样使用。<br>我们将上文中的 Block 赋值给 Block 类型的变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (^blk)(<span class="type">int</span>) = ^(<span class="type">int</span> count)&#123;<span class="keyword">return</span> count + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>但是在函数参数或返回值中使用 Block 类型变量时，记述起来很复杂，因此常用 typedef 来解决：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> (^blk_t)(<span class="type">int</span>);</span><br><span class="line">blk_t blk = ^(<span class="type">int</span> count)&#123;<span class="keyword">return</span> count + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Blocks的实现"><a href="#Blocks的实现" class="headerlink" title="Blocks的实现"></a>Blocks的实现</h2><h3 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h3><p><strong>Block的本质就是 C 语言结构体的实例，Block 就是 Objective-C 对象。</strong><br>Block 的语法看上去很特别，但实际上是作为普通的 C 语言源代码来处理的。我们可以用 clang 编译器的“clang -rewrite-objc 源代码文件名”指令将源代码转化为我们可读的源代码。</p>
<p>下面我们看如下这段代码转化为 C++ 源代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">&quot;Block\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;<span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Block结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;<span class="comment">//用于描述这个Block的附加信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Block构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;<span class="comment">//isa指针指向这个Block所属的类 _NSConcreteStackBlock</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Block使用的匿名函数其实被转化为简单的C的函数代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Block\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;<span class="comment">//为今后版本升级保留的区域</span></span><br><span class="line">  <span class="type">size_t</span> Block_size;<span class="comment">//Block的大小</span></span><br><span class="line"></span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block截获自动变量值"><a href="#Block截获自动变量值" class="headerlink" title="Block截获自动变量值"></a>Block截获自动变量值</h3><p>Block 是带有<strong>自动变量（局部变量）</strong>的<strong>匿名函数</strong>,”带有自动变量值”在 Block 中表现为截获 Block 中使用到的自动变量值。<br>我们看一个实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *fmt = <span class="string">&quot;var = %d\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(fmt,val);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed. var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    blk();<span class="comment">//打印出var = 10，因为Block保存了该自动变量的瞬间值，在执行Block后即使改变该自动变量值也不会影响Block执行时的自动变量值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt;  <span class="comment">//Block中访问的自动变量被作为成员变量追加到了Block结构体实例中</span></span><br><span class="line">  <span class="type">int</span> val;          <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">const</span> <span class="type">char</span> *_fmt, <span class="type">int</span> _val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">fmt</span>(_fmt), <span class="built_in">val</span>(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// Block实际执行的函数中访问的自动变量来自Block结构体实例</span></span><br><span class="line">  <span class="type">int</span> val = __cself-&gt;val; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(fmt,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dmy = <span class="number">256</span>;<span class="comment">//没有在Block中访问，所以没有被截获</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fmt = <span class="string">&quot;var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line"></span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed. var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h3><p>实际上，自动变量值截获只能保存执行 Block 语法瞬间的值，保存后就不能在 Block 中改写该值。试图在 Block 中修改自动变量会导致编译错误。<br>如果我们要改变 Block 中截获的自动变量值，有以下两个方法：</p>
<ul>
<li>使用 static 修饰自动变量值将其变为静态变量，修改其存储域。</li>
<li>使用 __block 修饰符</li>
</ul>
<p>我们看一下下面的源代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> static_global_val = <span class="number">2</span>;<span class="comment">//全局静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> static_val = <span class="number">3</span>;<span class="comment">//静态变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        global_val *=<span class="number">1</span>;</span><br><span class="line">        static_global_val *=<span class="number">2</span>;</span><br><span class="line">        static_val *=<span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量与全局静态变量并没有被捕获到Block中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> *static_val;<span class="comment">//截获了静态变量的指针</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> *_static_val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">static_val</span>(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// 从结构体中获取该指针</span></span><br><span class="line"></span><br><span class="line">  global_val *=<span class="number">1</span>;<span class="comment">//对于全局变量和静态全局变量的访问与转换前完全相同</span></span><br><span class="line">  static_global_val *=<span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  (*static_val) *=<span class="number">3</span>;<span class="comment">//使用静态变量的指针对其进行访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对于静态变量，Block 会捕获其指针对其进行访问。这种方法似乎对于自动变量也可以，为什么不截获自动变量的指针呢？因为自动变量再其作用域结束时已经被废弃了，Block调用时再去通过指针访问会出错。</p>
<p>我们在来看看使用“__block存储域类说明符”的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()&#123;</span><br><span class="line">    __block <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;<span class="comment">//被捕获的__block变量生成的结构体并不在Block用__main_block_impl_0结构体中，这样做是为了能再多个Block中使用同一个__block变量</span></span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="type">int</span> val;<span class="comment">//最初的自动变量变为了结构体中的实例变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// 结构体指针。__block将自动变量变成了栈上生成的结构体实例</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">val</span>(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// 获取结构体指针</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;<span class="comment">//通过__forwarding指针访问变量值</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;val, (<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="type">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="built_in">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">0x22000000</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__block 说明符将自动变量变成了栈上生成的结构体实例 __Block_byref_val_0，且这个结构体的指针被 Block 结构体所捕获。被捕获的 __block变量生成的结构体并不在Block用__main_block_impl_0结构体中，这样做是为了能在多个Block中使用同一个 __block变量。<br>__Block_byref_val_0 结构体实例的成员变量 __forwarding 持有该结构体实例自身的指针，通过这个 __forwarding 指针访问成员变量 val。 如下图所示</p>
<p><img src="/images/%E8%AE%BF%E9%97%AE__block%E5%8F%98%E9%87%8F.jpg" alt="访问__block变量"></p>
<p>为什么要使用指向结构体自身的 __forwarding 指针来访问其val值呢？为什么 Block 作为返回值时可以超出其变量作用域而存在呢？<br>其实，Block 所属类有以下几种：</p>
<ul>
<li>__NSConcreteStackBlock –该类的对象分配在栈上</li>
<li>__NSConcreteGlobalBlock –该类的对象分配在.data区</li>
<li>__NSConcreteMallocBlock –该类的对象分配在堆中</li>
</ul>
<p>在记述全局变量的地方使用Block变量时，实际的Block对象类为 __NSConcreteGlobalBlock。还有一种情况当 Block 语法的表达式中不使用应截获的自动变量时，Block也是 __NSConcreteGlobalBlock 类对象。</p>
<p>Blocks提供了将 Block 和 __block 变量从栈上复制到堆上的方法来使 Block 可以超出其作用域而存在，这时候在堆上分配的 Block 就是 __NSConcreteMallocBlock 类对象。栈上的 Block 会在以下几种情况时复制到堆：</p>
<ul>
<li>调用Block的 copy 方法时（除以下3种情况时均推荐自己调用copy方法，防止Block被废弃）</li>
<li>Block作为函数返回值返回时</li>
<li>将Block赋值给附有 __strong修饰符 id 类型的类或Block类型成员变量时</li>
<li>在方法名中含有 usingBlock的Cocoa框架方法或者GCD的API中传递Block时</li>
</ul>
<p><img src="/images/%E5%A4%8D%E5%88%B6__block%E5%8F%98%E9%87%8F.png" alt="复制__block变量"></p>
<p>将 Block 复制到堆之后，栈上的Block 的 __forwarding 指针指向了堆上的Block,从而保证了任何时候都可以正确的访问到val值。</p>
<h3 id="Block截获对象"><a href="#Block截获对象" class="headerlink" title="Block截获对象"></a>Block截获对象</h3><p>如果Block捕获的自动变量是 Objective-C 对象,会是什么情况呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    blk = [^(<span class="type">id</span> object)&#123;</span><br><span class="line">        [array addObject:object];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;array count = %ld&quot;</span>,[array count]);</span><br><span class="line">        <span class="comment">//array = [NSMutableArray array];//不能给array重新赋值，因为捕获的是指向该对象的指针，而不是对象本身</span></span><br><span class="line">    &#125; <span class="keyword">copy</span>];<span class="comment">//调用copy方法将block复制到堆上，才会对截获的array调用retain方法，否则array会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 1</span></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 2</span></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到在作用域结束后，array并没有没废弃，这个对象被Block截获，并且在Block复制到堆时对其进行了retain操作，从而持有了这个对象。<br>我们看看上面代码的 C++版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  id __strong array;<span class="comment">//截获的对象</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, id _array, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">    id __strong array = __cself-&gt;array;</span><br><span class="line">    [array addObject:obj]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;array count = %ld&quot;</span>,[array count]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//当block复制到堆时调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;array, (<span class="type">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<span class="comment">//相当于调用retain方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当堆上的block被废弃的时候调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="type">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<span class="comment">//相当于调用release方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">blk_t</span> blk;</span><br><span class="line">&#123;</span><br><span class="line">    id __strong array = [[NSMutalbleArray alloc] init];</span><br><span class="line">    blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">0x22000000</span>));</span><br><span class="line">    blk = [blk copy];</span><br><span class="line">&#125;</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br></pre></td></tr></table></figure>
<p>在OC中，C语言结构体不能含有__strong修饰符的变量，因为编译器不知道合适进行C语言结构体的初始化喝废弃操作，不能很好的管理内存，但是运行时库能准确把我 Block 从栈复制到堆以及堆上的Block被废弃的时机，因此Block结构体中可以含有附有 __strong或__weak修饰的变量。</p>
<h3 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h3><p>当我们想要在block中修改被捕获的对象时，可以用__block修饰，其代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="type">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]；<span class="comment">//obj默认是__strong</span></span><br></pre></td></tr></table></figure>

<p>该代码经过clang转换后的__block变量结构体部分如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_obj_0</span> &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_obj_0 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="built_in">void</span> (*__Block_byref_id_object_copy)(<span class="type">void</span>*, <span class="type">void</span>*);<span class="comment">//如果__block对象变量从栈复制到堆时，使用_Block_object_assign函数</span></span><br><span class="line"> <span class="built_in">void</span> (*__Block_byref_id_object_dispose)(<span class="type">void</span>*);<span class="comment">//堆上的__block对象变量被废弃时，使用_Block_object_dispose函数</span></span><br><span class="line"> __strong id obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Block中使用__strong修饰符的对象类型自动变量的情况下，当Block从栈复制到堆时，使用__Block_object_assign函数，持有Block截获的对象。<br>需要特别注意的是如果对象是__weak修饰的，则不论是否有__block修饰，Block复制到堆时，均不持有该对象。</p>
<h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><p>在Block内部使用__strong修饰符的对象类型的自动变量时，当Block从栈复制到堆的时候，该对象就会被Block所持有。如果这个对象还同时持有Block的话，就容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>(^blk_t)(<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Person 类对象持有Block类型成员变量blk，init实例方法中Block语法使用了附有__strong修饰符的对象self，并且由于Block语法赋值在了成员变量blk中，因此该栈上生成的Block会复制到堆，从而持有self，导致了循环引用。<br>可以使用__weak修饰符打破循环：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> temp = <span class="keyword">self</span>;</span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,temp);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候也可以使用__block修饰符来打破循环：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    __block <span class="type">id</span> temp = <span class="keyword">self</span>;</span><br><span class="line">    blk_= ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,temp);</span><br><span class="line">        temp = <span class="literal">nil</span>;<span class="comment">//需要再blk中将temp置空。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)execBlock &#123;</span><br><span class="line">    blk();<span class="comment">//保证blk被执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用__block来打破循环的话，需要再block中将对象置为nil，并且保证block执行来打破循环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/AV%20Foundation%E7%AC%94%E8%AE%B0-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/AV%20Foundation%E7%AC%94%E8%AE%B0-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">AV Foundation笔记-音视频基础入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 09:12:13" itemprop="dateCreated datePublished" datetime="2020-06-05T09:12:13+08:00">2020-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:41:48" itemprop="dateModified" datetime="2022-05-12T21:41:48+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们所看见的和听见的都是通过眼睛和耳朵的构造将这些信息转化为大脑能够解析的电信号，通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%93%AC%E4%BF%A1%E8%99%9F">模拟信号</a>传递给我们的。模拟信号利用对象的一些物理属性来表达、传递信息，例如声音、光、温度、位移、压强，这些物理量可以使用传感器测量。模拟信号中，不同的时间点位置的信号值是连续变化的。而数字世界中的信号是离散的，由 1 和 0 两个状态表示，要将模拟信号转换成能够在计算机中存储并传输的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a>，需要经过模拟-数字转换过程，这个过程称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%96%E6%A8%A3">采样</a>。</p>
<h1 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h1><p>通常采样与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%8C%96_(%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86)">量化</a>联合进行，例如对于音频信号来说，模拟信号先由采样器按照一定时间间隔采样获得时间上离散的信号，再经模数转换器在数值上也进行离散化，从而得到数值和时间上都离散的数字信号。大多情况下所说的“采样”就是指这种采样与量化结合的过程。</p>
<h2 id="音频采样"><a href="#音频采样" class="headerlink" title="音频采样"></a>音频采样</h2><p>我们一般使用麦克风来记录声音，它可以将机械能量转换成电能量。当我们发出声音时，会带动周围的空气产生特定频率和振幅的震动，这样麦克风中那层薄薄的膜片也会根据其感受到的声波进行震动，带动线圈震动，由此产生与输入信号相同频率和振幅的电流信号，这个信号中的频率与振幅分别代表了声音的音调与音量（对于复杂波形来说，音调对应的是波的基频）。<br><img src="/images/%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7.png" alt="声音信号"></p>
<p>麦克风所产生的电压信号类似于上图中的波形，这种模拟信号可以在磁带上记录成磁场强度的变化或在黑胶唱片上记录成沟槽大小的变化。但是当存储介质为计算机时，一般会通过线性脉冲编码调试（即Linear PCM）的过程将其数字化。这个过程会间隔固定的时间对信号进行测量，然后用独特的数字记号（通常为二进制）来量化。其中涉及两个重要的参数：</p>
<ul>
<li><p>采样率：采样率表示音频信号每秒的取样数，它决定了音频文件的频率范围。从下图可以看出采样率越高，数字波形的形状越接近原始模拟波形。根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86">采样定理</a>当采样率达到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9%E9%A2%91%E7%8E%87">奈奎斯特频率</a>，即频率达到所需要采样对象的最高频率的两倍时可以产生足够好的数字化效果。人类的听觉可以接收的音频范围为 20HZ~20kHZ，所以使用CD录制的音频采样率通常为 44.1kHZ，其所能捕捉的最大频率为20.05kHZ，对于人耳来说已经足够好了。<br><img src="/images/%E9%87%87%E6%A0%B7%E7%8E%87.png" alt="采样率"></p>
</li>
<li><p>位元深度：位元深度是用于保存样本值的字节数，它定义了在线性维度上可行的离散度，决定了我们所能捕捉的音频样本的精度。为每个样本的整理量化分配过少的位结果信息会导致数字音频信号产生噪声和扭曲。使用位元深度为 8 的方法可以提供 256 个离散级别的数据，对于一般音频也可使用。CD音质的位元深度为 16，更专业级别的音频录制环境的位元深度可能达到24或更高。</p>
</li>
</ul>
<h2 id="图像采样"><a href="#图像采样" class="headerlink" title="图像采样"></a>图像采样</h2><p>对于图像，我们一般使用扫描或者拍照技术对其信息进行采集。在数字化过程中，与音频基于时间的采样不同，图像是基于空间采样的（对于视频这种既有空间属性也有时间属性的信号，这两种方式都会使用）。空间采样包含对一副图片在一定分辨率下捕捉其亮度和色度，进而创建由该图片的像素点数据所构成的数字化结果。</p>
<p>在采样时，将二维空间中连续的图片在水平和垂直方向上等距的分割为矩形网状结构，形成一个个微小的方格称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0">像素</a>。像素没有固定的尺寸大小，它只是对一个最小完整采样的抽象。这样一副图片就被采样成有限个像素点构成的集合。然后通过量化将各像素的灰度值从模拟量转化为离散量。其中有如下主要参数：</p>
<ul>
<li><p>采样点数：对一幅图像采样时，若每行像素为M个，每列像素为N个，则图像尺寸为M *  N个像素。像素数量对图片质量有显著影响。一般来说图像采样点数越多，图像质量越好，但数据量越大。例如下图为采样点数从 256  * 256 逐步减少到到 8 * 8 对图像质量的影响。<br><img src="/images/%E5%83%8F%E7%B4%A0%E7%82%B9%E6%95%B0.png" alt="像素点数"></p>
</li>
<li><p>量化级数：对于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F">灰度图像</a>我们需要将各像素的灰度值量化，一般使用 8 位 256 个量化级数来表示 0~255 的灰度值。量化级数越多，图像质量越好。下图表示采样点数一定时，量化级数从 256 递减至 2 时对图像质量的影响。<br><img src="/images/%E7%81%B0%E5%BA%A6.png" alt="灰度"></p>
</li>
</ul>
<p>对于彩色图像，基于RGB<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93">色彩模型</a>按照颜色成分——红（R）、绿（G）、蓝（B）分别采样和量化的。若各种颜色成分均按 8 位量化，即每种颜色量级别是 256，可以处理256×256×256&#x3D;16777216 种颜色。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://objccn.io/issue-21-1/">相机工作原理</a>。</p>
</blockquote>
<h1 id="编码压缩"><a href="#编码压缩" class="headerlink" title="编码压缩"></a>编码压缩</h1><p>对于音视频数字信号，如果不加压缩的存储和传输虽然能够保留原始的呈现效果，但是会占用大量的存储空间与带宽。例如对于一个双声道，44.1kHz，16位LPCM音频文件的码率为：2 * 44.1kHz * 16bit&#x3D;1.346Mbit&#x2F;s，也就是每分钟要占用 10MB的空间。对于一个帧率为 30FPS，1280 * 720分辨率的每个像素采用 24 位的RGB色彩空间的视频文件其码率为：30 * 1280 * 720 * 24bit &#x3D; 634Mbit&#x2F;s,也就是每分钟要占用 4.6GB的空间。这样的码率显然在当前（虽然现在都8102年了）的设备存储及网络传输中显得难以接受，因此我们需要对这些音视频文件进行编码压缩。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/28114081">频压缩编码和音频压缩编码的基本原理</a>。 注：本文中音视频编码原理部分内容摘录自该博客。</p>
</blockquote>
<h2 id="音频编解码"><a href="#音频编解码" class="headerlink" title="音频编解码"></a>音频编解码</h2><p>音频编码主要是将音频采样数据（如PCM数据）中声音信号的冗余成分去除压缩为音频码流，从而降低音频的数据量的过程。</p>
<h3 id="音频编码基本原理"><a href="#音频编码基本原理" class="headerlink" title="音频编码基本原理"></a>音频编码基本原理</h3><p>所谓冗余成分是指音频中不能被人耳感知到的信号，它们对确定声音的音调等信息没有任何的帮助。冗余信号包含人耳听觉范围外的音频信号（即频率在20Hz~20KHz之外的部分）以及被掩蔽掉的音频信号。根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应。主要表现在频谱掩蔽效应和时域掩蔽效应：</p>
<h4 id="频谱掩蔽效应"><a href="#频谱掩蔽效应" class="headerlink" title="频谱掩蔽效应"></a>频谱掩蔽效应</h4><p>一个频率的声音能量小于某个阈值之后，人耳就会听不到，这个阈值称为最小可闻阈。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如图所示</p>
<p><img src="/images/%E9%A2%91%E5%9F%9F%E6%8E%A9%E8%94%BD%E6%95%88%E5%BA%94.jpeg" alt="频域掩蔽效应"><br>我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝。当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。</p>
<h4 id="时域掩蔽效应"><a href="#时域掩蔽效应" class="headerlink" title="时域掩蔽效应"></a>时域掩蔽效应</h4><p>当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。</p>
<p><img src="/images/%E6%97%B6%E5%9F%9F%E6%8E%A9%E8%94%BD%E6%95%88%E5%BA%94.jpeg" alt="时域掩蔽效应"></p>
<p>前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。</p>
<h3 id="主要音频编解码方案"><a href="#主要音频编解码方案" class="headerlink" title="主要音频编解码方案"></a>主要音频编解码方案</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/WAV">WAV</a>:WAV 编码的一种实现是在 PCM 数据格式的前面加上 44 字节，分别用来描述 PCM 的采样率，声道数及数据格式等信息，WAV 文件与无损文件是不同的，它只不过是不去对原始文件做压缩。音质很好，大量软件及平台都支持。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows_Media_Audio">WMA</a>:微软推出的数字音频编码方案，一般情况下会比同样音质的MP3文件体积小。与MP3一样，需要购买版权支持。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MP3">MP3</a>:当前较为流行的一种有损压缩的数字音频编码方案之一。iOS的AVFoundation框架只提供对MP3数据的解码，并不支持对其编码。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC">AAC</a>:与H.264标准对应的音频编码方案，相比MP3格式有显著的提升，且没有专利问题，也是一种有损压缩方案。AAC是iPhone等多种设备的默认音频编码格式。它的扩展名主要有：.aac，.mp4，m4a。</li>
</ul>
<p>当然还有许多其他音频编解码方案，但是对于iOS开发学习过程来说，主要针对AAC编码方案即可。</p>
<h2 id="视频编解码"><a href="#视频编解码" class="headerlink" title="视频编解码"></a>视频编解码</h2><p>视频编码主要是将视频像素数据（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/YUV">YUV</a>数据）压缩为视频码流，降低视频数据量的过程。等等，YUV是什么鬼？我们像素数据采集的时候不是RGB数据么？其实在我们平时拍照或者拍视频的时候会经历一个色彩二次抽样的过程，将数据转换为YVU颜色模式的数据。在下面的相机拍照的工作流程图中也可以看到这个步骤：</p>
<p><img src="/images/IMG_8077.jpg" alt="IMG_8077"></p>
<h3 id="色彩二次抽样"><a href="#色彩二次抽样" class="headerlink" title="色彩二次抽样"></a>色彩二次抽样</h3><p>由于人类的视觉系统对颜色的位置及移动不及对亮度敏感，所以可以使用较多的亮度细节、较少的色度细节作优化，而不至于图片的质量受损严重。分别用一个亮度分量（Y’）及两个不同颜色分量（色度UV，分别用Cb和Cr来表示蓝色和红色的浓度偏移量）来替换原来的RGB数据从而减少颜色数据的过程就叫色彩二次抽样。</p>
<p><img src="/images/Barn-yuv.png" alt="Barn-yuv"></p>
<p>这张维基百科上的彩色图片可以让你对一张图片的 Y’及U、V组成部分有一个直观的认识。为节省带宽，大多数YUV格式平均使用的每像素位数都少于24位。其成分按照 J:a:b 的格式来取值：</p>
<ul>
<li>J：水平抽样参照（概念上区域的宽度）。通常为4。</li>
<li>a：在J个像素第一行中的色度抽样数目（Cr, Cb）。</li>
<li>b：在J个像素第二行中的额外色度抽样数目（Cr, Cb）</li>
</ul>
<p>其中主要的格式有4:2:0，4:2:2，4:4:4。在所有的格式下，每个像素的全部亮度信息都被保存下来了，在4:4:4时全部的色彩信息也被保存下来了，表示完全取样，数据量相比于RGB模型没有变化。4:2:2表示2:1的水平取样，垂直完全采样，数据量相比于RGB模式减少三分之一，4:2:0表示2:1的水平取样，垂直2：1采样。数据量相比于RGB模式减少二分之一。注意当前iPhone上的摄像头就是采用4:2:0的方式进行拍摄的。下图可以帮助理解这个二次抽样比例的模式：</p>
<p><img src="/images/Jab.png" alt="Jab"></p>
<h3 id="视频编码基本原理"><a href="#视频编码基本原理" class="headerlink" title="视频编码基本原理"></a>视频编码基本原理</h3><p>数据压缩是通过去除数据中的冗余信息而达成。就视频数据而言，数据中的冗余信息有如下几种：</p>
<ul>
<li>数据冗余:例如如空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性。消除这些冗余并不会导致信息损失，属于无损压缩。</li>
<li>视觉冗余:人眼的一些特性比如亮度辨别阈值，视觉阈值，对亮度和色度的敏感度不同，使得在编码的时候引入适量的误差，也不会被察觉出来。可以利用人眼的视觉特性，以一定的客观失真换取数据压缩。这种压缩属于有损压缩。</li>
</ul>
<p>一般的数字视频压缩编码方法都是混合编码，即将变换编码，运动估计和运动补偿，以及熵编码三种方式相结合来进行压缩编码。通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。</p>
<h4 id="变换编码"><a href="#变换编码" class="headerlink" title="变换编码"></a>变换编码</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%81">变换编码</a>的作用是将空间域描述的图像信号变换到频率域，然后对变换后的系数进行编码处理。一般来说，图像在空间上具有较强的相关性，变换到频率域可以实现去相关和能量集中。常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换，简称DCT变换。</p>
<p>变换编码一般用于帧内压缩，去除空间冗余信息和部分视觉冗余信息，所以一般是有损压缩算法，通常也用于JEPG静态图像压缩算法，但是通常是对原始图片的部分处理以生成极高质量的照片，通过这一步骤创建的帧称为 I-frames。</p>
<h4 id="运动估计和运动补偿"><a href="#运动估计和运动补偿" class="headerlink" title="运动估计和运动补偿"></a>运动估计和运动补偿</h4><p>这一步骤主要通过以组为单位的视频帧消除时间序列上的相关性来压缩冗余数据，是帧间压缩。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量。</p>
<p>运动估计一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280 * 720，首先将其以网格状的形式分成40 * 45个尺寸为16 * 16的彼此没有重叠的图像块，然后在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个运动矢量。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个残差图像块，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫运动补偿。</p>
<p><img src="/images/GOP.png" alt="GOP"></p>
<p>由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要，很多帧组合在一起作为一组图片（简称GOP），如下图所示。其中有三种不同类型的帧：</p>
<ul>
<li>I-frames:又称关键帧，只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。包含创建完整图片需要的所有数据，因此其尺寸是最大的，压缩比并不高，解压时间短。每个GOP正好有一个I-frames。</li>
<li>P-frames:又称预测帧，编码时使用一个前面的I-frames或P-frames作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。</li>
<li>B-frames:又称双向帧，编码过程中它要使用一个前面的I-frames或P-frames和一个后面的I-frames或P-frames进行预测。几乎不需要存储空间，但解压时间最长。</li>
</ul>
<h4 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%86%B5%E7%B7%A8%E7%A2%BC%E6%B3%95">熵编码</a>是一种独立于介质的具体特征的进行无损数据压缩的方案。其基本原理是对信源中出现概率大的符号赋予短码，对于出现概率小的符号赋予长码，从而在统计上获得较短的平均码长。可变字长编码通常有霍夫曼编码、算术编码、游程编码等。通过这种变长编码算法来进一步提高编码效率。</p>
<h3 id="主要视频编码方案"><a href="#主要视频编码方案" class="headerlink" title="主要视频编码方案"></a>主要视频编码方案</h3><p>视频编码有各种各样的方案标准，其实整体看起来还是比较混乱的，这里我们只举例几种稍作了解：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MPEG-2">MPEG-2</a>:是MPEG工作组于1994年发布的视频和音频压缩国际标准，通常用来为广播信号提供视频和音频编码，包括卫星电视、有线电视等。是采用以香农信息论为基础的预测编码、变换编码、熵编码及运动补偿等第一代数据压缩编码技术。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MPEG-4">MPEG-4</a>:一般特指MPEG-4第2部分，是基于第二代压缩编码技术制定的国际标准，它以视听媒体对象为基本单元，实现了从基于像素的传统编码向基于对象和内容的现代编码的转变，提高了压缩率。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a>又称为MPEG-4第10部分，是目前最主流的方案，充分利用了现有MPEG-4标准中的各个环节，即保留了以往压缩技术的优点和精华又具有其他压缩技术无法比拟的许多优点。是一种面向块，基于运动补偿的视频编码标准。可以提供更高的编码效率，更高清的视频画面质量，更好的网络适应能力。</li>
</ul>
<h1 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h1><p>我们平时在电脑中存储的或者网上下载的各种.mov、.avi、.mp4等等后缀名的文件，平时我们将这些类型视为文件格式，其实更准确的理解是这些类型是文件的封装格式。封装格式也是元文件格式，封装格式就是按照一定的规范结构将视频数据，音频数据等放在一起。所谓的结构不仅包含了媒体信息，如视频、音频、字幕、编码和时间信息等，还包含了描述性的元数据，比如电影标题、歌曲作者等。这些元数据可以通过工具进行呈现。</p>
<p>下面我们了解一下一些常用的封装格式：</p>
<ul>
<li>QuickTime:苹果公司开发的封装格式，它可存储的内容相当丰富，除了视频、音频以外还可支持图片、文字（文本字幕）等。文件后缀名为.mov、.qt。</li>
<li>AVI:微软公司开发的对抗苹果QuickTime格式的技术，AVI本身只提供了一个框架，内部的图像数据及声音数据可以支持任意的编码形式。AVI与其他格式最大的不同是它将索引放在文件尾部，所以不能支持流媒体播放。文件后缀名为.avi。</li>
<li>MP4:是MPEG-4第 14 部分规范定义的容器格式，是从QuickTime直接派生出来的行业标准格式，视频主要采用H.264编码格式，音频主要采用AAC编码格式，同时也支持老版本的MPEG编码标准。文件后缀名为.mp4,在苹果生态系统中，也常用.m4a的音频文件及.m4v的视频文件等格式区分基于MP4格式的特定媒体类型。</li>
<li>TS:TS封装支持几乎所有编码的高清视频和音轨文件。视频编码有MPEG2、MPEG4 AVC、VC1，音频则种类DD、TrueHD、DTS、DTSHD等。TS的全名是Transport Stream，在打包视频和音频时，能提供时间戳，在整个打包视频的任何时段开始播放，都能顺利解码并保持音画同步。文件后缀为.ts。</li>
<li>FLV：FLV流媒体格式是一种全新的视频格式，全称为Flash Video。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好地应用等缺点，因此FLV格式成为了当今主流视频格式。目前几乎所有全球热门的在线视频网站都采用了FLV视频格式。文件后缀为.flv。</li>
<li>MKV：MKV格式是民间流行的一种视频格式，以它兼容众多视频编码见长，可以是DivX、XviD、RealVideo、H264、MPEG2、VC1等等。但是由于是民间格式，没有版权限制，又易于播放，所以官方发布的视频影片都不采用mkv，网上制作下载常见。文件后缀为.mkv。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/iOS%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/iOS%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">iOS 中的字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 11:30:06" itemprop="dateCreated datePublished" datetime="2020-04-22T11:30:06+08:00">2020-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:43:00" itemprop="dateModified" datetime="2022-05-12T21:43:00+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机是 0 和 1 的世界，为了表示文本，我们就需要指定字符到数字的映射，这个映射就叫做编码。</p>
<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>ASCII（American Standard Code for Information Interchange:美国信息交换标准代码）是由美国国家标准协会制定的单字节字符编码方案。一个字节（8位）可以表示 256 种状态，ASCII 只使用到了一个字节中的 7 位，它将英文字母，数字 0-9 以及一些标点符号和控制字符映射为 0-127 这些整型，所以其最高位一直为 0。</p>
<p>随后，人们基于 ASCII 创建了各种编码系统，并使用了其没有使用的第八位来编码其他字符以期处理英语外的其他语言。但是由于 8 位空间的局限性以及这些编码系统的不兼容性使得一个统一的，全世界每个字符都有一个对应编码的编码标准的出现成为众望所归的事情。它就是 Unicode。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode 标准几乎为世界上各种书写系统里的每一个字符或符号定义了一个唯一的数字。这个数字叫做<strong>码点（code points）</strong>，以 U+xxxx 这样的格式写成，格式里的 xxxx 代表四到六个十六进制的数。</p>
<p>最初，Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。后来，Unicode 编码扩展到了 21 位（从 U+0000 到 U+10FFFF）。<strong>注意现在的 Unicode 不是 16 位的编码！它是 21 位的。</strong> 这 21 位提供了 1,114,112 个码点。编码空间被分为 17 个平面。每个平面有 65,536 个字符。0 号平面叫做<strong>基本多文种平面（Basic Multilingual Plane, BMP）</strong>，涵盖了几乎所有你能遇到的字符，除了 emoji。其它平面叫做补充平面，大多是空的。</p>
<h1 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h1><p>字符和码点之间的映射只完成了一半工作，还需要定义另一种编码来确定码点在内存和硬盘中要如何表示。Unicode 标准为此定义了几种映射，叫做 Unicode 转换格式（Unicode Transformation Formats，简称 UTF）。</p>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32 是一种固定长度的 Unicode 转换格式。每个码点都使用 32 位存储空间，因为太占用空间了从而在实际中很少使用。</p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16 本身是一种长度可变的编码。它是根据有 16 位固定长度的<strong>码元（code units）</strong>定义的。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做<strong>代理对（surrogate pair）</strong>。</p>
<p>和所有多字节长度的编码系统一样，UTF-16（以及 UTF-32）还得解决字节顺序的问题。在硬盘里存储或者通过网络传输字符串时，UTF-16 允许在字符串的开头插入一个<strong>字节顺序标记（Byte Order Mask,BOM）</strong>。字节顺序标记是一个值为 U+FEFF 的码元，通过检查文件的头两个字节，解码器就可以识别出其字节顺序。字节顺序标记不是必须的，Unicode 标准把大端顺序（big-endian byte order）定为默认情况。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序。有效空间利用及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p>
<h1 id="OC-中的-NSString"><a href="#OC-中的-NSString" class="headerlink" title="OC 中的 NSString"></a>OC 中的 NSString</h1><p><strong>NSString 对象代表的其实是用 UTF-16 编码的码元组成的数组。</strong> 因为在 <code>NSString</code> 开发的时候（它最初是作为 Foundation Kit 的一部分在 1994 年发布的），Unicode 还是 16 位的。</p>
<p>默认情况下，Clang 会把源文件看作以 UTF-8 编码的。只要你确保 Xcode 以 UTF-8 编码保存文件，你就可以直接用字符显示程序插入任意字符。如果你更喜欢用码点，最大到 U+FFFF 这个范围内的码点你可以以 @”\u266A”（♪）的方式输入，BMP 外其它平面的码点则以 @”\U0001F340”（🍀）的方式输入。有意思的是，C99 不允许标准 C 字符集里的字符用通用字符名（universal character name）来指定，因此不能这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">//NSString *s = @&quot;\u0041&quot;;</span><br></pre></td></tr></table></figure>

<p><code>NSString</code> 代表的是用 UTF-16 编码的文本，长度、索引和范围都基于 UTF-16 的码元。因此 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsstring/1414212-length?language=objc">length</a> 方法返回的是字符串中码元的数量而不是字符个数。 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/unichar?language=objc">unichar</a> 类型和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsstring/1414645-characteratindex?language=objc">characterAtIndex:</a>方法说的都是码元。</p>
<p><code>-[NSString length]</code> 返回字符串里 <code>unichar</code> 的个数。对于基本多文种平面（BMP）里所有的字符在 UTF-16 里都可以用一个码元表示。但是随着 emoji （在 1 号平面）的流行，实际使用中就会发现代理对，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *s = @&quot;\U0001F30D&quot;; // 🌭  </span><br><span class="line">NSLog(@&quot;%lu&quot;,[s length]);// 2</span><br></pre></td></tr></table></figure>
<p>由于这些组合字符序列的存在，会导致很多不便，幸而， <code>NSString</code> 提供了<code>enumerateSubstringsInRange:options:usingBlock: </code>方法，当参数为<code>NSStringEnumerationByComposedCharacterSequences</code>时，可以对真正的 Unicode 字符进行遍历。</p>
<h1 id="Swift-中的-String"><a href="#Swift-中的-String" class="headerlink" title="Swift 中的 String"></a>Swift 中的 String</h1><p>Swift 中的<code>String</code>类型字符串是例如<code>&quot;hello, world&quot;</code>，<code>&quot;albatross&quot;</code>这样的<strong>有序的 <code>Character</code> 类型的值的集合</strong>。每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 转换格式（UTF）。</p>
<p><strong>Swift 中每个<code>Character</code>类型的值代表一个可扩展的字形群</strong>。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。例如字母 é 可以用单一的 Unicode 标量 é(U+00E9)来表示。然而一个标准的字母 e(U+0065) 加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母 é。这个急促重音的标量形象的将 e 转换成了 é。在这两种情况中，字母 é 代表了一个单一的 Swift 的<code>Character</code>值，同时代表了一个可扩展的字形群。在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;E9&#125;</span>&quot;</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;65&#125;</span><span class="subst">\u&#123;301&#125;</span>&quot;</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 也是同一个单一的 Character值 é</span></span><br></pre></td></tr></table></figure>

<p>可扩展的字符群集可以由一个或者多个 Unicode 标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。</p>
<p>如果想要获得一个字符串中 Character 值的数量，可以使用<code>count</code>属性。需要注意的是通过 <code>count</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/" class="post-title-link" itemprop="url">博客收藏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 14:56:19" itemprop="dateCreated datePublished" datetime="2020-03-09T14:56:19+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-30 00:00:59" itemprop="dateModified" datetime="2023-08-30T00:00:59+08:00">2023-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a target="_blank" rel="noopener" href="https://github.com/soapyigu/LeetCode-Swift">LeetCode-Swift</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QnAT-gnsx-3Yok4js5G_3A">【图解数据结构】 目录（持续更新）</a><br><a target="_blank" rel="noopener" href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/efce1a2a95ab">swift-algorithm-club翻译</a></p>
<h1 id="TCP-IP及网络相关"><a href="#TCP-IP及网络相关" class="headerlink" title="TCP&#x2F;IP及网络相关"></a>TCP&#x2F;IP及网络相关</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">TCP 协议简介</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html">协议森林</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿 上</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿 下</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d9c284b518825095879e7a5">面试官，不要再问我三次握手和四次挥手</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-10-6/">IP，TCP 和 HTTP</a><br><a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/WebSocket/iOS_WebSocket.md">微信,QQ这类IM app怎么做——谈谈Websocket</a><br><a target="_blank" rel="noopener" href="https://draven.co/whys-the-design/">为什么这么设计系列文章</a><br><a target="_blank" rel="noopener" href="http://www.52im.net/thread-1003-1-1.html">不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)</a><br><a target="_blank" rel="noopener" href="http://blog.p2hp.com/archives/4950">TCP&#x2F;IP指南</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/19395.html">HTTP API 认证授权术</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/21708.html">网络数字身份认证术</a><br><a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/23">HTTP2简介和基于HTTP2的Web优化</a></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p><a target="_blank" rel="noopener" href="http://awhisper.github.io/2017/02/26/%E6%89%AF%E6%B7%A1%EF%BC%9A%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E8%81%8A%E7%BC%96%E8%AF%91%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/">扯淡：大白话聊聊编译那点事儿</a><br><a target="_blank" rel="noopener" href="https://github.com/bestswifter/blog/blob/master/articles/compile-and-language.md">大前端开发者需要了解的基础编译原理和语言知识</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/86840">链接器：符号是怎么绑定到地址上的？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-wgBhE11xEXDS7Hqgq3FjA">iOS 微信编译速度优化分享</a><br><a target="_blank" rel="noopener" href="https://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM</a><br><a target="_blank" rel="noopener" href="https://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM 直播的 Slides</a><br><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thin-csapp-4/2016/04/16/">肆 链接 - 不同的代码如何协同</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-6-3/">Mach-O 可执行文件</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-6-2/">编译器</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XIcAdy6E3M45RoF6PDyqHg">iOS端数据库解决方案分析</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/58ff4c7544d9040069fb061e">微信客户端 SQLite 数据库修复实践</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/S51JaEOH98e2AzjejKn0kw">在 iOS 的 SQLite 数据库中应用 FMDB 库</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&mid=2650264198&idx=1&sn=35c6d49a70294c80bc028ed4d4fddce4&chksm=f40683b3c3710aa53a7c2f2e7185da72db59d1b66a1c3dd5aef4365ed02e0e990ae71d548f94&scene=0#wechat_redirect">iOS端数据库解决方案分析</a><br><a target="_blank" rel="noopener" href="https://github.com/Tencent/MMKV/wiki/iOS_tutorial_cn">MMKV for iOS&#x2F;macOS</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/By3fNvSF175a6rg9ke_QoQ">iOS 开发者应该掌握些 C++ 知识</a></p>
<h1 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tppYsCNS57i00RpQKAU5Yw">C 语言中的指针与数组</a></p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/i8hB_g8rJPl6QDi8Hf9y_w">8D85-8D8A-6280-672F ？</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-9-1/">NSString 与 Unicode</a></p>
<h1 id="OPENGL"><a href="#OPENGL" class="headerlink" title="OPENGL"></a>OPENGL</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/B4GxcNz9bybC6aUcnclVLw">20分钟让你了解OpenGL ——OpenGL全流程详细解读</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kRGfCQH91FGgD6AB9JMEkg">从零讲解 iOS 中 OpenGL ES 的纹理渲染</a><br><a target="_blank" rel="noopener" href="https://niyaoyao.github.io/2018/05/23/learning_opengl(es)_opengl_model_pipeline_and_practices/">Learning OpenGL(ES) —— OpenGL Model, Pipeline and Practices</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/nb/2135411">OpenGL ES落影合集</a></p>
<h1 id="计算机程序的构造与解释"><a href="#计算机程序的构造与解释" class="headerlink" title="计算机程序的构造与解释"></a>计算机程序的构造与解释</h1><p><a target="_blank" rel="noopener" href="https://github.com/DeathKing/Learning-SICP">Learning-SICP</a></p>
<h1 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h1><p><a target="_blank" rel="noopener" href="https://vc2tea.com/whats-shadowsocks/">写给非专业人士看的 Shadowsocks 简介</a><br><a target="_blank" rel="noopener" href="https://github.com/haoel/haoel.github.io">科学上网</a><br><a target="_blank" rel="noopener" href="https://manual.nssurge.com/book/understanding-surge/cn/">Surge 官方中文指引：理解 Surge 原理</a></p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a><br><a target="_blank" rel="noopener" href="https://github.com/geeeeeeeeek/git-recipes">🥡Git 菜单</a></p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><a target="_blank" rel="noopener" href="http://billie66.github.io/TLCL/book/">The Linux Commond Line</a></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn-regex</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a><br><a target="_blank" rel="noopener" href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a><br><a target="_blank" rel="noopener" href="https://academy.realm.io/posts/nspredicate-cheatsheet/">NSPredicate Cheatsheet</a></p>
<h1 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24339995">机器学习原来这么有趣！第一章：全世界最简单的机器学习入门指南</a><br><a target="_blank" rel="noopener" href="https://microsoft.github.io/ML-For-Beginners">https://microsoft.github.io/ML-For-Beginners</a></p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ihg_WjwkDRr-UppiFkFTzw">6k 字总结 flexbox 布局 ，收藏就行</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xIhkfOMiis6YWeQBv_i3Og">JavaScript权威面试指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/Objective-C%20%E5%9B%9E%E5%BF%86%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/22/Objective-C%20%E5%9B%9E%E5%BF%86%E5%BD%95/" class="post-title-link" itemprop="url">Objective-C 回忆录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-22 13:48:14" itemprop="dateCreated datePublished" datetime="2019-10-22T13:48:14+08:00">2019-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 21:40:44" itemprop="dateModified" datetime="2022-05-12T21:40:44+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：这篇基本上是重新翻看《Objective-C 基础教程》时的一些阅读笔记，内容偏入门级。熟悉 ObjC 的就不需要翻啦(ー&#96;´ー)。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>早在 20 世纪 80 年代初，Brad Cox 为了融合流行的、可移植的 C 语言和优雅的 Smalltalk 语言的优势，设计出了 Objective-C 语言，它是 C 语言的一个扩展集。1985年，Steve Jobs 创立了 NeXT 公司，他们使用 Objective-C 语言基于 Unix 开发了 NeXTSTEP 操作系统。而在 Apple 收购了 NeXT 之后，从 NeXTSTEP 和 OPENSTEP 编程环境演化出来了著名的 Cocoa 编程工具箱，从此 Cocoa 和 Objective-C 就成了 Apple 公司 OS X 和 iOS 操作系统的核心。</p>
<h2 id="Objective-C-小知识点"><a href="#Objective-C-小知识点" class="headerlink" title="Objective-C 小知识点"></a>Objective-C 小知识点</h2><ul>
<li>Xcode 通过 .m 扩展名来表示文件使用的时 Objective-C 代码，应由 Objective-C 编译器处理。而 C 编译器处理 .c 文件，C++ 编译器处理 .cpp 文件。所有这些编译工作默认由 LLVM 处理。（扩展名 .m 表示 message）</li>
<li>通过<code>#import</code>导入的头文件使用<strong>预编译头文件</strong>（压缩的、摘要形式的头文件）的方式来加快读取速度。</li>
<li>导入头文件使头文件和源文件之间建立了一种紧密的依赖关系。如果头文件有任何变化，那么所以依赖 它的文件都得重新编译。</li>
<li>头文件中的<code>@class</code>指令用于创建一个前向引用，在编译器只需要知道这是一个类，后面只会通过指针去引用它时提供了一个缩短编译时间的好方法，此外，还可以有效解决两个类之间循环依赖的问题。但是在诸如继承时则不能使用，因为编译器需要知道所有超类的信息才能成功为其子类编译<code>@interface</code>部分。</li>
<li><code>@selector()</code>返回一个指向有特定名称的选择器的 SEL 指针。什么是选择器呢？选择器只是一个方法名称，但它以 Objective-C 运行时使用的特殊方式编码，以快速的执行查询，可以使用<code>@selector()</code>编译指令圆括号中的方法名称来指定选择器。</li>
<li><code>@protocol()</code>返回一个指向有特定名称的协议的 Protocol * 指针。</li>
<li>Objective-C 运行时生成一个类的时候，会创建一个代表该类的类对象。类对象包含了指向超类、类名和类方法列表的指针，还包含一个 long 型的数据，为新创建的实例对象指定大小。用来创建新对象的类方法称为工厂方法。</li>
</ul>
<p><img src="/images/SEL-Methods-IMP.png" alt="SEL-Methods-IMP"></p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>在早期的 32 位系统下，<code>BOOL</code>实际上是一种对带符号的字符类型（<code>signed char</code>）的<code>typedef</code>，它使用 8 位的存储空间，通过<code>#define</code>指令把<code>YES</code>定义为 1，<code>NO</code>定义为 0。编译器只将<code>BOOL</code>认作 8 位二进制数，所以将大于 1 字节的整型值赋给一个<code>BOOL</code>变量，那么只有低位字节会被用作<code>BOOL</code>值。<br><img src="/images/Objective-C%E4%B8%AD%E7%9A%84%E7%9C%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E5%80%BC.png" alt="Objective-C中的真值类型和数值">图：<a target="_blank" rel="noopener" href="http://nshipster.cn/bool/">BOOL &#x2F; bool &#x2F; Boolean &#x2F; NSCFBoolean</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/bool?language=objc">目前在64位 iOS, tvOS, watchOS 系统中 BOOL 其实是 bool 的 typedef</a>，也就是说 BOOL 只有0（NO）,1(YES)两个值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS, tvOS, watchOS:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="type">BOOL</span>;</span><br><span class="line"><span class="comment">// macOS</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">BOOL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>OOP 是一种编程架构，可构建由多个对象组成的软件。软件就好比存在于计算机中的小零件，它们通过互相传递信息来完成工作。<br>过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。数据可以通过间接方式引用代码，代码可以对数据进行操作。<br>对象到底是什么呢？<strong>对象是一种包含值和指向其类的隐藏指针的结构体。类是一种能够实例化成对象的结构体，类含有一个指针用于指向实现某个功能的代码。（类对象有什么用呢？让每个对象直接指向各自的代码不是更简单嘛？确实是更简单一些，而且某些 OOP 系统也是这样做的。但是拥有类对象会具备极大的优势，如果在运行时改变某个类，则该类的所有对象都会自动继承这些变化。）</strong><br>在 Objective-C 中调用方法时，一个名为 self 的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象，例如，在代码<code>[circle setFillColor:kRedColor]</code>中，方法将 circle 作为 self 参数进行传递。由此方法可以使用此隐藏的 self 参数查找并操作对象的数据。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="方法调度"><a href="#方法调度" class="headerlink" title="方法调度"></a>方法调度</h3><p>对象在收到消息时，如何知道要执行哪个方法呢？当代码发送消息时，Objective-C 的方法调度机制将在当前类中搜索相应的方法，如果无法在接受消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E5%BA%A6.png" alt="支持继承程序中的方法调度"></p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RoundedRectangle</span> : <span class="title">Shape</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>下图展示了RoundedRectangle对象的内存布局。<br><img src="/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="对象中实例变量的布局"><br>最上面是 NSObject 对象声明的名为 isa 的实例变量，它保存着指向对象当前类的指针，接下来是由 Shape 类声明的两个实例变量 fillColor 和 bounds，最后是由 RoundedRectangle 类声明的实例变量 radius。<br>每个方法调用都获得了一个名为 self 的隐藏参数，它是一个指向接收消息的对象的指针，self 指向继承链中第一个类的第一个实例变量，如上图所示也就是 isa 变量。因为编译器已经看到了所有这些类的 @interface 声明，也就知道了对象中的实例变量的布局，根据这个<strong>基地址再加上偏移地址</strong>，编译器就可以查找其他实例变量的位置了。<br><strong>脆弱的基类问题</strong>：在 Snow Leopard 和 iOS4.0 系统中引入 64 位的 Objective-C 运行时之前，即使苹果工程师想在 NSObject 中添加其他的实例变量也是无法做到的，因为在编译器生成的程序中，那些<strong>偏移位置是通过硬编码</strong>实现的。在引入运行时之后它使用<strong>间接寻址方式</strong>确定了变量的位置（把<strong>实例变量当做一种存储偏移量所用的特殊变量</strong>，交由<strong>类对象</strong>管理，偏移量会在运行时查找，如果类的定义变了，那么存储的偏移量也就变了。因此任何时候都能访问到实例变量正确的偏移量，甚至可以在运行时向类中新增实例变量,这就是<strong>稳固的 ABI</strong> 机制，通过这个机制我们可以在类扩展或实现文件中定义实例变量），从而解决了这个问题。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>为了调用继承的方法在父类中的实现，需要使用 super 作为方法调用的目标。super 既不是参数也不是实例变量。<strong>当你向 super 发送消息时，实际上是在请求 Objective-C 向该类的超类发送消息。</strong> 如果超类中没有定义该消息，Objective-C 会和平常一样继续在继承链上一级中查找。<br><img src="/images/%E8%B0%83%E7%94%A8%E8%B6%85%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95-1.png" alt="调用超类的方法"></p>
<h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>如果要对其他对象中的属性进行操作，应该尽量使用对象提供的存取方法，绝对不能直接改变对象里面的值，例如：<code>main()</code>函数不应该直接访问 Car 类的 engine 实例变量（通过<code>car-&gt;engine</code>的方法）来改变 engine 的属性，而应该使用 setter 方法进行更改。<br><strong>在 Objective-C 中所有对象间的交互都是通过指针实现的。</strong></p>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p>为什么诸如 CGRect, CGPoint, CGSize 等数据类型是 C 的 struct 而不是对象呢？原因在于性能！GUI 程序通常会使用许多临时的坐标、大小和矩形区域来完成工作。但是所有的 Objective-C对象都是动态分配的，而动态分配是一个代价较大的操作，它会消耗大量的时间。</p>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><p>C 字符串是将字符串作为简单的字符数组进行处理，并且在数组最后添加尾部的零字节作为结束标志。<br>NSString 的 length 实例方法能够精确无误的处理各种语言的字符串。因为一个字符占用的可能多余一个字节。这样在 C 语言的<code>strlen()</code>函数只能计算字节数，就会返回错误的数值。</p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><p>NSArray 是用来存储对象的有序列表，你可以在 NSArray 中放入<strong>任意类型</strong>的对象，但是它只能存储 Objective-C 对象，而不能存储原始的 C 语言基础数据类型，如 int， float, enum, struct 和 NSArray 中的随机指针。此外，它还不能存储 nil。<br>没有创建 NSMutableArray 和 NSMutableDictionary 的字面量语法。<br>对可变数组进行枚举操作时，需要注意<strong>不能通过添加或删除这类方式来改变数组的容量</strong>。<br>NSArray 中添加了通过代码块来枚举对象的方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>为什么有了快速枚举还要代码块枚举呢？因为通过代码块可以让循环操作并发执行，而通过快速枚举，执行操作要一项项地线性完成。</p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>为什么不用数组存储而要用字典呢？ 因为字典（也被称为散列表）使用的是键查询的优化方式，可以立即找出要查询的数据而不需要遍历整个数组。<br>尽量不要创建 NSString， NSArray， NSDictionary 的子类，因为它们都是以类簇的方式实现的。</p>
<h3 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h3><p>NSValue 可以封装任意值。</p>
<h3 id="NSPredicate-（谓词）"><a href="#NSPredicate-（谓词）" class="headerlink" title="NSPredicate （谓词）"></a>NSPredicate （谓词）</h3><p>NSPredicate用于指定数据被过滤的条件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> horsepower;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Engine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">Engine *engine = [[Engine alloc] init];</span><br><span class="line">engine.horsepower = <span class="number">300</span>;</span><br><span class="line">Car *car = [[Car alloc]init];</span><br><span class="line">car.engine = engine;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower &gt;= 120&quot;</span>];</span><br><span class="line"><span class="type">BOOL</span> match = [predicate evaluateWithObject:car];</span><br></pre></td></tr></table></figure>
<p><code>-evaluateWithObject:</code>计算指定对象 car 是否满足谓词 predicate 中的条件。本类的谓词中使用 engine.horsepower 作为键路径，对 car 对象应用<code>valueForKeyPath:</code>方法获取引擎的马力。然后比较其是否大于等于 120。<br>NSPredicate 一般用于对集合类中数据的过滤，使用方法可以参考 NSHipster 的这篇文章：<a target="_blank" rel="noopener" href="http://nshipster.cn/nspredicate/">NSPredicate</a>。另外，在谓词字符串中可以使用 <code>LIKE</code> 如：<code>&quot;name LIKE &#39;???er*&#39;&quot;</code> 将会匹配 er 前有3个字符，后面还有一些字符的 name 字符串变量。 也可以是使用 <code>MATCHES</code> 运算符类赋给它一个正则表达式，从而来选择匹配的值。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>如果一个对象内有指针指向其他对象的实例变量，则称该对象拥有这些对象。如果一个函数创建了一个对象，则称该函数拥有这个对象。“拥有一个对象”意味着该实体要负责确保对其所有的对象进行清理。<br>NSObject 类提供了一个<code>-(id)autorelease;</code>的方法，当给一个对象发送 autorelease 消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送 release 消息。例子如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;I am %d years old&quot;</span>,<span class="number">4</span>]];</span><br><span class="line">    <span class="keyword">return</span> [description autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存管理规则：</p>
<ol>
<li>使用 new 、 alloc 和 copy 方法创建一个对象时，该对象的引用计数值为 1，当不再使用该对象时，你应该想该对象发送一条 release 或 autorelease 消息。这样对象将在使用寿命结束时被销毁。</li>
<li>当使用其他方法获得一个对象时，则假设该对象的保留计数器值为 1，而且已经被设置为自动释放了。</li>
<li>如果你保留了某个对象，就需要释放或者自动释放该对象，必须保持 retain 方法和 release 方法的使用次数相等。</li>
</ol>
<p><strong>自动释放池的释放时间是完全确定的：要么是在代码中自己手动销毁，要么是使用 AppKit 时在时间循环结束时销毁。</strong>自动释放池以栈的形式实现：当你创建了一个新的自动释放池时，它就被添加到栈顶。接收 autorelease 消息的对象将被放入最顶端的自动释放池中。<br>Objective-C 的垃圾回收器是新型的垃圾回收器，它定期检查变量和对象并且跟踪它们之间的指针，当发现没有任何变量指向某个对象时，就将该对象视为应该丢弃的垃圾。与自动释放池一样，垃圾回收也是在时间循环结束时触发的。</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>iOS 无法使用垃圾回收，垃圾回收期在运行时工作，通过返回的代码来定期检查对象。ARC 是在编译时进行工作的。它在代码中插入了合适的 retain 和 release 语句。<br>ARC 只对可保留的对象指针有效，主要有三种：</p>
<ul>
<li>代码块指针</li>
<li>Objective-C 对象指针</li>
<li>通过 _<em>attribute</em>((NSObject)) 类型定义的指针</li>
</ul>
<p>声明变量时使用 __weak 关键字或对属性使用 weak 特性的归零弱引用会在指向的对象释放之后，将这些弱引用设置为零（nil）。<br>使用 ARC 时要注意：</p>
<ul>
<li>属性名称不能以 new 开头。</li>
<li>@property 声明的对象其内存管理特性默认为 assign。</li>
</ul>
<h3 id="拥有者权限"><a href="#拥有者权限" class="headerlink" title="拥有者权限"></a>拥有者权限</h3><p>ARC 中的可保留对象指针可以与非可保留对象指针通过<strong>桥接转换</strong>的 C 语言技术来进行转换并对其指针的所有权进行管理。</p>
<ul>
<li><code>__bridge type</code> 操作符：可以使 <code>void *</code> 和 <code>id</code> 对象指针相互转换，这个类型转换会传递指针但是不会传递它的所有权。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *nsString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge <span class="built_in">CFStringRef</span>)nsString;</span><br><span class="line"><span class="comment">//cfString接收了指针，但指针的所有权仍然由 nsString 保留，使用完 cfString 变量之后不需要调用 CFRelease 函数去释放它。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_retained CF type</code> 操作符：这个类型转换会使要转换赋值的变量也持有所赋值的对象。会给对象的保留计数器加 1。__bridge_retained 转换与 retain 类似。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *nsString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)nsString;</span><br><span class="line"><span class="built_in">CFRelease</span>(cfString);</span><br><span class="line"><span class="comment">//cfString 和 nsString 同时持有对象。使用完后 nsString 由 ARC 负责释放，但是 cfString 需要你调用 CFRelease() 函数释放。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_transfer Objective-C type</code> 操作符，与上一个执行相反的操作，被转换的变量所持有的对象在该变量被赋值给转换目标后随之释放。__bridge_transfer 转换与 release 相似。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span> *cString = <span class="string">&quot;cString&quot;</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreateWithCString</span>(<span class="literal">NULL</span>, cString, kCFStringEncodingASCII);        </span><br><span class="line"><span class="built_in">NSString</span> *nsString = (__bridge_transfer <span class="built_in">NSString</span> *)cfString;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,nsString);</span><br><span class="line"><span class="comment">//nsString 持有该对象，使用完后 nsString 由 ARC 负责释放, cfString 在转换完成后释放。</span></span><br></pre></td></tr></table></figure>
<p><strong>在 struct 和 union 中是不能使用保留对象的。</strong>可以通过使用 void* 和桥接转换来解决这个问题。</p>
<h3 id="记录一些疑惑："><a href="#记录一些疑惑：" class="headerlink" title="记录一些疑惑："></a>记录一些疑惑：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *ocString = <span class="string">@&quot;aString&quot;</span>;</span><br><span class="line">        <span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)ocString;</span><br><span class="line">        <span class="built_in">CFShow</span>(cfString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码按照上面的理解，cfString 和 ocString 都是持有了对象的，但是用 Xcode9 的 analyze 来分析并没有曝出内存泄露问题？ 不太能理解，希望看到的大神讲解一下。求教育！</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><h3 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h3><p>向某个类发送 alloc 消息就是从操作系统获得一块内存，并将其指定为存放对象的实例变量的位置。alloc 方法还顺便将这块内存区域全部初始化为 0，如 BOOL 类型变量初始化为 NO, float类型变量初始化为 0.0,指针初始化为 nil。刚分配的对象不能立即使用，需要先初始化，不然会出现奇怪的行为。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>为什么要<strong>嵌套调用</strong> alloc 和 init 方法？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br></pre></td></tr></table></figure>
<p>而不是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [Car alloc]；</span><br><span class="line">[car init];</span><br></pre></td></tr></table></figure>
<p>因为<strong>初始化方法返回的对象可能与分配的对象不同。</strong>像 NSString 和 NSArray 这样的类事件上是以<strong>类簇</strong>的方式实现的，所以 init 方法可以检查它的参数，并决定返回另一个类的对象更合适。<br>我们经常这样写初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">//自定义初始化行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中调用了<code>[super init]</code>，其作用是让超类完成自身的初始化工作。由于 self 参数是通过固定的距离来寻找实例变量所在的内存位置的，如果从 init 方法返回一个新对象，则需要更新 self,以便其后的实例变量的引用可以被映射到正确的内存位置。而且这个赋值操作只影响该 init 方法中 self 的值，而不影响该方法范围以外的任何内容。如果在初始化一个对象时出现问题，则 init 方法可能会返回 nil。</p>
<h3 id="指定初始化函数"><a href="#指定初始化函数" class="headerlink" title="指定初始化函数"></a>指定初始化函数</h3><p>类中某个初始化函数被指派为初始化函数，该类的所有初始化方法都使用指定初始化函数执行初始化操作，而子类使用其超类的指定初始化函数进行超类的初始化，通常接受参数最多的初始化方法是最终的指定初始化方法。<br>如果创建了一个指定初始化函数，则一定要在你自己的指定初始化函数中调用超类的指定初始化函数。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>@property 预编译指令的作用是自动声明属性的 setter 和 getter 方法。</li>
<li>@synthesize 预编译指令的作用是实现该属性的访问方法。所有属性都是基于变量的，当在 synthesize getter 和 setter 方法时，编译器会自动创建适当类型的实例变量，并且在属性名前加下划线，作为实例变量的名字。如果你没有声明这些变量，编译器也会声明的。注：Xcode 4.5 之后，可以不必使用 synthesize 了。</li>
<li>@dynamic 预编译指令告诉编译器不要自动生成任何代码或创建相应的实例变量。我们可以自己去写实现方法。</li>
</ul>
<p>实例变量的声明可以放在头文件和实现文件中，区别在于若有一个子类，并且要从子类直接通过属性访问变量，那么变量就必须声明在头文件中。<br>在使用属性时，同时可以指定其各种特性，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">CGRect</span> size;</span><br></pre></td></tr></table></figure>
<p>展示了属性的默认的一些特性，其中比较重要的是这些内存管理语义的：</p>
<ul>
<li>assign “设置方法”只会执行针对 scalar type 的简单复制操作，如： CGFloat, NSInter</li>
<li>strong 定义了一种”拥有关系“，设置方法会先保留新值，并释放旧值，然后将新值设置上去。</li>
<li>weak 定义了一种”非拥有关系，设置方法与 assign 类似，但是在属性所指的对象释放时，属性值也会被设置为 nil。</li>
<li>unsafe_unretained 语义与 assign 相同，但它适用于 object type ，表示“非拥有关系”，而且在目标对象释放时，属性值也不会被设置为 nil,所以是 unsafe 的。</li>
<li>copy 所属关系与 strong 类似，然而设置方法并不保留新值，而是拷贝它。通常用于 NSString, NSArray, NSDictionaty 及其子类。当源字符串是 NSString 时, copy 操作只是做了次浅拷贝，当源字符串是 NSMutableString 时， copy 操作是深拷贝，属性值指向拷贝生成的新对象。</li>
</ul>
<p>在对象之外访问实例变量时，总是应该通过属性来做，然而在对象内部既可以使用“点语法”通过存取方法来访问实例变量，也可以直接访问实例变量。这两种方法有以下区别：</p>
<ol>
<li>直接访问实例变量不经过 Objective-C 的方法派发，因此速度比较快。</li>
<li>直接访问实例变量，不会调用其“设置方法”，因此绕过了相关属性所定义的“内存管理语义”。</li>
<li>直接访问实例变量，不会触发“键值观察”。</li>
</ol>
<p>因此在对象内部写入实例变量时，应该通过其“设置方法”来做，而在读取实例变量时，直接访问它。例外情况是在初始化方法及 dealloc 方法中应该总是直接访问实例变量。因为子类可能会 override 设置方法。这时在基类中通过设置方法来访问实例变量时将会调用子类的设置方法。（但是若使用了惰性初始化技术，则必须通过存取方法来访问属性）。</p>
<h2 id="类别（Category）"><a href="#类别（Category）" class="headerlink" title="类别（Category）"></a>类别（Category）</h2><p>利用 Objective-C 的动态运行时分配机制，可以为现有的类添加新方法。可以在类别中添加属性（必须是 @dynamic 类型的），但是不能添加实例变量，<strong>类别没有空间容纳实例变量</strong>，添加属性的好处在于可以通过点语法调用 setter 和 getter 方法。<br><strong>使用类别时要注意避免命名冲突，当发生命名冲突时，类别具有更高的优先级，类别方法将完全取代初始方法。</strong><br>类别主要有三个用途：</p>
<ol>
<li>将类的实现代码分散到多个不同的文件或框架中（使用分类中方法时要引入分类的头文件。有时编写程序库时，将分类的头文件不随程序库一起公开，从而使用者就不知道库里还有这些私有方法）。</li>
<li>创建对私有方法的前向引用（在类别中声明该私有方法，然后将该类别置于实现文件的最前端，编译器就知道该方法已经存在，不会发出警告了。主要用于不方便在类的 @interface 部分列出方法或者使用的是尚未发布的私有方法。）。</li>
<li><strong>向对象添加非正式协议，用于实现委托</strong>（创建一个 NSObject 的类别，然后在你的类中实现想要实现的方法。这也意味着只要对象实现了委托方法，任何类的对象都可以成为委托对象。）</li>
</ol>
<p><strong>类扩展是唯一能声明实例变量的分类</strong>，也可以改变属性的读写权限等，类扩展必须定义在其所接续的那个类的实现文件里，而且它没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。与其他分类不同，它没有名字。<br>为什么能在类扩展中定义方法和实例变量呢？因为有<strong>“稳固的 ABI 机制”</strong>，使得我们无需知道对象大小即可使用它，由于类的使用者无需知道实例变量的内存布局，所以他们就不必须定义在公共接口中了。<br>实例变量也可以定义在“实现块”里，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _anInstansceVariable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从语法上来说，这与直接添加到类扩展中等效。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Objective-C 不支持多重继承，但是我们可以通过协议这种方式描述接口，让类遵循协议，然后实现协议中的方法来扩展类的功能。协议最常见的用途是实现<strong>委托模式</strong>，不过也有其他用法。</p>
<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p><strong>“委托模式”</strong>是一种实现对象间通信的编程设计模式，该模式的主旨是：定义一套接口，某对象若想要接受另一个对象的委托，则需遵从此接口，以便称为其“委托对象”（delegate）。而“另一个对象“则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。<br>有了协议之后，类就可以用一个属性来存放其委托对象了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;XXXDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这个属性一般都定义为 weak， 因为通常情况下扮演 delegate 的那个对象也要持有本对象，因此为了避免 retain cycle，存放委托对象的那个属性就得定义为weak 或者 unsafe_unretained。<br>在调用 delegate 对象的方法时，总是应该把发起委托的实例也一并传入方法中（通过协议方法的声明），这样， delegate 对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。<br>有时候需要优化委托对象是否能响应某个协议方法时（调用<code>if([delegate respondsToSelector:@selector(xxx)])</code>），可以将此信息缓存在某个结构体实例变量中。</p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>有时候对象类型并不重要，重要的是对象有没有实现某些方法，在这种情况下可以用<strong>”匿名对象“</strong>来表达这一概念。如：<code>id&lt;XXXDelegate&gt;</code>,不需要知道此对象所属的类型，只有遵循 XXXDelegate 协议就好了。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>数据持久化就是将内存中的数据模型转换为存储模型,以及将存储模型转换为内存中的数据模型的统称。数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。iOS 开发中常用的数据持久化技术有：plist 文件，NSKeyedArchiver，SQLite3，NSUserDefaults，CoreData 等。</p>
<h3 id="plist-文件"><a href="#plist-文件" class="headerlink" title="plist 文件"></a>plist 文件</h3><p>plist 文件可以存储 NSArray, NSDictionary, NSString, NSNumber, NSData, NSDate类及其可变类的对象。一般有两种方式进行读写操作：</p>
<ul>
<li>NSArray, NSDictionary, NSData及其子类可以直接调用<code>writeToFile:atomically:</code>方法将对象写入 plist 文件。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [path stringByAppendingPathComponent:<span class="string">@&quot;test.plist&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,<span class="string">@&quot;string&quot;</span>];</span><br><span class="line">[array writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//... 读取</span></span><br><span class="line"><span class="built_in">NSArray</span> *otherArray = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,otherArray);</span><br></pre></td></tr></table></figure>
<ul>
<li>NSPropertyListSerialization 类可以为存储和加载 plist 的行为提供很多设定项（比如修改数据的为可变类型的），它可以将 plist 的数据内容以二进制的形式写入文件，因此其提供的其实是 NSArray 和 NSDictionary 与 NSData 之间的转换功能。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic =@&#123;<span class="string">@&quot;one&quot;</span>:<span class="string">@&quot;1&quot;</span>,<span class="string">@&quot;two&quot;</span>:@<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSData</span> *serializedData = [<span class="built_in">NSPropertyListSerialization</span> dataWithPropertyList:dic format:<span class="built_in">NSPropertyListBinaryFormat_v1_0</span> options:<span class="number">0</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (serializedData) &#123;</span><br><span class="line">    [serializedData writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...读取 </span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *otherDic = [<span class="built_in">NSPropertyListSerialization</span> propertyListWithData:serializedData options:<span class="built_in">NSPropertyListMutableContainersAndLeaves</span> format:<span class="literal">NULL</span> error:&amp;error];</span><br></pre></td></tr></table></figure>
<h3 id="NSKeyedArchiver-和-NSKeyedUnarchiver"><a href="#NSKeyedArchiver-和-NSKeyedUnarchiver" class="headerlink" title="NSKeyedArchiver 和 NSKeyedUnarchiver"></a>NSKeyedArchiver 和 NSKeyedUnarchiver</h3><p>遵循 NSCoding 协议并实现了其方法的对象都可以将它的实例变量和其他数据编码为数据块，然后保存在磁盘中，需要的时候再读会内存中创建新对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZAThing</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *subThings;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZAThing</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _name = [aDecoder decodeObjectForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">        _number = [aDecoder decodeIntegerForKey:<span class="string">@&quot;number&quot;</span>];</span><br><span class="line">        _subThings = [aDecoder decodeObjectForKey:<span class="string">@&quot;subThings&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">    [aCoder encodeInteger:<span class="keyword">self</span>.number forKey:<span class="string">@&quot;number&quot;</span>];</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.subThings forKey:<span class="string">@&quot;subThings&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZAThing *thing = [[ZAThing alloc] init];</span><br><span class="line">thing.name = <span class="string">@&quot;111&quot;</span>;</span><br><span class="line">thing.number = <span class="number">222</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *things = @[@<span class="number">1</span>,@<span class="number">2</span>];</span><br><span class="line">thing.subThings = [things mutableCopy];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing];</span><br><span class="line">ZAThing *otherThing = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在对象中还有嵌套的对象时，如上面的 subThings，在归档和反归档时会递归调用嵌套对象的 encode 和 decode 方法。（注：如果 subThings 中包含 thing 对象，这样循环包含的话，Cocoa 的归档和反归档也可以对其进行处理，但是不要用试图 NSLog 来打印， NSLog 不够智能不能处理这种情况）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/SDWebImage%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/SDWebImage%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SDWebImage 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 09:42:15" itemprop="dateCreated datePublished" datetime="2019-03-19T09:42:15+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-13 21:34:33" itemprop="dateModified" datetime="2022-05-13T21:34:33+08:00">2022-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="How-is-SDWebImage-better-than-X"><a href="#How-is-SDWebImage-better-than-X" class="headerlink" title="How is SDWebImage better than X?"></a>How is SDWebImage better than X?</h2><p>开篇，我先翻译一下 SDWebImage 官方介绍中的这篇文章：<a target="_blank" rel="noopener" href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F">How is SDWebImage better than X?</a></p>
<ul>
<li><p>从 iOS5.0 开始 NSURLCache 会处理磁盘缓存，那么使用 SDWebImage 相比于单纯使用 NSURLRequest 强在哪里呢？</p>
<blockquote>
<p>确实从iOS5.0开始，NSURLCache 会在内存及磁盘中缓存 HTTP 响应的原始数据。但是每次缓存命中，应用都需要数据解析（HTTP 原始数据是编码的）、内存拷贝等大量的操作将原生的缓存数据转换进UIImage对象中。<br>另一方面，SDWebImage 在内存中缓存了 UIImage 对象，并在磁盘中存储了图片文件的原始压缩数据（已解码）。UIImage 对象使用 NSCache 按原样存储在内存中，所以在使用时并不需要拷贝，而且可以在应用或系统需要时随时释放内存。<br>除此之外，SDWebImageDecoder 将 UIImageView 首次使用 UIImage 对象的解压缩工作放在了后台线程中而不是通常的主线程中，可以减少主线程堵塞。<br>最后，SDWebImage 完全绕过了复杂且易出错的 HTTP 缓存控制配置，从而极大的加速了缓存查找。</p>
</blockquote>
</li>
<li><p>既然 AFNetworking 为 UIImageView 提供了相似的功能，SDWebImage 还有用嘛？</p>
<blockquote>
<p>大概没啥用，AFNetworking 也是利用了基于 Foundation 框架的 URL 加载系统缓存:NSURLCache，还为 UIImageView 和 UIButton 提供了默认使用 NSCached 的可配置内存缓存。缓存行为可以根据相应的 NSURLRequest 来配置。AFNetworking 还提供了图片数据的后台解压缩等 SDWebImage 的特性。<br>因此如果你已经使用了 AFNetworking，而且只想要简单的异步图片加载分类，内置的 UIKIT 框架也够用了。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">小记：七牛云测试域名回收问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 17:08:30" itemprop="dateCreated datePublished" datetime="2018-11-28T17:08:30+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-07 10:26:50" itemprop="dateModified" datetime="2019-01-07T10:26:50+08:00">2019-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>月初收到七牛云的邮件扫了一眼大概是关于测试域名回收的问题，由于我只是用到了七牛云存储来做博客图床也就没在意。今天一上博客发现有些图片已经刷不出来了，请求图片的链接返回:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>error<span class="punctuation">:</span> <span class="string">&quot;no such domain&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这不就很蛋疼了嘛，上后台一看，果然是测试域名的问题：<a target="_blank" rel="noopener" href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules">测试域名使用规范</a>，图片上传后生成域名以 clouddn.com 结尾的 URL 在域名回收后自然不能访问了。</p>
<p>官方给出的解决途径是绑定自定义域名，然而这个域名是需要在公安网备案的，对我来说为使用图床还得搞个备案的域名未免太麻烦，索性先不用七牛云的图床了。当我尝试点击下载文件时：</p>
<p><img src="/images/yun.png" alt="yun"></p>
<p>网页的顶端给了我一个错误提示：</p>
<p><img src="/images/bucket_error.png" alt="bucket_error"></p>
<p>这就很尴尬了，域名被回收了直接下载都下载不了，怎么破呢？只好祭出 google 大法。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>搜索后发现原来七牛云提供了<a target="_blank" rel="noopener" href="https://developer.qiniu.com/kodo/tools/1300/qrsctl">命令行辅助工具qrsctl</a>来对存储资源进行操作，下载下来通过命令<code>chmod +x qrsctl</code>为文件添加可执行权限。然后使用如下命令进行操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录</span></span><br><span class="line">./qrsctl login &lt;User&gt; &lt;Passwd&gt;</span><br><span class="line"><span class="comment">#登录成功后查看所有存放资源的空间（buckets）</span></span><br><span class="line">./qrsctl buckets</span><br><span class="line"><span class="comment">#列出bucket中以prefix开头的所有资源</span></span><br><span class="line">./qrsctl listprefix &lt;bucket&gt; &lt;prefix&gt;                </span><br></pre></td></tr></table></figure>
<p>因为我们要获取所有的图片资源，所以prefix参数使用了<code>&#39;&#39;</code>空字符串，所得结果如下图所示：</p>
<p><img src="/images/terminal_buckets.png" alt="terminal_buckets"></p>
<p>在获取到所有资源名称后，就可以调用<code>qrsctl</code>下载资源的接口了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key为资源文件的名称 destFile为下载的目标路径</span></span><br><span class="line">./qrsctl get &lt;Bucket&gt; &lt;Key&gt; &lt;DestFile&gt;</span><br></pre></td></tr></table></figure>
<p>使用下面的脚本来完成下载任务更加方便：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#``反引号是命令替换，可以先执行其中的命令并暂时保存在变量 imgs 中,``的替换操作也可使用$()操作</span></span><br><span class="line">imgs=`./qrsctl listprefix 176zane <span class="string">&#x27;&#x27;</span>`</span><br><span class="line">i=0 </span><br><span class="line"><span class="comment">#打印$imgs执行结果 然后使用管道符合 | 将结果传给 tr 命令将空格转化为换行符,再将结果逐行读取到 line 变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$imgs</span> | <span class="built_in">tr</span> <span class="string">&quot; &quot;</span> <span class="string">&quot;\n&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#(())用于算数运算比较，此处的判断用于将上面结果中第一行的 ‘marker:‘这个非资源名的信息打印过滤掉</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$i</span>&gt;<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line">        ./qrsctl get 176zane <span class="variable">$line</span> ./<span class="variable">$line</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>虽然对<code>shell</code>脚本不是太熟悉，但是上面的逻辑还是挺简单的，尝试一下很简单就把图片资源下载下来了，但是检查了一下就发现并没有下载完所有的资源，其实这里面还有一个坑：<code>tr &quot; &quot; &quot;\n&quot;</code>命令将之前处理结果分成一行一行的字符串时也将文件名中带有空格的如上图中用绿框框起来的文件名给破坏了，在后台中删除了该文件命名中的空格后重新运行脚本就搞定了。当然这是简单的做法，当你有很多资源名中含有空格时，可以在获取资源名后，在后续的命令中对文件名加上引号来下载：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qrsctl get 176zane <span class="string">&#x27;2018-07-12 10_40_14.gif&#x27;</span> ./<span class="string">&#x27;2018-07-12 10_40_14.gif&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就拿回了所有保存在七牛云上的图片资源，鉴于暂时没找到合适的图床，索性就直接用 github 来保存吧，虽然加载速度会慢点，但还是比较可靠的。全局替换图床链接<code>http://oztca4xvs.bkt.clouddn.com/</code>为本地地址<code>/images/</code>后，将图片复制到<code>source/images/</code>目录下，重新部署即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/21/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/" class="post-title-link" itemprop="url">黑客与画家</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-21 17:30:29" itemprop="dateCreated datePublished" datetime="2017-10-21T17:30:29+08:00">2017-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-03-27 14:07:14" itemprop="dateModified" datetime="2018-03-27T14:07:14+08:00">2018-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B4%A7%E9%93%BA%E5%AD%90/" itemprop="url" rel="index"><span itemprop="name">杂货铺子</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>黑客与画家的共同之处，在于他们都是创作者。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
