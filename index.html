<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:type" content="website">
<meta property="og:title" content="Deep Thought">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="Life is short. Live your dream and wear your passion.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="姚七六">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/08/05/iOS%20App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/05/iOS%20App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">iOS App启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-05 12:28:40" itemprop="dateCreated datePublished" datetime="2023-08-05T12:28:40+08:00">2023-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:39:12" itemprop="dateModified" datetime="2023-09-15T14:39:12+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统中最重要的抽象，它是程序（指令和数据）运行的真正实例。它给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<h2 id="XNU-X-is-Not-Unix"><a href="#XNU-X-is-Not-Unix" class="headerlink" title="XNU(X is Not Unix)"></a>XNU(X is Not Unix)</h2><p><img src="/images/Core%20OS.png" alt="Core OS"></p>
<p>iOS 系统架构分大致为四层，每个层级提供不同的服务。这里我们重点关注处于 Core OS 层的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Darwin_(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">Darwin</a> 操作系统，它是 macOS 和 iOS 操作环境的操作系统部分，是类 Unix 操作系统。Darwin 的内核是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XNU">XNU</a>，XNU 采用的是微内核 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mach">Mach</a> 和 宏内核 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BSD">BSD</a> 的混合内核，具备微内核和宏内核的优点。<br><img src="/images/XNU.png" alt="XNU"></p>
<p>Mach 是为解决早期 Unix 中“一切皆文件”的抽象机制的不足（不方便进行进程间通信（IPC））而出现的替代。它负责操作系统最基本的工作，包括进程和线程抽象、处理器调度、进程间通信、消息机制、虚拟内存管理、内存保护等。但是因为内核态&#x2F;用户态的上下文切换会额外消耗时间，同时内核与服务进程之间的消息传递也会降低运行效率，苹果深度定制了 BSD 宏内核，使其和 Mach 混合使用。BSD 是对 Mach 封装，提供了 POSIX 应用程序接口（Portable Operating System Interface of UNIX）及进程管理、安全、网络、驱动、内存、文件系统（HFS+）、网络文件系统（NFS）、虚拟文件系统（VFS）等功能。</p>
<p>进程对应到 Mach 是 Mach Task，Mach Task 可以看做是线程执行环境的抽象，包含虚拟地址空间、IPC 空间、处理器资源、调度控制、线程容器。进程在 BSD 里是由 BSD Process 处理，BSD Process 扩展了 Mach Task，增加了进程 ID、信号信息等。</p>
<p>线程对应到 Mach 是 Mach Thread，是 Mach 里的最小执行单位。Mach Thread 有自己的状态，包括机器状态、线程栈、调度优先级（有 128 个，数字越大表示优先级越高）、调度策略、内核 Port、异常 Port。线程对应到 BSD 中为POSIX 兼容的线程模型 pthread。</p>
<p>Mach 的模块包括进程和线程都是对象，对象之间不能直接调用，只能通过 Mach Msg 进行通信，也就是 mach_msg() 函数。在用户态可以通过 mach_msg_trap() 函数触发陷阱来处理异常消息切换到内核态，BSD 在异常消息机制的基础上建立了信号处理机制，用户态产生的信号会先被 Mach 转换成异常，BSD 将异常再转换成信号。</p>
<h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><p>Mach-O is a bunch of file types.iOS 的可执行文件及动态库、静态库等都是 Mach-O 格式的。<br><img src="/images/Mach-O%20File%20type.png" alt="Mach-O File type"><br>Mach-O 文件的内部被划分成用大写字母表示的 Segment,每个 Segment 的空间大小为页的整数倍（为了方便虚拟内存的实现）。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。Segment 内部又被划分成小写字母表示的 Section，Section 的空间大小并不一定为页的整数倍，多个 Section 之间不会重叠。<br><img src="/images/Mach-O%20segment.png" alt="Mach-O segment"><br>在 __TEXT segment 中包含了 Mach header，header 中存储了文件类型、适用的 CPU 架构及加载指令数量等基本信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>        magic;      <span class="comment">// 64位还是32位</span></span><br><span class="line">    <span class="type">cpu_type_t</span>      cputype;    <span class="comment">// CPU 类型，比如 arm 或 X86</span></span><br><span class="line">    <span class="type">cpu_subtype_t</span>   cpusubtype; <span class="comment">// CPU 子类型，比如 armv7</span></span><br><span class="line">    <span class="type">uint32_t</span>        filetype;   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">uint32_t</span>        ncmds;      <span class="comment">// load commands 的数量</span></span><br><span class="line">    <span class="type">uint32_t</span>        sizeofcmds; <span class="comment">// load commands 大小</span></span><br><span class="line">    <span class="type">uint32_t</span>        flags;      <span class="comment">// 标签</span></span><br><span class="line">    <span class="type">uint32_t</span>        reserved;   <span class="comment">// 保留字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>紧跟在 header 之后的是多条 Load Command,其中提供了内核与 dyld 加载 Mach-O 文件时所需要的辅助信息。<br>在 __LINKEDIT segment 中存储了诸如函数名称和全局变量的名称及地址等信息的元数据，还保存了每个页的 hash 用于载入时确保文件不被篡改。</p>
<h1 id="XNU-加载主程序（内核态）"><a href="#XNU-加载主程序（内核态）" class="headerlink" title="XNU 加载主程序（内核态）"></a>XNU 加载主程序（内核态）</h1><p>在传统的 Unix 系统中，<code>fork()</code> 是唯一用来创建新进程的方法，该方法将复刻一个当前进程的完整结构，包括二进制代码。所以负责启动其他 App 的进程为了能跑其他人的程序，还需要配合 <code>exec()</code> 方法，把 fork 出来的进程的 image 覆盖成新 App 的。<br>XNU 加载主程序时，会<code>fork()</code>进程，并对进程进行一些基本设置，比如为进程分配虚拟内存、为进程创建主线程、将 Mach-O 可执行文件映射（map 而不是 read）进内存等。相关的代码我们可以看苹果的开源文件：<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/master/bsd/kern/kern_exec.c">kern_exec</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __mac_execve(<span class="type">proc_t</span> p, <span class="keyword">struct</span> __mac_execve_args *uap, <span class="type">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为简化描述，省略部分代码。</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span>  *<span class="title">uthread</span>;</span> <span class="comment">// 线程</span></span><br><span class="line">    <span class="type">task_t</span> new_task = <span class="literal">NULL</span>;   <span class="comment">// Mach Task</span></span><br><span class="line">    ...</span><br><span class="line">    context.vc_thread = current_thread();</span><br><span class="line">    context.vc_ucred = kauth_cred_proc_ref(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配大块内存，不用堆栈是因为 Mach-O 结构很大。</span></span><br><span class="line">    MALLOC(bufp, <span class="type">char</span> *, (<span class="keyword">sizeof</span>(*imgp) + <span class="keyword">sizeof</span>(*vap) + <span class="keyword">sizeof</span>(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">    imgp = (<span class="keyword">struct</span> image_params *) bufp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化开辟的 imgp 结构里的公共数据</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    uthread = get_bsdthread_info(current_thread());</span><br><span class="line">    <span class="keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">        imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">        in_vfexec = TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 程序如果是启动态，就需要创建新的 mach task 和 thread。这些指针将会在 image active 之后指向新的进程。</span></span><br><span class="line">        imgp-&gt;ip_flags |= IMGPF_EXEC;</span><br><span class="line">        <span class="comment">// fork 进程</span></span><br><span class="line">        imgp-&gt;ip_new_thread = fork_create_child(current_task(),</span><br><span class="line">                    <span class="literal">NULL</span>, p, FALSE, p-&gt;p_flag &amp; P_LP64, TRUE);</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">        context.vc_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个函数主要是分配内存，检查权限，然后调用 load_machfile()，在从0x000000起始位置开始留出至少4G（64位）不可读写的空间用于捕捉NULL指针引用，根据 ASLR 随机一个地址开始加载 Mach-O 文件，读取 Mach-O header，根据解析后得到的 load command 信息，通过映射方式加载到内存中。还会使用 activate_exec_state() 函数处理解析加载 Mach-O 后的结构信息，设置执行 App 的入口点。</span></span><br><span class="line">    error = exec_activate_image(imgp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (imgp-&gt;ip_new_thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        task_bank_init(get_threadtask(imgp-&gt;ip_new_thread));</span><br><span class="line">        proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        thread_affinity_exec(current_thread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承进程处理</span></span><br><span class="line">        <span class="keyword">if</span> (!in_vfexec) &#123;</span><br><span class="line">            proc_inherit_task_role(get_threadtask(imgp-&gt;ip_new_thread), current_task());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进程的主线程</span></span><br><span class="line">        <span class="type">thread_t</span> main_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">        task_set_main_thread_qos(new_task, main_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置完入口点后会通过<code>load_dylinker()</code>函数来解析加载 dyld，然后将入口点地址改成 dyld 的入口地址。这一步完后，内核部分就完成了 Mach-O 文件的加载。剩下的就是用户态层 dyld 加载 App 了。<br><img src="/images/load%20mach-o.png" alt="load mach-o"></p>
<h1 id="Dyld-加载动态库（用户态）"><a href="#Dyld-加载动态库（用户态）" class="headerlink" title="Dyld 加载动态库（用户态）"></a>Dyld 加载动态库（用户态）</h1><p>Dyld 也是开源的，在<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/dyld/blob/master/src/dyldStartup.s">dyldStartup.s</a>中 Dyld 的入口函数<code>__dyld_start</code>中，设置好一些寄存器参数后，调用<code>dyldbootstrap::start()</code>方法，其中调用了<code>dyld::_main()</code>，该方法会加载相关的动态库，完成后返回 APP<code>main()</code>函数地址，然后调用<code>main()</code>函数就进入我们熟悉的程序入口了。</p>
<h2 id="Load-dylibs"><a href="#Load-dylibs" class="headerlink" title="Load dylibs"></a>Load dylibs</h2><p><code>dyldbootstrap::start()</code>方法会根 ASLR(Address Space Layout Randomization)计算主执行文件偏移后的地址与 Mach-O header 指针，将其作为参数传递给<code>dyld::_main()</code>函数，接下来：</p>
<ol>
<li><code>setContext()</code>,使用 Mach-O header 中的信息检查并运行环境，创建链接上下文。</li>
<li>验证主执行文件与系统架构的兼容性成功后，实例化主执行文件的 ImageLoader。解析主执行文件的 header，获取需要加载的依赖库的列表。</li>
<li>找到每个 dylib 对其实例化一个 ImageLoader，打开文件读取开头部分，确保它是 Mach-O 文件。然后找到代码签名让内核校验签名。成功后对文件的每个 segment 调用<code>mmap()</code>。由于 dylib 可能会依赖其他 dylib，所以这个加载过程是递归的。一般应用会加载 100-400 个 dylib，但是大多数是系统库，这些库大部分已经被缓存在内存中了，所以加载速度很快。</li>
</ol>
<p><img src="/images/load%20dylibs.png" alt="load dylibs"></p>
<h2 id="Fix-ups"><a href="#Fix-ups" class="headerlink" title="Fix-ups"></a>Fix-ups</h2><p>加载完所有的 dylibs 后，还处于各自独立的状态，需要通过 Fix-ups 将它们绑定在一起。由于代码签名的存在，我们不能直接修改指令，那么如何在一个 dylib 中调用另一个 dylib 的方法呢？这里采用了叫做 dynamic PIC(Position independent Code)的技术，它会在 __DATA segment 中创建一个指针，指向要调用的方法或变量。所以 Fix-ups 都是在修正 __DATA segment 中的指针和数据，将符号绑定在地址上。留意保存在 __DATA segment 中的 __la_symbol_ptr section 中的符号并不是在启动时绑定的，而是在程序运行时首次访问时才绑定的。</p>
<h3 id="Rebasing-and-Binding"><a href="#Rebasing-and-Binding" class="headerlink" title="Rebasing and Binding"></a>Rebasing and Binding</h3><p>Fix-ups 分为两种类型：</p>
<ul>
<li><p>Rebasing:在 dylib 内部调整指针，由于 ASLR 的使用，dylib 会被整体偏移到某个地址，所以需要遍历所有的指针并添加一个偏移值。这里可能会导致 page fault 和 COW，从而会导致I&#x2F;O问题，但是好在是序列化的，内核会预先读取，减少I&#x2F;O 消耗。<br><img src="/images/rebasing.png" alt="rebasing"></p>
</li>
<li><p>Binding:设置指向该 dylib 之外的指针，本质上是通过符号名称绑定的，这些符号信息保存在 __LINKEDIT segment 中，表示这个数据指针要指向某个符号。dyld 需要去符号表中找到该符号对应的实现，然后将指针值存储到 __DATA segment 中的指针中。<br><img src="/images/binding.png" alt="binding"></p>
</li>
</ul>
<h3 id="Notify-Objc-Runtime"><a href="#Notify-Objc-Runtime" class="headerlink" title="Notify Objc Runtime"></a>Notify Objc Runtime</h3><p>这部分内容我在之前的博客:<a target="_blank" rel="noopener" href="https://176zane.github.io/2018/02/07/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">Runtime 源码笔记：对象与类</a> 中类的加载过程一节中有描述到，在 Runtime 的入口函数<code>_objc_init</code>中有注册 dyld 相关事件的回调函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br></pre></td></tr></table></figure>
<p>OC 基于 Runtime 机制可以用类的名字来实例化一个类的对象，Runtime 维护了一张映射类名与类的全局表，当 ImageLoader 加载完 dylib 后，dyld 会调用回调函数<code>map_images</code>对其进行解析和处理，将可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都按格式 fix-up 后成功加载到内存中。<br><img src="/images/notify%20objc%20runtime.png" alt="notify objc runtime"></p>
<h2 id="Initializer"><a href="#Initializer" class="headerlink" title="Initializer"></a>Initializer</h2><p>在完成所有的数据 fix-ups 后，就可以对需要初始化的数据进行初始化操作了。OC 的<code>+load</code>以及 C++ 的<code>constructor</code>方法都会在这个阶段执行。<br><img src="/images/initializers.png" alt="initializers"></p>
<p>完成上面这些工作后，dyld 会调用<code>main()</code>函数。其中调用<code>UIApplicationMain()</code>，我们的 App 就这样启动了。</p>
<p>注：本文中的 dyld 加载动态库的过程是基于 dyld2 描述的，iOS13 系统中已经升级为 dyld3，加载过程略有不同。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">WWDC2016-406</a></li>
<li><a target="_blank" rel="noopener" href="https://justinyan.me/post/4057">macOS 内核之一个 App 如何运行起来</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/231b1cebf477">iOS App从点击到启动</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/07/20/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E7%AC%94%E8%AE%B0%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/20/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E7%AC%94%E8%AE%B0%E4%BA%8C/" class="post-title-link" itemprop="url">《数据结构与算法之美》笔记-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-20 09:20:32" itemprop="dateCreated datePublished" datetime="2023-07-20T09:20:32+08:00">2023-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:38:30" itemprop="dateModified" datetime="2023-09-15T14:38:30+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="排序比较"></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.jpg" alt="冒泡排序"><br>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n-1 次，就完成了 n 个数据的排序工作。</p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/bubble%20sort.playground/Contents.swift">冒泡排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">bubbleSort</span>(<span class="keyword">_</span> <span class="params">nums</span>: <span class="keyword">inout</span> [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>nums.count<span class="operator">-</span><span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> flag <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>nums.count<span class="operator">-</span><span class="number">1</span><span class="operator">-</span>i &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] <span class="operator">&gt;</span> nums[j<span class="operator">+</span><span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">let</span> temp <span class="operator">=</span> nums[j<span class="operator">+</span><span class="number">1</span>]</span><br><span class="line">                nums[j<span class="operator">+</span><span class="number">1</span>] <span class="operator">=</span> nums[j]</span><br><span class="line">                nums[j] <span class="operator">=</span> temp</span><br><span class="line">                flag <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均情况时间复杂度也为 O(n2)。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><img src="/images/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="插入排序"></p>
<p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p>冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？<br>从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。</p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/insertion%20sort.playground/Contents.swift">插入排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">insertionSort</span>(<span class="keyword">_</span> <span class="params">nums</span>: <span class="keyword">inout</span> [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">..&lt;</span>nums.count &#123;</span><br><span class="line">        <span class="keyword">let</span> temp <span class="operator">=</span> nums[i]</span><br><span class="line">        <span class="keyword">var</span> j <span class="operator">=</span> i <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> nums[j] <span class="operator">&gt;</span> temp &#123;</span><br><span class="line">            nums[j<span class="operator">+</span><span class="number">1</span>] <span class="operator">=</span> nums[j]</span><br><span class="line">            j <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[j<span class="operator">+</span><span class="number">1</span>] <span class="operator">=</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h2><p>对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。<br>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。<br>平均情况时间复杂度为O(n2)。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><img src="/images/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" alt="选择排序"></p>
<p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/selectionSort.playground/Contents.swift">选择排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序的交换过程中破坏了稳定性，其不是稳定的排序算法</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">selectionSort</span>(<span class="keyword">_</span> <span class="params">nums</span>: <span class="keyword">inout</span> [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>nums.count &#123;</span><br><span class="line">        <span class="keyword">var</span> j <span class="operator">=</span> i</span><br><span class="line">        <span class="keyword">var</span> min <span class="operator">=</span> nums[i]</span><br><span class="line">        <span class="keyword">var</span> minIndex <span class="operator">=</span> j</span><br><span class="line">        <span class="keyword">while</span> j<span class="operator">&lt;</span>nums.count &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j]<span class="operator">&lt;</span>min &#123;</span><br><span class="line">                min <span class="operator">=</span> nums[j]</span><br><span class="line">                minIndex <span class="operator">=</span> j</span><br><span class="line">            &#125;</span><br><span class="line">            j <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp <span class="operator">=</span> nums[i]</span><br><span class="line">        nums[i] <span class="operator">=</span> min</span><br><span class="line">        nums[minIndex] <span class="operator">=</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h2><p>选择排序是一种不稳定的排序算法，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<h2 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。</p>
<h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>选择排序需要 2 次循环遍历，所以最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序"><br><img src="/images/%E9%80%92%E5%BD%92%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="递归的归并排序"></p>
<p>归并排序使用分治思想，先把待排序序列拆分成一个个子序列，直到子序列只有一个元素，停止拆分，然后对每个子序列进行边排序边合并。归并排序的一个缺点是它需要一个临时的“工作”数组，其大小与被排序的数组相同。 它不是原地排序<br>分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/mergeSort.playground/Contents.swift">归并排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">mergeSort</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;    </span><br><span class="line">    <span class="keyword">let</span> middleIndex <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span>              </span><br><span class="line">    <span class="keyword">let</span> leftArray <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[<span class="number">0</span><span class="operator">..&lt;</span>middleIndex]))             </span><br><span class="line">    <span class="keyword">let</span> rightArray <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[middleIndex<span class="operator">..&lt;</span>array.count]))  </span><br><span class="line">    <span class="keyword">return</span> merge(leftArray,rightArray)             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">merge</span>(<span class="keyword">_</span> <span class="params">leftPile</span>: [<span class="type">Int</span>],<span class="keyword">_</span> <span class="params">rightPile</span>: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> leftIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> orderedPile <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">while</span> leftIndex <span class="operator">&lt;</span> leftPile.count <span class="operator">&amp;&amp;</span> rightIndex <span class="operator">&lt;</span> rightPile.count &#123;</span><br><span class="line">        <span class="keyword">if</span> leftPile[leftIndex] <span class="operator">&lt;</span> rightPile[rightIndex] &#123;</span><br><span class="line">            orderedPile.append(leftPile[leftIndex])</span><br><span class="line">            leftIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> leftPile[leftIndex] <span class="operator">&gt;</span> rightPile[rightIndex] &#123;</span><br><span class="line">            orderedPile.append(rightPile[rightIndex])</span><br><span class="line">            rightIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            orderedPile.append(leftPile[leftIndex])</span><br><span class="line">            leftIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            orderedPile.append(rightPile[rightIndex])</span><br><span class="line">            rightIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> leftIndex <span class="operator">&lt;</span> leftPile.count &#123;</span><br><span class="line">        orderedPile.append(leftPile[leftIndex])</span><br><span class="line">        leftIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> rightIndex <span class="operator">&lt;</span> rightPile.count &#123;</span><br><span class="line">        orderedPile.append(rightPile[rightIndex])</span><br><span class="line">        rightIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orderedPile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h2><p>在元素拆分的时候，虽然相同元素可能被分到不同的组中，但是合并的时候相同元素相对位置不会发生变化，故稳定。</p>
<h2 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>需要用到一个数组保存排序结果，也就是合并的时候，需要开辟空间来存储排序结果，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>
<h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。<br><img src="/images/%E5%BF%AB%E6%8E%92%E5%88%86%E5%8C%BA%E5%87%BD%E6%95%B0%E5%9B%BE%E8%A7%A3.png" alt="快排分区函数图解"></p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/quickSort.playground/Contents.swift">快速排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">partition</span>(<span class="keyword">_</span> <span class="params">array</span>:<span class="keyword">inout</span> [<span class="type">Int</span>],<span class="keyword">_</span> <span class="params">low</span>:<span class="type">Int</span>,<span class="keyword">_</span> <span class="params">high</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot <span class="operator">=</span> array[high]<span class="comment">//直接选择最后一个数字为分区点</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="operator">=</span> low</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> low<span class="operator">..&lt;</span>high &#123;</span><br><span class="line">        <span class="keyword">if</span> array[j] <span class="operator">&lt;</span> pivot &#123;</span><br><span class="line">            <span class="keyword">let</span> temp <span class="operator">=</span> array[j]</span><br><span class="line">            array[j] <span class="operator">=</span> array[i]</span><br><span class="line">            array[i] <span class="operator">=</span> temp</span><br><span class="line">            i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[high] <span class="operator">=</span> array[i]</span><br><span class="line">    array[i] <span class="operator">=</span> pivot</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">quickSortC</span>(<span class="keyword">_</span> <span class="params">array</span>:<span class="keyword">inout</span> [<span class="type">Int</span>],<span class="keyword">_</span> <span class="params">low</span>:<span class="type">Int</span>,<span class="keyword">_</span> <span class="params">high</span>:<span class="type">Int</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> low <span class="operator">&gt;=</span> high &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> index <span class="operator">=</span> partition(<span class="operator">&amp;</span>array, low, high)</span><br><span class="line">    quickSortC(<span class="operator">&amp;</span>array,low,index<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    quickSortC(<span class="operator">&amp;</span>array,index<span class="operator">+</span><span class="number">1</span>,high)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">quickSort</span>(<span class="keyword">_</span> <span class="params">array</span>:<span class="keyword">inout</span> [<span class="type">Int</span>])&#123;</span><br><span class="line">    quickSortC(<span class="operator">&amp;</span>array, <span class="number">0</span>, array.count<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h2><p>在元素分组的时候，相同元素相对位置可能会发生变化，故不稳定。</p>
<h2 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>不同实现空间复杂度不太一样，可以实现原地排序，空间复杂度为O(1)。</p>
<h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>与选取的 pivot 值有关系，如果 pivot 值为最大或最小，导致只有一边进行快速排序，时间复杂度为 O(n2) , 如果选择中间的值为 O(nlogn),平均时间复杂度为O(nlogn);</p>
<h2 id="归并排序和快速排序的区别"><a href="#归并排序和快速排序的区别" class="headerlink" title="归并排序和快速排序的区别"></a>归并排序和快速排序的区别</h2><p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。<br><img src="/images/%E5%BD%92%E5%B9%B6%E5%BF%AB%E6%8E%92%E5%8C%BA%E5%88%AB.jpg" alt="归并快排区别"></p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><img src="/images/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="计数排序"></p>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，然后把C中每个元素变成前面所有元素的累加和，接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到R中的位置，即是该元素排序后的位置。</p>
<p>swift实现<a target="_blank" rel="noopener" href="https://github.com/176zane/LeetCode/blob/master/sort/countingSort.playground/Contents.swift">计数排序</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">countingSort</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> max <span class="operator">=</span> array.max() <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> countArray <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: <span class="type">Int</span>(max <span class="operator">+</span> <span class="number">1</span>)) <span class="comment">//其中存储小于或者等于元素值的个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array &#123;</span><br><span class="line">        countArray[i] <span class="operator">+=</span> <span class="number">1</span><span class="comment">//计算每个元素出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> <span class="operator">..&lt;</span> countArray.count &#123;</span><br><span class="line">        <span class="keyword">let</span> sum <span class="operator">=</span> countArray[i] <span class="operator">+</span> countArray[i <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">        countArray[i] <span class="operator">=</span> sum<span class="comment">//算出小于等于此元素值的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortedArray <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: array.count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array &#123;</span><br><span class="line">        countArray[i] <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        sortedArray[countArray[i]] <span class="operator">=</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稳定性-5"><a href="#稳定性-5" class="headerlink" title="稳定性"></a>稳定性</h2><h2 id="空间复杂度-5"><a href="#空间复杂度-5" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>该算法使用长度为n + 1和n的数组，因此所需的总空间为O(2n)</p>
<h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>第一次遍历A并计算C所花时间是O(n)，C累加所花时间是O(k)，再次遍历A并给R赋值所花时间是O(n)，因此，总时间为O(k + n)。在实际中，当k&#x3D;O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/03/27/[WWDC]Mastering%20Grand%20Central%20Dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/%5BWWDC%5DMastering%20Grand%20Central%20Dispatch/" class="post-title-link" itemprop="url">【WWDC】Mastering Grand Central Dispatch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-27 16:33:36" itemprop="dateCreated datePublished" datetime="2023-03-27T16:33:36+08:00">2023-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-22 23:21:41" itemprop="dateModified" datetime="2023-07-22T23:21:41+08:00">2023-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是对<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/210/">Mastering Grand Central Dispatch WWDC2011 - Session 210</a>以及 GCD 其他内容的学习笔记。</p>
<p>GCD 按照我的理解就是一个系统级的并发模型，通过这个模型你不再需要直接接触底层的“线程”和“锁”去编写大量的对线程安全要求很高的代码，而是在模型中将“执行任务的 Block”添加进合适的“调度队列（dispatch queue）”中就可以轻松实现多线程编程。当然它还附赠了例如<code>dispatch_once</code>在线程安全的环境下实现单例等很多好用的功能！</p>
<p>要编写多线程代码，首先要理解下面这些基本的概念：</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="进程（Process）与线程（Thread）"><a href="#进程（Process）与线程（Thread）" class="headerlink" title="进程（Process）与线程（Thread）"></a>进程（Process）与线程（Thread）</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">进程</a>是程序（指令与数据）的真正运行实例。在早期面向进程设计的操作系统中，进程是程序的基本执行实体；而现代面向线程设计的操作系统中，进程本身不是基本运行单位而是线程的容器。计算机可以同时运行多个进程，有前台进程也有后台进程。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B">线程</a>是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h2 id="并行（Parallelism）与并发（Concurrency）"><a href="#并行（Parallelism）与并发（Concurrency）" class="headerlink" title="并行（Parallelism）与并发（Concurrency）"></a>并行（Parallelism）与并发（Concurrency）</h2><p><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">Grand Central Dispatch Tutorial for Swift 3: Part 1&#x2F;2</a>中的这张图很清晰的解释了两者的区别：</p>
<p><img src="/images/Concurrency_vs_Parallelism.png" alt="Concurrency_vs_Parallelism"><br>在单核 CPU 中通过“上下文切换”（即保存 CPU 的寄存器等信息到各自路径专用的内存块中，从切换目标路径专用的内存块中复原寄存器等信息，继续执行目标路径的命令列的过程）在某个线程与其他线程间反复执行，并发的看上去像是同时执行多个线程一样。而在多核 CPU 中则可以通过并行真正的同时执行多个线程。</p>
<p>GCD 是建立在线程的基础之上的，在下层系统维护着一个共享的线程池，你只需要将执行任务的 block 或者函数添加进 dispatch queues 中，然后由 GCD 来决定在哪个线程上面执行它。GCD 根据系统状态及可用资源来决定进行多大程度的并行。留意并行要求必须是并发的，但是并发并不能保证一定并行！</p>
<h2 id="分发队列（Dispatch-Queue）"><a href="#分发队列（Dispatch-Queue）" class="headerlink" title="分发队列（Dispatch Queue）"></a>分发队列（Dispatch Queue）</h2><p>Dispatch Queue 是管理你添加的要执行任务的队列，它按照先进先出（FIFO）的顺序执行处理。Dispatch Queue 是线程安全的，也就意味着你可以同时在多个线程访问它。Dispatch Queue 分为 Serial Queue和 Concurrent Queue 两种（注：下面部分图片来自 Ray 家的教程）：</p>
<h3 id="串行队列（Serial-Queue）"><a href="#串行队列（Serial-Queue）" class="headerlink" title="串行队列（Serial Queue）"></a>串行队列（Serial Queue）</h3><p><img src="/images/Serial-Queue-Swift.png" alt="Serial-Queue-Swift"><br>Serial Queue 保证在任何时间同时只能执行一个任务，它会等待当前正在进行的任务结束之后再处理其他任务。由 GCD 来控制任务的执行时机，两个任务之间会有多久的间隔也是不确定的。一旦生成 Serial Queue 并添加了任务进去，系统对于一个 Serial Queue 就只生成并使用一个线程。但是多个 Serial Queue 对应各自不同的线程，因此他们之间是可以并行执行的。Serial Queue 与线程的关系可以看下面的gif图（注：图片截取自 WWDC 视频）：</p>
<p><img src="/images/2018-07-0923_21_23.gif" alt="2018-07-09 23_21_23"></p>
<h3 id="并发队列（Concurrent-Queue）"><a href="#并发队列（Concurrent-Queue）" class="headerlink" title="并发队列（Concurrent Queue）"></a>并发队列（Concurrent Queue）</h3><p><img src="/images/Concurrent-Queue-Swift.png" alt="Concurrent-Queue-Swift"></p>
<p>Concurrent Queue 允许同时执行多个任务，其中的任务会按照被添加的顺序出队开始执行，但是它不会等待正在执行的任务结束就可以开始下一个任务。任务结束的顺序及同一时刻正在执行的任务数量是不确定的。一个 Concurrent Queue 可以使用多个线程同时执行多个处理。什么时候开始执行一个任务，在多核环境下是使用“上下文切换”还是在另一个核心上运行这些都是由 GCD 决定的。Concurrent Queue 与线程的对应关系可以看下图：</p>
<p><img src="/images/2018-07-1000_02_32.gif" alt="2018-07-10 00_02_32"></p>
<h1 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h1><h2 id="dispatch-get-main-queue-dispatch-get-global-queue"><a href="#dispatch-get-main-queue-dispatch-get-global-queue" class="headerlink" title="dispatch_get_main_queue&#x2F;dispatch_get_global_queue"></a>dispatch_get_main_queue&#x2F;dispatch_get_global_queue</h2><p>有两种途径得到Dispatch Queue：</p>
<ol>
<li>获取系统标准提供的 Main Queue&#x2F;Global Queues</li>
<li>通过<code>dispatch_queue_create</code>函数生成的 Custom Queues</li>
</ol>
<p>Main Queue 中的任务是在主线程 Runloop 中执行的,因为主线程只有一个，Main Queue 自然也就是一个 Serial Queue。由于在主线程中执行，因此要将用户界面的更新等必须在主线程中执行的任务添加到 Main Queue 中。可以通过<code>dispatch_get_main_queue()</code>函数获取。</p>
<p>Global Queue 是整个系统共享的 Concurrent Queue,它包含四个不同优先级的队列：high, default, low, 和 background。在 iOS 8.0 之前，只需要将任务提交到对应执行优先级的 Global Queue 中即可保证任务执行的优先级顺序。例如获取一个高优先级队列的函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数 flag 是为未来保留的，现在传入 0 即可。</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> highGlobalQue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>现在你不需要直接指定 Queue 的优先级了，而是指定一个 Quality of Service (QoS) 级别来暗示任务的重要性，然后 GCD 通过这个值来决定使用哪个优先级的队列。Qos 级别有以下几种：</p>
<ul>
<li><code>QOS_CLASS_USER_INTERACTIVE</code>: 这个级别代表任务需要尽快执行以便提供良好的用户体验，主要用于 UI 刷新，处理事件等需要低延迟的任务。这个级别的任务应该在主线程执行。</li>
<li><code>QOS_CLASS_USER_INITIATED</code>: 这个级别代表任务是从 UI 线程初始化的，可以异步执行，主要用于尽快的得到执行结果，这个级别被映射到了高优先级队列。</li>
<li><code>QOS_CLASS_DEFAULT</code>: 默认的任务级别。映射到默认优先级队列。</li>
<li><code>QOS_CLASS_UTILITY</code>: 这个级别的任务通常是耗时的，主要用于计算，磁盘IO,网路通信等，它被设置为尽量节省能源的。这个级别被映射到了低优先级队列。</li>
<li><code>QOS_CLASS_BACKGROUND</code>:这个级别的任务大多是用户感知不到的，会被映射到后台优先级队列</li>
<li><code>QOS_CLASS_UNSPECIFIED</code>:这个级别表示服务质量缺失。</li>
</ul>
<p>获取一个<code>QOS_CLASS_USER_INITIATED</code>级别的队列方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> userInitiatedQue = dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数&quot;com.zane.serialQueue&quot;用来标记这个队列，在 Instruments 中调试时作为队列的名字。第二个参数使用 NULL/DISPATCH_QUEUE_SERIAL 表示生成串行队列，使用 DISPATCH_QUEUE_CONCURRENT 表示生成并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customeConcurrentQue = dispatch_queue_create(<span class="string">&quot;com.zane.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>上面代码创建的 Serial Queue,在往这个队列中提交了任务之后，系统就会为它生成一个线程。使用这个方法创建多少个 Serial Queue，就会对应生成多少个相互间并行的线程，因此如果创建大量的 Serial Queue 就会消耗大量内存，引起大量上下文切换，使得程序性能降低。因此只应该在多个线程更新共享资源会导致数据竞争时，使用一个 Serial Queue.</p>
<p>上面创建的 Concurrent Queue，不管创建多少个，系统都只会为其使用有效管理的几个线程。</p>
<p>早期通过这个方法生成的 Queue 还需要使用<code>dispatch_release()</code>函数释放它，iOS 6 之后，系统通过ARC 来管理生成的 Queue，提交进 Queue 的 block 会持有一个该 Queue 的引用，所以只有在 Queue 中所有的 block 执行完之后才会释放。</p>
<h2 id="dispatch-sync-dispatch-async"><a href="#dispatch-sync-dispatch-async" class="headerlink" title="dispatch_sync&#x2F;dispatch_async"></a>dispatch_sync&#x2F;dispatch_async</h2><p>可以通过下面两个常用的函数向 Queue 中添加任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="type">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async</code>函数是非同步（asynchronous）的，他将 block 添加进 queue 中，不做任何等待立即返回，这样不会阻碍当前执行的线程，可以继续进行下一行函数，常用于处理后台任务。<code>dispatch_async</code>函数内部会先将 block 拷贝到堆中，避免 block 执行前就被销毁。</p>
<p><code>dispatch_sync</code>函数是同步（synchronous）的，它将 block “同步的”添加进 queue 中，在添加进的这个 block 任务执行完成之前，<code>dispatch_sync</code>函数会一直等待，该函数会处于调用状态而不返回。也就是说当前线程是停止的。当 block 中的任务执行结束之后，函数返回，当前线程继续进行下一行函数。</p>
<p>与<code>dispatch_async</code>不同，<code>dispatch_sync</code>不会对该 queue 执行 retain 操作,它从调用者那里“借来”一个对 queue 的引用，而且也不会对 block 做<code>Block_copy</code>操作。</p>
<p><code>dispatch_sync</code>函数的特性导致其很容易引起死锁的情况，如在执行一个 Serial Queue 的任务的线程中，将一个任务 block 同步添加到这个 Serial Queue 中时，就会发生死锁。因为该线程中正在执行这个函数，它已经处于调用状态而不返回，也就无法执行 block 中的任务，两者互相等待，形成死锁。实例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(customeSerialQue, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(customeSerialQue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实还有相对应的<code>xxx_f</code>的直接提交函数任务的 API，上面的两个函数实现中其实也是封装调用了下面的函数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当提交的 work 函数调用时，context 作为第一个参数传递给 work 函数，表示上下文数据。work 函数不能为空。</span></span><br><span class="line"><span class="type">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> *context, dispatch_function_t work);</span><br><span class="line"><span class="type">void</span> dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-sync-dispatch-barrier-async"><a href="#dispatch-barrier-sync-dispatch-barrier-async" class="headerlink" title="dispatch_barrier_sync&#x2F;dispatch_barrier_async"></a>dispatch_barrier_sync&#x2F;dispatch_barrier_async</h2><p>这个函数通常用于处理“读者写者”的问题。当多个线程同时对一份数据进行操作时，这时就很容易出现“线程不安全”的问题，在 GCD 出现之前我们通常使用<code>@synchronized()</code>锁或者<code>NSLock</code>锁来提供同步机制。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法会给对象<code>self</code>自动创建一个锁，等块中的代码执行完毕后就释放这个锁。它的缺点在于如果你代码中有大量的<code>@synchronized(self)</code>时，他们都共用同一个锁，程序可能会等待另一段于此无关的代码执行完毕。</p>
<p>有 GCD 之后，我们可以使用 Serial Queue 来提供替代方案，将读取与写入操作都写入同一个 Serial Queue 中，即可保证数据同步。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_customeSerialQue =dispatch_queue_create(<span class="string">&quot;com.zane.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *tempString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeSerialQue, ^&#123;</span><br><span class="line">        tempString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tempString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="comment">//注：其实设置方法也可以使用 dispatch_async,因为这里并不需要等待返回值。</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeSerialQue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，我们可以发现这个问题中，多个读取方法是可以并发执行的，但是读取方法与写入方法之间不能并行执行。这时就可以请出<code>dispatch_barrier_sync</code>&#x2F;<code>dispatch_barrier_async</code>方法了。他们在 Concurrent Queue 上工作时提供了一个串行式的瓶颈，在队列中，通过他们提交的任务必须单独执行，这就意味着在 barrier 之前提交的任务必须先全部完成，然后再单独执行 barrier 提交的任务，执行完成后，队列又恢复正常的并发状态。这些特性意味着该方法只对 Concurrent Queue 有意义，因为 Serial Queue 本身就是一次执行一个任务的。</p>
<p><img src="/images/Dispatch-Barrier-Swift.png" alt="Dispatch-Barrier-Swift"><br>再看一个动图,加深理解：<br><img src="/images/2018-07-1210_40_14.gif" alt="2018-07-12 10_40_14"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_customeConcurrentQue =dispatch_queue_create(<span class="string">&quot;com.zane.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *tempString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_customeConcurrentQue, ^&#123;</span><br><span class="line">        tempString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tempString;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    dispatch_barrier_async(_customeConcurrentQue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“读者写者问题”的实例代码如上，还有一点需要留意的是在上述代码中我们使用了<code>dispatch_queue_create</code>生成的自定义的并发队列，而没有使用<code>dispatch_get_global_queue</code>获取系统的全局并发队列，这是因为全局并发队列是系统资源，他不喜欢你来操纵它，所以<code>dispatch_barrier_async</code>函数用在它上面是没有效果的，效果跟使用<code>dispatch_async</code>函数一样。同理，可以暂时挂起队列和恢复队列执行的<code>dispatch_suspend/dispatch_resume</code>对于全局并发队列也是没有效果的。</p>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p><code>dispatch_after</code>用于一个任务的延后执行。它并不是在指定的时间执行，而是在指定的时间异步的将任务添加进 queue 中。它的一个简单的示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码与 3 秒后使用<code>dispatch_async</code>函数将 block 添加进 Main Queue 中的效果是一样的。它的第一个参数是<code>dispatch_time_t</code>类型的值，一般通过<code>dispatch_time</code>函数或者<code>dispatch_walltime</code>函数获取，前者通常用于计算相对时间，后者用于计算绝对时间。这个参数传入<code>DISPATCH_TIME_NOW </code>的话，倒不如直接使用<code>dispatch_async</code>函数。传入<code>DISPATCH_TIME_FOREVER</code>结果是未定义的。</p>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p><code>dispatch_once</code>是用来保证在应用程序中只执行一次处理的 API。它是线程安全的操作，因此几乎成了 Objctive-C 中实现单例的标准方法了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> SomeClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_once</code>的第一个参数是一个指向<code>dispatch_once_t</code>的指针，用来测试 block 中的任务是否已经完成。对于只需执行一次的任务来说，每次调用传入的该标记值应该完全相同。所以该指针指向的变量应该为静态变量或者全局变量。</p>
<h2 id="调度组（Dispatch-Group）"><a href="#调度组（Dispatch-Group）" class="headerlink" title="调度组（Dispatch Group）"></a>调度组（Dispatch Group）</h2><p>Dispatch Group 涉及到集合的同步化，你将多个任务添加到一个分组之后，就可以等待所有的任务执行完毕，或者提供一个回调函数后继续往下执行，当所有任务执行完毕后收到通知，执行回调函数。更厉害的是你提交的任务可以属于不同的 Queue。这种特性常用于必须在指定的任务都完成的情况下才能继续的情况。</p>
<p>先看一个简单的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_UTILITY, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//1生成一个 group</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">//2异步添加任务  </span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3挂起线程，等待任务完成或超时</span></span><br><span class="line"><span class="type">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)<span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;working&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先通过<code>dispatch_group_create</code>方法生成一个 group， 然后通过<code>dispatch_group_async</code>函数将 block 添加进 queue 中并与 group 联系起来之后，group 就会保持一个其中未完成任务的数量值，连接一个任务时增加该值，任务完成后减少该值。后面的<code>dispatch_group_wait</code>和<code>dispatch_group_notify</code>函数就是使用这个数量值来判断与这个 group 连接起来的所有任务是否完成。</p>
<p><code>dispatch_group_async</code>函数与<code>dispatch_async</code>相似，只是多了将任务 block 与 group 联系起来的作用。</p>
<p>在这里我们使用了<code>dispatch_group_wait</code>函数，它会一直处于调用状态而不返回，从而阻塞了当前线程，直到 group 中的所有任务执行完成或者到达指定的时间。返回时若所有任务都执行完成，这个函数的返回值为 0，否则不为 0。你也可以指定时间参数为<code>DISPATCH_TIME_FOREVER</code>让它一直等待直到全部任务完成。</p>
<p>除了上面这种同步等待的方式，还可以使用<code>dispatch_group_notify</code>来异步的获取通知，它的调用不会阻塞当前线程，直接返回。在检测到队列中的所有任务完成时，<code>dispatch_group_notify</code>会将执行结束处理的 block 添加到 它指定的 queue 中。上例中的注释 3 后的部分可以替换成下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一个特殊的需求，试想：如果我们打算在任务 block 中添加一个想要异步执行的任务，比如下载一张图片等等，这个时候若使用下面这种方式添加任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;/images/thehitchhiker2.png&quot;</span>];</span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;download done!&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可能不会达到期望的效果，程序可能会在打印了<code>work done!</code>之后再打印<code>download done!</code>，这是因为连接在 group 上的任务是异步的，它的 block 程序已经执行完了，但是它的实际下载并没有完成，而如果我们想观察的是下载任务的结束的话就需要请出<code>dispatch_group_enter</code>与<code>dispatch_group_leave</code>的组合了。实例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;/images/thehitchhiker2.png&quot;</span>];</span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;work done&quot;</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>
<p>这样就能达到我们的目的了。<code>dispatch_group_enter</code>函数表示一个任务进入这个 group 了，会增加队列中未完成任务的数量值，<code>dispatch_group_leave</code>表示一个任务已经完成，会减少队列中未完成任务的数量值。这两个函数的组合使得我们可以更合理的控制 group 中未完成任务的个数，从而达到更精确的控制。<code>dispatch_group_enter</code>与<code>dispatch_group_leave</code>应该彼此对应，如果 enter 了而没有 leave，那么这一组任务将永远不会完成。</p>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> (^block)(size_t));</span><br></pre></td></tr></table></figure>
<p>这个 API 会将带参数的 block 提交到 queue 中，用于多次调用。调用次数由第一个参数 iterations 决定，并且他会阻塞当前线程等待任务的迭代次数完成后才返回。若 queue 参数是 Concurrent queue 的话，那么这些迭代任务可以并发执行。若是 Serial queue 的话，且该 queue 对应的线程是当前正在运行的线程，则会与<code>disparch_sync</code>一样发生死锁的情况。注意若迭代次数过多或者执行任务很简单的话，该函数所带来的并发收益不能抵消创建线程等其他开销，这种情况下最好还是使用<code>for</code>循环。</p>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_set_target_queue(dispatch_object_t object, <span class="built_in">dispatch_queue_t</span> queue);</span><br></pre></td></tr></table></figure>
<p>这个 API 可以为一个 object 设置 target queue,这个 object 可以是 dispatch queue、dispatch source或者 dispatch io 等等，target queue 最终决定了 object 所包含的任务会在哪个 queue 被调用。</p>
<p>queue 之间会形成一套层级体系，除了 Global queue 之外其他的 queue 都有其 target queue, queue 中的任务最终会在其 target queue 中执行。Global queue 在这个层级的最上层，沿着这个层级体系，所有的 queue 最终其 target queue 都会指向 Global queue和 Main queue。由 Global queue 的优先级（上文中讲到 Global queue 有如下优先级：high, default, low, 和 background）决定最终的执行优先级。使用<code>dispatch_queue_create</code>生成的 queue, 不管是 Serial queue 还是 Concurrent queue 其 target queue 默认都是 default 优先级的 Global queue。</p>
<p><code>dispatch_set_target_queue</code> 的过程是类似<code>dispatch_barrier_async</code>，所以它不会影响已经添加在 queue 中的任务的执行过程，只会影响设置完 target queue 之后添加的任务。要留意设置 target queue 时不要形成循环。</p>
<p>修改一个 object 的 target queue 会影响它原本的行为：</p>
<ul>
<li>Dispatch queues:将一个 queue 的 target queue 设置为 Serial queue 会同步化这个 queue。例如下图中的层级体系中（图片来自Effective Objective-C 2.0），排在 queue B与 queue C 中的 block 会在 queue A 中依次执行。于是排列在 queue A、B、C中的 block 总会错开串行执行（他们之间没有固定排序）。但是 queue A 与 queue D 中的 block 则可以并行执行。<img src="/images/targetqueuehierarchy.png" alt="target queue hierarchy">当然，如果你将一个 concurrent queue 的 target queue 指向 serial queue，那么其中的任务会串行的执行。</li>
<li>Dispatch sources: dispatch source 的 target queue 决定了它的事件处理的 block 将会被被提交到哪个 queue 中。</li>
<li>Dispatch I&#x2F;O channels:如果一个 Dispatch I&#x2F;O 的 target queue 被设置为 background 优先级的 Global queue 时，<code>dispatch_io_read</code>和<code>dispatch_io_write</code>这些操作将会被节流。</li>
</ul>
<p>若你有向一个 Serial queue 的前端添加任务的需求的话，使用<code>dispatch_set_target_queue</code>也可以满足你的需求：<br><img src="/images/jumpthequeue.png" alt="jump the queue"></p>
<h2 id="dispatch-queue-set-specific-dispatch-get-specific"><a href="#dispatch-queue-set-specific-dispatch-get-specific" class="headerlink" title="dispatch_queue_set_specific&#x2F;dispatch_get_specific"></a>dispatch_queue_set_specific&#x2F;dispatch_get_specific</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_queue_set_specific(<span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">void</span> *context, dispatch_function_t destructor);</span><br><span class="line"><span class="type">void</span> * dispatch_get_specific(<span class="keyword">const</span> <span class="type">void</span> *key);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_set_specific</code>适用于将任意数据以键值对的形式关联到指定的 queue 中。留意与<code>NSDictionary</code>中的对象比较不同的是这个函数中的 key 比较的是指针值，而不是指针所指向的对象。所以可以使用一个静态变量的指针来传入这个参数。不建议直接传入一个字符串常量。context 参数是与 key 关联的上下文参数，可以为 NULL。在 destructor 参数中可以释放前面的 context 参数,当队列释放时，或者有新的值与该 key 关联时，原有的值就会被移除，这个析构函数就会被调用。</p>
<p><code>dispatch_get_specific</code>这个函数需要在一个执行于 queue 中的 block 中调用，用以获取这个 queue 关联的数据，若不是在 queue 中运行的代码中调用则会返回 NULL。需要注意的是这个函数如果在指定的 queue 中查找不到 key 对应的数据，则会沿着 queue 的层级体系一直向上查找，直到找到数据或者达到根队列位置。要是传入的 queue 是 Global queue 也会返回 NULL。</p>
<p><code>dispatch_get_specific</code>的特性可以用于解决一个 queue 层级间的同步化导致死锁的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueueA = dispatch_queue_create(<span class="string">&quot;com.zane.serialQueueA&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueueB = dispatch_queue_create(<span class="string">&quot;com.zane.serialQueueB&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">dispatch_set_target_queue(serialQueueB, serialQueueA);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> kQueueSpecific;</span><br><span class="line"><span class="built_in">CFStringRef</span> stringValue = <span class="built_in">CFSTR</span>(<span class="string">&quot;queueA&quot;</span>);</span><br><span class="line"><span class="comment">//析构函数只能带有一个指针参数且返回值为空，这里可以使用 CFRelease 作为析构函数</span></span><br><span class="line">dispatch_queue_set_specific(serialQueueA, &amp;kQueueSpecific, (<span class="type">void</span> *)stringValue, (dispatch_function_t)<span class="built_in">CFRelease</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过 queue 特有关联数据，判断若在 queueA 中则直接执行 block，若不在则同步到 queueA 中执行，以此避免同步队列的死锁。</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueueB, ^&#123;</span><br><span class="line">    dispatch_block_t block = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;work&quot;</span>);&#125;;</span><br><span class="line">    <span class="comment">//dispatch_get_specific 在 queueB 中找不到，再去它的 target queue 中寻找。</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> specificValue = dispatch_get_specific(&amp;kQueueSpecific);</span><br><span class="line">    <span class="keyword">if</span> (specificValue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(serialQueueA, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="信号量（Dispatch-Semaphore）"><a href="#信号量（Dispatch-Semaphore）" class="headerlink" title="信号量（Dispatch Semaphore）"></a>信号量（Dispatch Semaphore）</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>是一个同步对象，用于保持在 0 至指定最大值之间的一个计数值。当线程完成一次对该 semaphore 对象的等待（wait）时，该计数值减一；当线程完成一次对 semaphore 对象的释放（release）时，计数值加一。当计数值为0，则线程等待该 semaphore 对象不再能成功直至该 semaphore 对象变成 signaled 状态。semaphore 对象的计数值大于 0，为 signaled 状态；计数值等于0，为 nonsignaled 状态。</p>
<p>我们通过下面的例子看看 GCD 中的信号量怎么用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建一个信号量，初始值为1  </span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">//当信号量大于等于1时，dispatch_semaphore_wait 会将信号量减 1 ，并返回。若信号量小于1 ，则会一直等待，直到信号量大于1或者超时。该函数的返回值与 dispatch_group_wait 函数一样。</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [mutableArray addObject:@(i)];</span><br><span class="line">        <span class="comment">//在执行完需要同步的任务后，将信号量的值加 1，使得其他线程中最先等待该信号量的代码继续执行。</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要留意的是当信号量变量还在使用时，对该变量进行重新赋值或者置空会释放之前的信号量，从而引起崩溃！</p>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>Dispatch Source 是 BSD 系统内核惯有功能 kqueue 的包装，kqueue是在 XNU 内核中发生各种系统事件（例如 Unix 信号、文件描述符、Mach 端口事件、定时器等等）时，在应用程序编程方执行处理的技术。其内存占用小，尽量不占用资源，可以说是应用程序处理 XNU 内核中发生的各种时间的方法中最优秀的一种。</p>
<p>Dispatch Source 可以在这些事件发生时，在指定的 queue 中执行事件的处理。下面我们通过一个使用 Dispatch Source 设置定时器的例子看看他的简单用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 dispatch source 来监控底层系统事件，当事件发生时，将相应的 handler block 提交到指定 queue 中。第一个参数为监控的时间类型，第二个参数是与第一个参数有关的信号编号，地灿哥参数也是与第一个参数有关的特定时间标志，第四个参数为提交 handler block 的 queue。这个创建过程是异步执行的。</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line"><span class="comment">//设置定时器，第三个参数为间隔时间，这里设置为 DISPATCH_TIME_FOREVER 表示不需要重复。第四个参数为允许系统延迟的时间。注意即使该值为0，系统也可能会延迟这个定时器的执行。</span></span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), DISPATCH_TIME_FOREVER, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">//定时器指定时间所需要提交到 queue 中执行的任务 block</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer fired!&quot;</span>);</span><br><span class="line">    <span class="comment">//可以使用 dispatch_source_cancel 来取消一个 dispatch source </span></span><br><span class="line">    dispatch_source_cancel(timer);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//设置取消 dispatch source 时的处理，这个函数是异步执行的，取消之后就不会再有更多的 event 事件被传递，但是已经加入 queue 中的处理可以继续执行。</span></span><br><span class="line">dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer canceled&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch source 创建后是处于 suspend 状态的，在设置完 event handler 等属性之后需要调用 dispatch_resume 开启</span></span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>Dispatch source 是不可重入的，任何在 dispatch source 处于 suspend 状态或者 event handler 正在执行的时候接收的事件都会被合并，并在 dispatch source resume 之后或者 handler 返回后被提交。</p>
<p>Dispatch Source 与 Dispatch Queue 不同的是它是可以取消的，而且可以设置取消时的 handler。</p>
<p>需要留意的一点是 dispatch source 在 suspend 状态下，如果直接设置 source &#x3D; nil 或者重新创建 source 都会造成崩溃。正确的方式是在 resume 状态下调用<code>dispatch_source_cancel</code>后再重新创建。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>本文主要讨论了一些常用的 API,着重描述了使用时的一些注意点，容易导致问题的地方。阅读完会对iOS中使用 GCD 进行多线程编程有一个大概的认识。还有在一些其他情况下，诸如读取大文件等等也可使用 Dispatch I&#x2F;O及 Dispatch Data 等，可以用时再去研究。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">Grand Central Dispatch Tutorial for Swift 3: Part 1&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/148515/grand-central-dispatch-tutorial-swift-3-part-2">Grand Central Dispatch Tutorial for Swift 3: Part 2&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/210/">Mastering Grand Central Dispatch WWDC2011 - Session 210</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/dispatch?language=objc">Dispatch</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/" class="post-title-link" itemprop="url">Runtime 源码笔记：对象与类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 16:28:36" itemprop="dateCreated datePublished" datetime="2022-07-04T16:28:36+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-03 00:03:23" itemprop="dateModified" datetime="2023-08-03T00:03:23+08:00">2023-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>同事突然指着<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime(objc4-723)的源码</a><code>objc-private.h</code>中下面这段，问我：“<code>objc_object</code>结构体中只有一个<code>isa</code>变量，那对象中的实例变量去哪了？”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">   <span class="type">isa_t</span> isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一下子有点儿懵逼，印象中的对象的内存布局总是如下图所示：</p>
<p><img src="/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="对象中实例变量的布局"></p>
<p>声明一个<code>RoundedRectangle</code>类的实例对象变量，该变量指向对象中继承自<code>NSObject</code>类的<code>isa</code>实例变量，<code>isa</code>后紧跟着继承自其父类<code>Shape</code>中的<code>fillColor</code>和<code>bounds</code>实例变量，之后是它自己的<code>radius</code>实例变量。</p>
<p>那么，这到底是怎么回事呢？</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>我们在最初学习 Objective-C 时知道，所有的对象都包含一个叫<code>isa</code>的变量，该变量是一个指向对象所属类的指针，其定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    Class isa;                              <span class="comment">//指向该类的 metaClass</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__                              <span class="comment">//以下在OBJC2（06年发布）版本后就废弃了</span></span></span><br><span class="line">    Class super_class;                      <span class="comment">//指向该类的父类，若该类为根类时为NULL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                       <span class="comment">//类名</span></span><br><span class="line">    <span class="type">long</span> version;                           <span class="comment">//类的版本信息</span></span><br><span class="line">    <span class="type">long</span> info;                              <span class="comment">//类信息，运行时使用个位标识，如普通类、元类</span></span><br><span class="line">    <span class="type">long</span> instance_size;                     <span class="comment">//类的实例变量大小（包含继承自父类的实例变量）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> *ivars;           <span class="comment">//类的成员变量地址列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_method_list</span> **methodLists;  <span class="comment">//类的方法地址列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_cache</span> *cache;               <span class="comment">//缓存的方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_protocol_list</span> *protocols;   <span class="comment">//遵循的协议列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>id</code>是一种特殊的类型，它能指代任意的 Objective-C 对象类型。对象是由<code>objc_object</code>结构体来定义的。其中包含一个<code>Class</code>类型的变量<code>isa</code>，<code>Class</code>是一个指向<code>objc_class</code>结构体的指针，在这个结构体中存放着类的“元数据”。</p>
<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>然而在处理器从32位迁移到64位后，对象指针扩大为64位的整数，为了使地址内存对齐，一些位将永远是零。出于节省内存和提高运行效率的目的，苹果爸爸在<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC 2013 Session 404</a>中提出了 Tagged Pointer 的概念，因此也修改了<code>objc_object</code>的定义。</p>
<p><img src="/images/TaggedPointer.png" alt="Tagged Pointer"></p>
<p><img src="/images/TaggedPointer2.png" alt="Tagged Pointer2"></p>
<p>当对象指针的最低有效位（LSB）为 1 时，则该指针为 Tagged Pointer。其实这个指针的值本质上已经不是指向对象的地址了，而是保存着对象数据的值类型的变量。所以它的内存并不存储在堆中，也不需要 malloc&#x2F;free。</p>
<p>我们再看一下<code>objc_object</code>的定义的变化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;    <span class="comment">//非 tagged pointer 对象获取其 Class 的函数</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>; <span class="comment">//tagged pointer 对象获取其 Class 的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=false*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initClassIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initProtocolIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initInstanceIsa</span><span class="params">(Class cls, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">changeIsa</span><span class="params">(Class newCls)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">//这里只提取了__x86_64__架构的结构体定义，其他如__arm64__等架构类似。</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>; <span class="comment">//标志位：0表示原生指针，1表示使用 taggedPointer 优化内存</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>; <span class="comment">//是否绑定过关联对象，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>; <span class="comment">//是否有析构函数，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">44</span>;<span class="comment">//所属类指针的非零位</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>; <span class="comment">//固定值0xd2，调试器用来分辨对象的</span></span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>; <span class="comment">//是否被 __weak 变量引用过，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>; <span class="comment">//是否正在释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">//引用计数值是否过大</span></span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">8</span>; <span class="comment">//对象的引用计数值-1（若值为5，则对象引用计数为6）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::initIsa</span><span class="params">(Class cls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isTaggedPointer</span>()); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!DisableNonpointerIsa);</span><br><span class="line">        <span class="built_in">assert</span>(!cls-&gt;<span class="built_in">instancesRequireRawIsa</span>());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">isa_t</span> <span class="title">newisa</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//这里截取SUPPORT_INDEXED_ISA = 0 时的代码，查知只有在watchABI的环境下SUPPORT_INDEXED_ISA值才为1</span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (<span class="type">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isa</code>变量的类型由<code>Class</code>类型变为了<code>isa_t</code>的类型，这个类型是一个联合（<code>union</code>），在联合中，几个字段共用同一块内存，其长度为联合中最大字段的长度。在<code>initIsa</code>方法中，当不启用 Tagged Pointer 时，就直接使用类的指针为<code>isa.cls</code>赋值，它还是表示对象所属类的指针。当启用时，使用宏<code>ISA_MAGIC_VALUE</code>来初始化<code>isa.bits</code>,这样已经为结构体内的<code>magic</code>、<code>nonpointer</code>字段赋值了，然后根据函数参数设置<code>has_cxx_dtor</code>，将类的指针右移 3 位以消除用于内存对齐所补的 0，使用非 0 位来为<code>shiftcls</code>字段赋值。</p>
<h1 id="类与元类"><a href="#类与元类" class="headerlink" title="类与元类"></a>类与元类</h1><p>无论是否启用 Tagged Pointer，<code>isa</code>变量中都保存了对象所属类的信息。接下来我们看一下定义类的结构体<code>objc_class</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// 缓存指针和 vtable，加速方法调用</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t类型的结构体指针加 retain/release/alloc/dealloc 路径优化的标记位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code>是继承自<code>objc_object</code>的，因此类本质上也是对象，称为类对象。类对象中包含继承来的<code>isa</code>变量，与实例对象中<code>isa</code>变量“指向”对象的所属类类似（这里的指向指的是变量中保存了对象所属类的信息，可以通过此信息找到类，下文中均如此表述），类对象的<code>isa</code>指向该类的元类（metaclass）。这一点可以从创建类与元类的函数<code>objc_allocateClassPair</code>中看出：</p>
<h2 id="动态创建类与元类"><a href="#动态创建类与元类" class="headerlink" title="动态创建类与元类"></a>动态创建类与元类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="type">const</span> <span class="type">char</span> *name, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls, meta;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="type">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="comment">//检查类名是否已经存在，验证父类是否合格（已实现的构建完成的类或者创建根类时可为空）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getClass</span>(name)  ||  !<span class="built_in">verifySuperclass</span>(superclass, <span class="literal">true</span><span class="comment">/*rootOK*/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为类与元类开辟空间</span></span><br><span class="line">    cls  = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">    meta = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">    <span class="comment">//初始化类与元类</span></span><br><span class="line">    <span class="built_in">objc_initializeClassPair_internal</span>(superclass, name, cls, meta);</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本来不想贴这长串代码，但是细读对理解类的创建过程的有所理解</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">objc_initializeClassPair_internal</span><span class="params">(Class superclass, <span class="type">const</span> <span class="type">char</span> *name, Class cls, Class meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertWriting</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">class_ro_t</span> *cls_ro_w, *meta_ro_w;</span><br><span class="line">    <span class="comment">//分配class_rw_t和class_ro_t结构体空间</span></span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>((<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>));</span><br><span class="line">    meta-&gt;<span class="built_in">setData</span>((<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>));</span><br><span class="line">    cls_ro_w   = (<span class="type">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    meta_ro_w  = (<span class="type">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;ro = cls_ro_w;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;ro = meta_ro_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置class_rw_t结构体内基本信息</span></span><br><span class="line">    <span class="comment">//类已分配但未注册|class_rw_t-&gt;ro是class_ro_t在堆中的拷贝|class_t-&gt;data是class_rw_t不是class_ro_t|类已开始实现但未完成</span></span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;version = <span class="number">0</span>;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;version = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置cls_ro_t结构体内基本信息</span></span><br><span class="line">    cls_ro_w-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    meta_ro_w-&gt;flags = RO_META;<span class="comment">//元类</span></span><br><span class="line">    <span class="keyword">if</span> (!superclass) &#123;</span><br><span class="line">        cls_ro_w-&gt;flags |= RO_ROOT;<span class="comment">//根类</span></span><br><span class="line">        meta_ro_w-&gt;flags |= RO_ROOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (superclass) &#123;</span><br><span class="line">        <span class="comment">//设置cls_ro_t-&gt;instanceStart和cls_ro_t-&gt;instanceSize为父类的instanceSize</span></span><br><span class="line">        cls_ro_w-&gt;instanceStart = superclass-&gt;<span class="built_in">unalignedInstanceSize</span>();</span><br><span class="line">        meta_ro_w-&gt;instanceStart = superclass-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">unalignedInstanceSize</span>();</span><br><span class="line">        cls-&gt;<span class="built_in">setInstanceSize</span>(cls_ro_w-&gt;instanceStart);</span><br><span class="line">        meta-&gt;<span class="built_in">setInstanceSize</span>(meta_ro_w-&gt;instanceStart);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cls_ro_w-&gt;instanceStart = <span class="number">0</span>;</span><br><span class="line">        meta_ro_w-&gt;instanceStart = (<span class="type">uint32_t</span>)<span class="built_in">sizeof</span>(objc_class);</span><br><span class="line">        cls-&gt;<span class="built_in">setInstanceSize</span>((<span class="type">uint32_t</span>)<span class="built_in">sizeof</span>(id));  <span class="comment">// just an isa</span></span><br><span class="line">        meta-&gt;<span class="built_in">setInstanceSize</span>(meta_ro_w-&gt;instanceStart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置类名与元类名</span></span><br><span class="line">    cls_ro_w-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    meta_ro_w-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">//初始化储存属性内存管理特性的值</span></span><br><span class="line">    cls_ro_w-&gt;ivarLayout = &amp;UnsetLayout;<span class="comment">//记录__strong的实例变量</span></span><br><span class="line">    cls_ro_w-&gt;weakIvarLayout = &amp;UnsetLayout;<span class="comment">//记录__weak的实例变量</span></span><br><span class="line">    <span class="comment">//设置元类与类的索引</span></span><br><span class="line">    meta-&gt;<span class="built_in">chooseClassArrayIndex</span>();<span class="comment">//此处函数中逻辑只在 SUPPORT_INDEXED_ISA = 1 时编译</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别为类与元类添加它们与父类和元类的联系</span></span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(meta);</span><br><span class="line">    <span class="keyword">if</span> (superclass) &#123;</span><br><span class="line">        meta-&gt;<span class="built_in">initClassIsa</span>(superclass-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        cls-&gt;superclass = superclass;</span><br><span class="line">        meta-&gt;superclass = superclass-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">        <span class="built_in">addSubclass</span>(superclass, cls);</span><br><span class="line">        <span class="built_in">addSubclass</span>(superclass-&gt;<span class="built_in">ISA</span>(), meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有父类，则该类为根类</span></span><br><span class="line">        meta-&gt;<span class="built_in">initClassIsa</span>(meta);<span class="comment">//根类的元类指向元类本身</span></span><br><span class="line">        cls-&gt;superclass = Nil;<span class="comment">//根类的父类为 Nil</span></span><br><span class="line">        meta-&gt;superclass = cls;<span class="comment">//根类的元类的父类指向根类</span></span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);</span><br><span class="line">        <span class="built_in">addSubclass</span>(cls, meta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化方法缓存列表为空</span></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmpty</span>();</span><br><span class="line">    meta-&gt;cache.<span class="built_in">initializeToEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>cls-&gt;initClassIsa(meta);</code>可以看出类对象<code>cls</code>确实使用元类对象<code>meta</code>初始化了它的<code>isa</code>变量。接下来的代码在该类有没有父类的情况下分别建立起了类与元类与他们各自父类与元类的联系。<code>superclass</code>指针确立了继承关系，<code>isa</code>描述了实例所属的类，通过这些联系建立起来了<strong>”类的继承体系”</strong>，如下图所示,通过这张布局关系图，我们可以查出对象能否响应某个选择子，是否遵从某项协议等，并且能够通过<code>isMemberOfClass</code>和<code>isKindOfClass</code>等类型信息查询方法来检视类的继承体系。</p>
<p><img src="/images/objc-isa-class-diagram.png" alt="objc-isa-class-diagram"></p>
<p>需要注意以下两点:</p>
<ol>
<li>所有的 metaclass 的<code>isa</code>都指向根类的元类，包括根元类！这样就形成了一个闭环。当向对象（类对象&#x2F;元类对象）发送消息时，runtime 会在对象所属的类的方法列表里面查找消息对应的方法，这样的闭环会保证这一步执行正确。</li>
<li>元类的父类指向类的父类的元类（绕口令啊(ノ ﾟДﾟ)ノ　┻━━┻），例外的是根类，根类的 <code>superclass</code>为 nil，根类的元类的<code>superclass</code>指向根类。当在对象所属类的方法列表中没有找到对应的方法时，runtime 会去类的父类中查找，如果找到了就跳转到方法的实现代码中，如果一路向上找到根类也没有找到时，runtime 的”消息传递机制”就结束了。接下来会启动“消息转发机制”，详情可查看这里：<a target="_blank" rel="noopener" href="https://176zane.github.io/2017/11/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Objective-C%20Runtime%20Programming%20Guide/">【翻译】Objective-C Runtime Programming Guide</a></li>
</ol>
<p>我们说类对象结构体<code>objc_class</code>中存放着类的“元数据”，例如类的实例实现了哪些方法，具备多少个实例变量及其布局等信息，而元类中保存了类对象本身所具备的元数据，“类方法”就定义在这里，因为这些方法可以理解成类对象的实例方法。<code>objc_class</code>结构体中的<code>isa</code>和<code>superclass</code>变量构建起了类的继承体系，接下来我们看看剩下的部分。</p>
<h2 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h2><p><code>objc_class</code>结构体中的<code>cache</code>字段主要用于缓存调用过的方法。当对象接收到消息时，runtime 根据<code>isa</code>去对象所属类的方法列表中查找，如果每次都经过这样的流程，方法调用的效率会比较差，因此在第一次调用过一个方法后，这个方法就会被缓存在<code>cache</code>中，下次接收到消息时会先在这里查找，没有才去方法列表中查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;  <span class="comment">//一个用于存储缓存方法的散列表</span></span><br><span class="line">    <span class="type">mask_t</span> _mask;               <span class="comment">//_mask+1 = 目前分配的用来缓存方法的 bucket 的总数</span></span><br><span class="line">    <span class="type">mask_t</span> _occupied;           <span class="comment">//目前实际占用的 bucket 数量</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">cache_key_t</span> _key;           <span class="comment">//方法选择子对应的 key</span></span><br><span class="line">    IMP _imp;                   <span class="comment">//方法实现的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h2><p><code>objc_class</code>结构体中的<code>bits</code>字段的注释为：”class_rw_t * plus custom rr&#x2F;alloc flags”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getBit</span><span class="params">(<span class="type">uintptr_t</span> bit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBit</span>(FAST_HAS_CXX_CTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个结构体中只有一个 64 位的值<code>bits</code>，该数据中保存了一个指向<code>class_rw_t</code>结构体的指针和是否为 swift 类、是否有默认的<code>retain/release</code>等方法及是否要求 raw isa 三个标志位。结构体中还提供了使用掩码来访问这些数据的方法（甚至还提供一些对<code>class_rw_t</code>结构体中<code>flags</code>字段的访问函数）。引用<a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a>文章中的配图可以看得更明白一些：<br><img src="/images/class_data_bits_t.png" alt="class_data_bits_t"></p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_data_bits_t</code>结构体中的<code>data()</code>方法返回了指向<code>class_rw_t</code>结构体的指针，这个结构体中保存了类的方法、属性和协议等信息。先看一下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">//标记信息</span></span><br><span class="line">    <span class="type">uint32_t</span> version;               <span class="comment">//类的版本信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;           <span class="comment">//编译期就确定的类信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;         <span class="comment">//方法列表</span></span><br><span class="line">    <span class="type">property_array_t</span> properties;    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;     <span class="comment">//协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;            <span class="comment">//首个子类</span></span><br><span class="line">    Class nextSiblingClass;         <span class="comment">//下一个兄弟类</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *demangledName;            <span class="comment">//取消名字修饰后的类名</span></span><br><span class="line">    <span class="comment">//省略 SUPPORT_INDEXED_ISA = 1 时的 index 字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code>中还包含一个与它类似的结构体<code>class_ro_t</code>的常量指针。从命名我们可以猜出<code>class_ro_t</code>中存储的是只读的信息，而<code>class_rw_t</code>中存储了可读写的信息。实际上也是如此，在<code>class_ro_t</code>中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议等信息，<code>class_rw_t</code>存储的内容是可以动态修改的，所以运行时对类的扩展大都存储在这里。先看下<code>class_ro_t</code>的定义：</p>
<h4 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;                     <span class="comment">//标记信息</span></span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;             <span class="comment">//类自己定义的实例变量的起始偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;              <span class="comment">//类的总的实例变量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;                  <span class="comment">//保留的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;         <span class="comment">//__strong修饰的实例变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;                  <span class="comment">//类名</span></span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;     <span class="comment">//方法列表</span></span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;    <span class="comment">//协议列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;          <span class="comment">//实例变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;     <span class="comment">//__weak修饰的实例变量</span></span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;    <span class="comment">//属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的“创建新的类与元类”部分，我们看到在初始化类与元类的函数<code>objc_initializeClassPair_internal</code>中，开辟了<code>class_rw_t</code>和<code>class_ro_t</code>的存储空间，并将返回的指针保存在相应的数据中。接着对<code>class_rw_t</code>中的<code>flags</code>,<code>version</code>,<code>ro</code>字段进行了初始化，在<code>addSubclass(superclass, cls)</code>方法中又设置了自身的<code>nextSiblingClass</code>以及父类的<code>firstSubclass</code>。同时初始化了<code>class_ro_t</code>中的<code>flags</code>,<code>instanceStart</code>,<code>instanceSize</code>,<code>ivarLayout</code>,<code>weakIvarLayout</code>,<code>name</code>等字段（注意当存在父类时，本类的<code>instanceStart</code>与<code>instanceSize</code>都使用父类的<code>instanceSize</code>进行了初始化）。</p>
<p>我们上面不是说过<code>class_ro_t</code>结构体中的值是只读的嘛？为什么在这里对其中的变量进行了设置？而且如果你阅读过<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc">Objective-C Runtime函数列表</a>，就会发现<code>class_addIvar</code>这个函数也是在运行时通过修改类的<code>class_ro_t</code>中的字段，向类中添加了实例变量。</p>
<p>这是因为这些操作都是发生在动态构建类的过程中！<code>class_addIvar</code>的文档中有这么一段话：</p>
<blockquote>
<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.</p>
</blockquote>
<p>也就是说一旦完成类的构建过程，就不能再修改<code>class_ro_t</code>中的内容了，当然也就不能向其中添加实例变量了。<code>objc_registerClassPair</code>中做的事情就是将类的<code>class_rw_t</code>中的<code>flags</code>标记的<code>RW_CONSTRUCTING | RW_REALIZING</code>标志位清除，同时设置<code>RW_CONSTRUCTED</code>这个表示类已经构建完成的标志位。</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>在上面一部分，我们通过阅读创建类与元类的函数<code>objc_allocateClassPair</code>对动态创建类的过程有了一定的理解，并且认识了表示类的结构体及其初始化的过程。但是对于我们在源代码中编写的类，它的加载过程是怎样的呢？</p>
<p>我们编写的源代码在编译结束后链接的过程中就静态链接进程序的二进制文件中了，而程序中引入的系统库如”Foundation.framework”和包含 Runtime 的”libobjc.A.dylib”等则是通过苹果的动态链接器-dyld（the dynamic link editor）在程序启动时动态加载的。我们看一下 Runtime 的初始化入口方法<code>_objc_init</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();</span><br><span class="line">    <span class="built_in">tls_init</span>();</span><br><span class="line">    <span class="built_in">static_init</span>();</span><br><span class="line">    <span class="built_in">lock_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>();</span><br><span class="line">    <span class="comment">//注册dyld事件的回调函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数的最后注册了 dyld 相关事件的回调函数，当 ImageLoader 读取了 images(可执行文件或动态库等）并将其加载进内存后，dyld 会调用回调函数<code>map_images</code>对其进行解析和处理。接下来当需要对该 image 进行初始化时，dyld 就会调用回调函数<code>load_images</code>对其初始化。</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><p><code>map_images</code>中提取了 images 中 ObjC 相关的元数据（Class、Selector、Protocol等符号）进行了初始化，主要过程发生在<code>_read_images</code>函数中：</p>
<ol>
<li><p>针对包含有 swift 旧版本代码和对 sdk 版本在 OS X 10.11之前的进行<code>disableTaggedPointers</code>操作。</p>
</li>
<li><p>初始化一个全局的映射表<code>gdb_objc_realized_classes</code>用来存储没有在 dyld 共享缓存中优化过的 Classes，注意这个名字中的 realized 属于误用，其中存放的类也可以是未实现的状态。</p>
</li>
<li><p><code>readClass</code> : 将类与元类照编译器编译好的方式从二进制中读出来，然后将不重复的非元类插入到<code>gdb_objc_realized_classes</code>中，该函数的返回值有3中情况：</p>
<ul>
<li>cls:即类的指针，注意如果该类之前被 alloc 为未来实现的类则需要拷贝一个新类并将<code>rw</code>的类型<code>class_rw_t</code>强制转换为<code>class_ro_t</code>为<code>rw-&gt;ro</code> 赋值，设置新的<code>rw</code>并将其添加进 <code>remappedClasses</code>，注意这里的<code>newCls</code>就已经是<code>realized</code>的状态了。代码如下：</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line"><span class="built_in">memcpy</span>(newCls, cls, <span class="built_in">sizeof</span>(objc_class));</span><br><span class="line">rw-&gt;ro = (<span class="type">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line"><span class="built_in">freeIfMutable</span>((<span class="type">char</span> *)old_ro-&gt;name);</span><br><span class="line"><span class="built_in">free</span>((<span class="type">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line"><span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">replacing = cls;</span><br><span class="line">cls = newCls;</span><br></pre></td></tr></table></figure>
<ul>
<li>nil:当类没有父类或者当前父类是弱连接的，将这个类添加进需要重新映射的表后返回 nil.</li>
<li>something else: 指向保留的用于为未来实现的类开辟的空间.</li>
</ul>
</li>
<li><p>修正上一步中添加进<code>remappedClasses</code>的类，用已经实现的新类替换旧类的引用。</p>
</li>
<li><p>修正 selector 的引用。</p>
</li>
<li><p>读取 protocals 以及修正其引用。</p>
</li>
<li><p>对于实现了<code>+load</code>方法或者有静态实例的 non-lazy classes 执行<code>realizeClass</code>来实现它（注意对于 lazy classes 则是在其首次接收到消息时才实现它），返回类真实的数据结构使其处于可用的状态,关键代码如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 ro 替换为 rw，标记类为 已实现|实现中</span></span><br><span class="line">ro = (<span class="type">const</span> <span class="type">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">    <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">    rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    ro = cls-&gt;<span class="built_in">data</span>()-&gt;ro;</span><br><span class="line">    cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">    rw = (<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询是否为元类</span></span><br><span class="line">isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"><span class="comment">//设置version </span></span><br><span class="line">rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Choose an index for this class.</span></span><br><span class="line"><span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">cls-&gt;<span class="built_in">chooseClassArrayIndex</span>(); <span class="comment">//仅在watchABI下有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span></span><br><span class="line"><span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line"><span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line">supercls = <span class="built_in">realizeClass</span>(<span class="built_in">remapClass</span>(cls-&gt;superclass));</span><br><span class="line">metacls = <span class="built_in">realizeClass</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略SUPPORT_NONPOINTER_ISA时的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;superclass = supercls;</span><br><span class="line">cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line"><span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">    cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">    <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect this class to its superclass&#x27;s subclass lists</span></span><br><span class="line"><span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">    <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">addRootClass</span>(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach categories</span></span><br><span class="line"><span class="built_in">methodizeClass</span>(cls);</span><br><span class="line"><span class="keyword">return</span> cls;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在上面的<code>reconcileInstanceVariables</code>过程中，在<code>ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize</code>情况下即父类扩展了它的实例变量使得实例变量大小增大时，校准了<code>ro-&gt;instanceSize</code>，<code>ro-&gt;instanceStart</code>和<code>ivars</code>容器中每个<code>ivar-&gt;offset</code>指向的值以实现<code>non-fragile instance variables</code>的功能！</p>
<p> 在<code>methodizeClass</code>过程中将<code>ro-&gt;baseMethods()</code>,<code>ro-&gt;baseProperties</code>,<code>ro-&gt;baseProtocols</code>分别添加进<code>rw-&gt;methods</code>,<code>rw-&gt;properties</code>和<code>rw-&gt;protocols</code>容器列表中，然后将通过<code>unattachedCategoriesForClass</code>获取的未附加的分类附加在类上。</p>
</li>
<li><p>读取 Category ,然后通过<code>addUnattachedCategoryForClass</code>将分类注册到它的所属类上，之后调用<code>remethodizeClass</code>将实例方法、协议和属性添加到类上，将类方法添加到元类上。需要注意的是：1，Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个methodA；2，Category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会返回。</p>
</li>
</ol>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><p><code>load_images</code>方法就是调用<code>+load</code>方法，看一下<code>prepare_load_methods</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">classref_t</span> *classlist = </span><br><span class="line">    _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="type">category_t</span> *cat = categorylist[i];</span><br><span class="line">    Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">    <span class="built_in">realizeClass</span>(cls);</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数基本就是准备好实现了<code>+load</code>方法的类和分类，将其分别添加到 loadable_list 中。需要留意的是在<code>schedule_class_load</code>方法中会递归调用<code>schedule_class_load(cls-&gt;superclass)</code>,来保证先将父类添加进 loadable_list 中。</p>
<p>准备好后就调用了<code>call_load_methods</code>，关键代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">call_class_loads</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">&#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>类的<code>+load</code>方法是先于分类调用的！但是在类的<code>+load</code>方法中可以调用该类的分类中声明的方法，因为在此之前分类就已经 attach 到这个类上面了。</li>
<li><code>call_class_loads</code>从 loadable_list 中依次取出 class 然后调用<code>+load</code>，这里保证了父类优先调用的顺序！</li>
<li><code>+load</code>方法是直接使用函数内存地址的方式调用的：<code>(*load_method)(cls, SEL_load)</code>，它对于实现了<code>+load</code>方法的添加进 loadable_list 中的每个类与分类都会调用。因此这里成了极佳的<a target="_blank" rel="noopener" href="http://nshipster.cn/method-swizzling/">Method Swizzling</a>的时机。但是分类之间的<code>+load</code>执行顺序是按照编译顺序决定的，因此不同的编译顺序会导致分类间的<code>+load</code>顺序不固定。类的载入顺序不同也导致类之间<code>+load</code>方法执行顺序不固定。</li>
<li>如果代码还依赖了其他程序库，那么其他程序库里面的相关类的<code>+load</code>方法会先执行。</li>
<li>留意与<code>+load</code>类似的<code>+initialize</code>方法，可以执行类的初始化操作，不同的是调用这个方法时，运行时系统已经处于正常状态了，在这里可以调用任意类的任意方法。<code>+initialize</code>方法是惰性调用的，在程序首次使用类的时候才会调用一次它，这个方法是线程安全的，执行时会堵塞其他线程。还有与<code>+load</code>不同，<code>+initialize</code>遵循普通的继承与覆写规则，当类没有实现这个方法时，会调用其父类的实现。</li>
</ul>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>接下来简单看下对象的创建过程,我们通过调用<code>[[XXXClass alloc] init]</code>来生成一个实例对象。</p>
<h2 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h2><p>在代码<code>[[NSObject alloc] init]</code>中添加一个断点，查看一下调用栈：<br><img src="/images/alloc.png" alt="alloc"></p>
<p>初始化对象的关键代码都在<code>_class_createInstanceFromZone</code>方法中,抽取出一个主要流程的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//获取实例对象内存对齐后的大小</span></span><br><span class="line">    <span class="type">size_t</span> size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br><span class="line">    <span class="comment">//分配存储空间</span></span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="comment">//初始化isa,这部分代码我们再文章上面可以看到</span></span><br><span class="line">    obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>init</code>操作只是简单的返回了对象背身。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>看完了这些我们也能回答引言中提出的问题了：Objective-C对象不能简单对应于一个C struct，访问成员变量不等于访问C struct成员,当生成对象时，开辟出来对象的<code>instanceSize</code>大小的内存区域并返回指向该空间的指针，在这个内存空间中不仅包含了<code>objc_object</code>中定义的<code>isa</code>还有其他所有的实例变量（包括继承自父类的及其自己的），我们通常所说的类的实例对象也就指的是这块内存空间。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html">[objc explain]: Non-pointer isa</a></li>
<li><a target="_blank" rel="noopener" href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">[objc explain]: Classes and metaclasses</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></li>
<li><a target="_blank" rel="noopener" href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md">从 NSObject 的初始化了解 isa</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/06/05/AV%20Foundation%E7%AC%94%E8%AE%B0-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/AV%20Foundation%E7%AC%94%E8%AE%B0-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">AV Foundation笔记-音视频基础入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 09:12:13" itemprop="dateCreated datePublished" datetime="2022-06-05T09:12:13+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:41:08" itemprop="dateModified" datetime="2023-09-15T14:41:08+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们所看见的和听见的都是通过眼睛和耳朵的构造将这些信息转化为大脑能够解析的电信号，通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%93%AC%E4%BF%A1%E8%99%9F">模拟信号</a>传递给我们的。模拟信号利用对象的一些物理属性来表达、传递信息，例如声音、光、温度、位移、压强，这些物理量可以使用传感器测量。模拟信号中，不同的时间点位置的信号值是连续变化的。而数字世界中的信号是离散的，由 1 和 0 两个状态表示，要将模拟信号转换成能够在计算机中存储并传输的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a>，需要经过模拟-数字转换过程，这个过程称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%96%E6%A8%A3">采样</a>。</p>
<h1 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h1><p>通常采样与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%8C%96_(%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86)">量化</a>联合进行，例如对于音频信号来说，模拟信号先由采样器按照一定时间间隔采样获得时间上离散的信号，再经模数转换器在数值上也进行离散化，从而得到数值和时间上都离散的数字信号。大多情况下所说的“采样”就是指这种采样与量化结合的过程。</p>
<h2 id="音频采样"><a href="#音频采样" class="headerlink" title="音频采样"></a>音频采样</h2><p>我们一般使用麦克风来记录声音，它可以将机械能量转换成电能量。当我们发出声音时，会带动周围的空气产生特定频率和振幅的震动，这样麦克风中那层薄薄的膜片也会根据其感受到的声波进行震动，带动线圈震动，由此产生与输入信号相同频率和振幅的电流信号，这个信号中的频率与振幅分别代表了声音的音调与音量（对于复杂波形来说，音调对应的是波的基频）。<br><img src="/images/%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7.png" alt="声音信号"></p>
<p>麦克风所产生的电压信号类似于上图中的波形，这种模拟信号可以在磁带上记录成磁场强度的变化或在黑胶唱片上记录成沟槽大小的变化。但是当存储介质为计算机时，一般会通过线性脉冲编码调试（即Linear PCM）的过程将其数字化。这个过程会间隔固定的时间对信号进行测量，然后用独特的数字记号（通常为二进制）来量化。其中涉及两个重要的参数：</p>
<ul>
<li><p>采样率：采样率表示音频信号每秒的取样数，它决定了音频文件的频率范围。从下图可以看出采样率越高，数字波形的形状越接近原始模拟波形。根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86">采样定理</a>当采样率达到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9%E9%A2%91%E7%8E%87">奈奎斯特频率</a>，即频率达到所需要采样对象的最高频率的两倍时可以产生足够好的数字化效果。人类的听觉可以接收的音频范围为 20HZ~20kHZ，所以使用CD录制的音频采样率通常为 44.1kHZ，其所能捕捉的最大频率为20.05kHZ，对于人耳来说已经足够好了。<br><img src="/images/%E9%87%87%E6%A0%B7%E7%8E%87.png" alt="采样率"></p>
</li>
<li><p>位元深度：位元深度是用于保存样本值的字节数，它定义了在线性维度上可行的离散度，决定了我们所能捕捉的音频样本的精度。为每个样本的整理量化分配过少的位结果信息会导致数字音频信号产生噪声和扭曲。使用位元深度为 8 的方法可以提供 256 个离散级别的数据，对于一般音频也可使用。CD音质的位元深度为 16，更专业级别的音频录制环境的位元深度可能达到24或更高。</p>
</li>
</ul>
<h2 id="图像采样"><a href="#图像采样" class="headerlink" title="图像采样"></a>图像采样</h2><p>对于图像，我们一般使用扫描或者拍照技术对其信息进行采集。在数字化过程中，与音频基于时间的采样不同，图像是基于空间采样的（对于视频这种既有空间属性也有时间属性的信号，这两种方式都会使用）。空间采样包含对一副图片在一定分辨率下捕捉其亮度和色度，进而创建由该图片的像素点数据所构成的数字化结果。</p>
<p>在采样时，将二维空间中连续的图片在水平和垂直方向上等距的分割为矩形网状结构，形成一个个微小的方格称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0">像素</a>。像素没有固定的尺寸大小，它只是对一个最小完整采样的抽象。这样一副图片就被采样成有限个像素点构成的集合。然后通过量化将各像素的灰度值从模拟量转化为离散量。其中有如下主要参数：</p>
<ul>
<li><p>采样点数：对一幅图像采样时，若每行像素为M个，每列像素为N个，则图像尺寸为M *  N个像素。像素数量对图片质量有显著影响。一般来说图像采样点数越多，图像质量越好，但数据量越大。例如下图为采样点数从 256  * 256 逐步减少到到 8 * 8 对图像质量的影响。<br><img src="/images/%E5%83%8F%E7%B4%A0%E7%82%B9%E6%95%B0.png" alt="像素点数"></p>
</li>
<li><p>量化级数：对于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F">灰度图像</a>我们需要将各像素的灰度值量化，一般使用 8 位 256 个量化级数来表示 0~255 的灰度值。量化级数越多，图像质量越好。下图表示采样点数一定时，量化级数从 256 递减至 2 时对图像质量的影响。<br><img src="/images/%E7%81%B0%E5%BA%A6.png" alt="灰度"></p>
</li>
</ul>
<p>对于彩色图像，基于RGB<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93">色彩模型</a>按照颜色成分——红（R）、绿（G）、蓝（B）分别采样和量化的。若各种颜色成分均按 8 位量化，即每种颜色量级别是 256，可以处理256×256×256&#x3D;16777216 种颜色。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://objccn.io/issue-21-1/">相机工作原理</a>。</p>
</blockquote>
<h1 id="编码压缩"><a href="#编码压缩" class="headerlink" title="编码压缩"></a>编码压缩</h1><p>对于音视频数字信号，如果不加压缩的存储和传输虽然能够保留原始的呈现效果，但是会占用大量的存储空间与带宽。例如对于一个双声道，44.1kHz，16位LPCM音频文件的码率为：2 * 44.1kHz * 16bit&#x3D;1.346Mbit&#x2F;s，也就是每分钟要占用 10MB的空间。对于一个帧率为 30FPS，1280 * 720分辨率的每个像素采用 24 位的RGB色彩空间的视频文件其码率为：30 * 1280 * 720 * 24bit &#x3D; 634Mbit&#x2F;s,也就是每分钟要占用 4.6GB的空间。这样的码率显然在当前（虽然现在都8102年了）的设备存储及网络传输中显得难以接受，因此我们需要对这些音视频文件进行编码压缩。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/28114081">频压缩编码和音频压缩编码的基本原理</a>。 注：本文中音视频编码原理部分内容摘录自该博客。</p>
</blockquote>
<h2 id="音频编解码"><a href="#音频编解码" class="headerlink" title="音频编解码"></a>音频编解码</h2><p>音频编码主要是将音频采样数据（如PCM数据）中声音信号的冗余成分去除压缩为音频码流，从而降低音频的数据量的过程。</p>
<h3 id="音频编码基本原理"><a href="#音频编码基本原理" class="headerlink" title="音频编码基本原理"></a>音频编码基本原理</h3><p>所谓冗余成分是指音频中不能被人耳感知到的信号，它们对确定声音的音调等信息没有任何的帮助。冗余信号包含人耳听觉范围外的音频信号（即频率在20Hz~20KHz之外的部分）以及被掩蔽掉的音频信号。根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应。主要表现在频谱掩蔽效应和时域掩蔽效应：</p>
<h4 id="频谱掩蔽效应"><a href="#频谱掩蔽效应" class="headerlink" title="频谱掩蔽效应"></a>频谱掩蔽效应</h4><p>一个频率的声音能量小于某个阈值之后，人耳就会听不到，这个阈值称为最小可闻阈。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如图所示</p>
<p><img src="/images/%E9%A2%91%E5%9F%9F%E6%8E%A9%E8%94%BD%E6%95%88%E5%BA%94.jpeg" alt="频域掩蔽效应"><br>我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝。当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。</p>
<h4 id="时域掩蔽效应"><a href="#时域掩蔽效应" class="headerlink" title="时域掩蔽效应"></a>时域掩蔽效应</h4><p>当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。</p>
<p><img src="/images/%E6%97%B6%E5%9F%9F%E6%8E%A9%E8%94%BD%E6%95%88%E5%BA%94.jpeg" alt="时域掩蔽效应"></p>
<p>前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。</p>
<h3 id="主要音频编解码方案"><a href="#主要音频编解码方案" class="headerlink" title="主要音频编解码方案"></a>主要音频编解码方案</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/WAV">WAV</a>:WAV 编码的一种实现是在 PCM 数据格式的前面加上 44 字节，分别用来描述 PCM 的采样率，声道数及数据格式等信息，WAV 文件与无损文件是不同的，它只不过是不去对原始文件做压缩。音质很好，大量软件及平台都支持。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows_Media_Audio">WMA</a>:微软推出的数字音频编码方案，一般情况下会比同样音质的MP3文件体积小。与MP3一样，需要购买版权支持。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MP3">MP3</a>:当前较为流行的一种有损压缩的数字音频编码方案之一。iOS的AVFoundation框架只提供对MP3数据的解码，并不支持对其编码。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC">AAC</a>:与H.264标准对应的音频编码方案，相比MP3格式有显著的提升，且没有专利问题，也是一种有损压缩方案。AAC是iPhone等多种设备的默认音频编码格式。它的扩展名主要有：.aac，.mp4，m4a。</li>
</ul>
<p>当然还有许多其他音频编解码方案，但是对于iOS开发学习过程来说，主要针对AAC编码方案即可。</p>
<h2 id="视频编解码"><a href="#视频编解码" class="headerlink" title="视频编解码"></a>视频编解码</h2><p>视频编码主要是将视频像素数据（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/YUV">YUV</a>数据）压缩为视频码流，降低视频数据量的过程。等等，YUV是什么鬼？我们像素数据采集的时候不是RGB数据么？其实在我们平时拍照或者拍视频的时候会经历一个色彩二次抽样的过程，将数据转换为YVU颜色模式的数据。在下面的相机拍照的工作流程图中也可以看到这个步骤：</p>
<p><img src="/images/IMG_8077.jpg" alt="IMG_8077"></p>
<h3 id="色彩二次抽样"><a href="#色彩二次抽样" class="headerlink" title="色彩二次抽样"></a>色彩二次抽样</h3><p>由于人类的视觉系统对颜色的位置及移动不及对亮度敏感，所以可以使用较多的亮度细节、较少的色度细节作优化，而不至于图片的质量受损严重。分别用一个亮度分量（Y’）及两个不同颜色分量（色度UV，分别用Cb和Cr来表示蓝色和红色的浓度偏移量）来替换原来的RGB数据从而减少颜色数据的过程就叫色彩二次抽样。</p>
<p><img src="/images/Barn-yuv.png" alt="Barn-yuv"></p>
<p>这张维基百科上的彩色图片可以让你对一张图片的 Y’及U、V组成部分有一个直观的认识。为节省带宽，大多数YUV格式平均使用的每像素位数都少于24位。其成分按照 J:a:b 的格式来取值：</p>
<ul>
<li>J：水平抽样参照（概念上区域的宽度）。通常为4。</li>
<li>a：在J个像素第一行中的色度抽样数目（Cr, Cb）。</li>
<li>b：在J个像素第二行中的额外色度抽样数目（Cr, Cb）</li>
</ul>
<p>其中主要的格式有4:2:0，4:2:2，4:4:4。在所有的格式下，每个像素的全部亮度信息都被保存下来了，在4:4:4时全部的色彩信息也被保存下来了，表示完全取样，数据量相比于RGB模型没有变化。4:2:2表示2:1的水平取样，垂直完全采样，数据量相比于RGB模式减少三分之一，4:2:0表示2:1的水平取样，垂直2：1采样。数据量相比于RGB模式减少二分之一。注意当前iPhone上的摄像头就是采用4:2:0的方式进行拍摄的。下图可以帮助理解这个二次抽样比例的模式：</p>
<p><img src="/images/Jab.png" alt="Jab"></p>
<h3 id="视频编码基本原理"><a href="#视频编码基本原理" class="headerlink" title="视频编码基本原理"></a>视频编码基本原理</h3><p>数据压缩是通过去除数据中的冗余信息而达成。就视频数据而言，数据中的冗余信息有如下几种：</p>
<ul>
<li>数据冗余:例如如空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性。消除这些冗余并不会导致信息损失，属于无损压缩。</li>
<li>视觉冗余:人眼的一些特性比如亮度辨别阈值，视觉阈值，对亮度和色度的敏感度不同，使得在编码的时候引入适量的误差，也不会被察觉出来。可以利用人眼的视觉特性，以一定的客观失真换取数据压缩。这种压缩属于有损压缩。</li>
</ul>
<p>一般的数字视频压缩编码方法都是混合编码，即将变换编码，运动估计和运动补偿，以及熵编码三种方式相结合来进行压缩编码。通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。</p>
<h4 id="变换编码"><a href="#变换编码" class="headerlink" title="变换编码"></a>变换编码</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%81">变换编码</a>的作用是将空间域描述的图像信号变换到频率域，然后对变换后的系数进行编码处理。一般来说，图像在空间上具有较强的相关性，变换到频率域可以实现去相关和能量集中。常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换，简称DCT变换。</p>
<p>变换编码一般用于帧内压缩，去除空间冗余信息和部分视觉冗余信息，所以一般是有损压缩算法，通常也用于JEPG静态图像压缩算法，但是通常是对原始图片的部分处理以生成极高质量的照片，通过这一步骤创建的帧称为 I-frames。</p>
<h4 id="运动估计和运动补偿"><a href="#运动估计和运动补偿" class="headerlink" title="运动估计和运动补偿"></a>运动估计和运动补偿</h4><p>这一步骤主要通过以组为单位的视频帧消除时间序列上的相关性来压缩冗余数据，是帧间压缩。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量。</p>
<p>运动估计一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280 * 720，首先将其以网格状的形式分成40 * 45个尺寸为16 * 16的彼此没有重叠的图像块，然后在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个运动矢量。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个残差图像块，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫运动补偿。</p>
<p><img src="/images/GOP.png" alt="GOP"></p>
<p>由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要，很多帧组合在一起作为一组图片（简称GOP），如下图所示。其中有三种不同类型的帧：</p>
<ul>
<li>I-frames:又称关键帧，只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。包含创建完整图片需要的所有数据，因此其尺寸是最大的，压缩比并不高，解压时间短。每个GOP正好有一个I-frames。</li>
<li>P-frames:又称预测帧，编码时使用一个前面的I-frames或P-frames作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。</li>
<li>B-frames:又称双向帧，编码过程中它要使用一个前面的I-frames或P-frames和一个后面的I-frames或P-frames进行预测。几乎不需要存储空间，但解压时间最长。</li>
</ul>
<h4 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%86%B5%E7%B7%A8%E7%A2%BC%E6%B3%95">熵编码</a>是一种独立于介质的具体特征的进行无损数据压缩的方案。其基本原理是对信源中出现概率大的符号赋予短码，对于出现概率小的符号赋予长码，从而在统计上获得较短的平均码长。可变字长编码通常有霍夫曼编码、算术编码、游程编码等。通过这种变长编码算法来进一步提高编码效率。</p>
<h3 id="主要视频编码方案"><a href="#主要视频编码方案" class="headerlink" title="主要视频编码方案"></a>主要视频编码方案</h3><p>视频编码有各种各样的方案标准，其实整体看起来还是比较混乱的，这里我们只举例几种稍作了解：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MPEG-2">MPEG-2</a>:是MPEG工作组于1994年发布的视频和音频压缩国际标准，通常用来为广播信号提供视频和音频编码，包括卫星电视、有线电视等。是采用以香农信息论为基础的预测编码、变换编码、熵编码及运动补偿等第一代数据压缩编码技术。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MPEG-4">MPEG-4</a>:一般特指MPEG-4第2部分，是基于第二代压缩编码技术制定的国际标准，它以视听媒体对象为基本单元，实现了从基于像素的传统编码向基于对象和内容的现代编码的转变，提高了压缩率。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a>又称为MPEG-4第10部分，是目前最主流的方案，充分利用了现有MPEG-4标准中的各个环节，即保留了以往压缩技术的优点和精华又具有其他压缩技术无法比拟的许多优点。是一种面向块，基于运动补偿的视频编码标准。可以提供更高的编码效率，更高清的视频画面质量，更好的网络适应能力。</li>
</ul>
<h1 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h1><p>我们平时在电脑中存储的或者网上下载的各种.mov、.avi、.mp4等等后缀名的文件，平时我们将这些类型视为文件格式，其实更准确的理解是这些类型是文件的封装格式。封装格式也是元文件格式，封装格式就是按照一定的规范结构将视频数据，音频数据等放在一起。所谓的结构不仅包含了媒体信息，如视频、音频、字幕、编码和时间信息等，还包含了描述性的元数据，比如电影标题、歌曲作者等。这些元数据可以通过工具进行呈现。</p>
<p>下面我们了解一下一些常用的封装格式：</p>
<ul>
<li>QuickTime:苹果公司开发的封装格式，它可存储的内容相当丰富，除了视频、音频以外还可支持图片、文字（文本字幕）等。文件后缀名为.mov、.qt。</li>
<li>AVI:微软公司开发的对抗苹果QuickTime格式的技术，AVI本身只提供了一个框架，内部的图像数据及声音数据可以支持任意的编码形式。AVI与其他格式最大的不同是它将索引放在文件尾部，所以不能支持流媒体播放。文件后缀名为.avi。</li>
<li>MP4:是MPEG-4第 14 部分规范定义的容器格式，是从QuickTime直接派生出来的行业标准格式，视频主要采用H.264编码格式，音频主要采用AAC编码格式，同时也支持老版本的MPEG编码标准。文件后缀名为.mp4,在苹果生态系统中，也常用.m4a的音频文件及.m4v的视频文件等格式区分基于MP4格式的特定媒体类型。</li>
<li>TS:TS封装支持几乎所有编码的高清视频和音轨文件。视频编码有MPEG2、MPEG4 AVC、VC1，音频则种类DD、TrueHD、DTS、DTSHD等。TS的全名是Transport Stream，在打包视频和音频时，能提供时间戳，在整个打包视频的任何时段开始播放，都能顺利解码并保持音画同步。文件后缀为.ts。</li>
<li>FLV：FLV流媒体格式是一种全新的视频格式，全称为Flash Video。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好地应用等缺点，因此FLV格式成为了当今主流视频格式。目前几乎所有全球热门的在线视频网站都采用了FLV视频格式。文件后缀为.flv。</li>
<li>MKV：MKV格式是民间流行的一种视频格式，以它兼容众多视频编码见长，可以是DivX、XviD、RealVideo、H264、MPEG2、VC1等等。但是由于是民间格式，没有版权限制，又易于播放，所以官方发布的视频影片都不采用mkv，网上制作下载常见。文件后缀为.mkv。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/12/iOS%20%E5%B8%B8%E8%AF%BB%E5%B8%B8%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/iOS%20%E5%B8%B8%E8%AF%BB%E5%B8%B8%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" class="post-title-link" itemprop="url">iOS 常读常新的文章索引（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 20:03:13" itemprop="dateCreated datePublished" datetime="2022-05-12T20:03:13+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 21:31:41" itemprop="dateModified" datetime="2023-09-13T21:31:41+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d5cf01424e92">点击 Run 之后发生了什么？</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/">优化 App 的启动时间</a><br><a target="_blank" rel="noopener" href="https://176zane.github.io/2023/04/05/iOS%20App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">iOS App启动过程</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/85331">02 | App 启动速度怎么做优化与监控？</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/231b1cebf477">iOS App从点击到启动</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7jNAl9WdZAOYvvkYllwHfQ">iOS 启动时间与Dyld3</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XVd9QNvXgJx_9K3XHAcaSA">云音乐 iOS 启动性能优化「开荒篇」</a><br><a target="_blank" rel="noopener" href="https://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/">如何对 iOS 启动阶段耗时进行分析</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24875905">dylib动态库加载过程分析</a></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/411/">Getting Started with Instruments</a><br><a target="_blank" rel="noopener" href="http://www.starming.com/2017/06/20/deeply-ios-performance-optimization/">深入剖析 iOS 性能优化</a><br><a target="_blank" rel="noopener" href="http://southpeak.github.io/2015/12/20/perfect-smooth-scrolling-in-uitableviews/">Perfect smooth scrolling in UITableViews</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/39sqUF-42JukRiKW4nITpg">iOS拾遗—— Assets Catalogs 与 I&#x2F;O 优化</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wTF3JSFH5b2zIUYAbnC-Bw">性能深度分析之System Trace</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TI1PHPAuCQwfvZk47L89lg">正经分析iOS包大小优化</a></p>
<h2 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h2><p><a target="_blank" rel="noopener" href="https://github.com/aozhimin/iOS-Monitor-Platform">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a><br><a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.74.md">带你打造一套 APM 监控系统</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nGLgQfq8k3pzxUaTZa8uNQ">iOS云音乐APM性能监控实践</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CiqMlEIp1Ir2EJSDGgMooQ">iOS微信内存监控</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/89845">14 | 临近 OOM，如何获取详细内存分配信息，分析内存问题？</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GEGO77XiTxU3bmxVHAA6VQ">你真的了解OOM吗？——京东iOS APP内存优化实录</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hA1j4Uh5-xJS2BNosfyyaQ">iOS 内存泄漏场景与解决方案</a></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thin-csapp-7/2016/04/16/">柒 虚拟内存与动态内存分配</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/98560">36 | iOS 是怎么管理内存的？</a></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/4927301586">YYCache 源码解析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/408d4d37bcbd">YYCache 源码剖析：一览亮点</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24685115">iOS当中的Cache设计</a></p>
<h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/414/">Understanding Crashes and Crash Logs</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903619330834446">WWDC 2018：理解崩溃以及崩溃日志</a></p>
<p><a target="_blank" rel="noopener" href="http://saitjr.com/ios/symbolicatecrash-1.html">Crash 符号化</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iRxvrOsEdW1wPZ3tSPKeIg">iOS 符号化：基础与进阶</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208483273&idx=1&sn=37ee88e06e7426f59f3074c536370317&scene=21">漫谈 iOS Crash 收集框架</a><br><a target="_blank" rel="noopener" href="http://wereadteam.github.io/2016/05/23/GYBootingProtection/">iOS 启动连续闪退保护方案</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33662572?utm_medium=social&utm_source=weibo&from=1081293010&wm=3333_2001&weiboauthoruid=1738301812">iOS KVO crash 自修复技术实现与原理解析</a></p>
<p><a target="_blank" rel="noopener" href="https://objccn.io/issue-19-2/">与调试器共舞 - LLDB 的华尔兹</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e89af3e9a8d7">小笨狼与LLDB的故事</a></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a602c580b6d">iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER (译)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/t_IBkCClPBZFBPmtZT0WsQ">iOS架构之View层的架构方案</a><br><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/architecture/mvx.md">浅谈 MVC、MVP 和 MVVM 架构模式</a></p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p><a target="_blank" rel="noopener" href="https://blog.cnbang.net/tech/3080/">iOS 组件化方案探索</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zvT7YbP-ex8TeeCYuEis5Q">iOS组件化方案</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&mid=2647761791&idx=1&sn=3e4a8592b1cd48e9e6fb11ce4c849c0c&chksm=8887d840bff0515654b687c5e66902c2b034fcefc986e6d8ebacd5ff287c78edea615a6145a5&scene=21#wechat_redirect">iOS 组件化 —— 路由设计思路分析</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ih_-Wl2Pk3uhxM-J2M5jLg">移动端组件化架构（上）</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wH9Zv_D3Oqm-yUL5HW_GmA">移动端组件化架构（下）</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38652748">美团外卖iOS多端复用的推动、支撑与思考</a></p>
<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/">Threading Programming Guide(2)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XbdezDo2xu-9SaSmid2pbw">解密 Runloop</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/r4R-Ilz3bOIBMvxzq_vmMA">iOS应用UI线程卡顿监控</a><br><a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.74.md#%E4%B8%80%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7">卡顿监控</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aa-2jp0VYmXB6Sn0Jgx7Bg">Runloop-实际开发你想用的应用场景</a></p>
<h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5ZV0eUljDYY36qaq0KzrUA">关于TapGesture、UIResponder 链和 target-action 事件的相互影响的机理和应用</a></p>
<h3 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h3><p><a target="_blank" rel="noopener" href="http://southpeak.github.io/2015/12/13/cocoa-uikit-uicontrol/">UIKit: UIControl</a></p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3459ff04104d?utm_campaign=hugo&utm_medium=reader_share&utm_content=note&utm_source=weixin-friends&from=groupmessage&isappinstalled=0">iOS倒计时的探究与选择</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016633863241728014">NSTimer循环引用原因及解决方案</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kN9eUnFAWDA26kFNHBUcIQ">小心 NSTimer 中的内存泄漏</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cSZUNMuqk6DL3-nctyxzcw">iOS关于时间的处理</a></p>
<h1 id="图像渲染流程"><a href="#图像渲染流程" class="headerlink" title="图像渲染流程"></a>图像渲染流程</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/101639">42 | iOS原生、大前端和Flutter分别是怎么渲染的？</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&mid=2647764254&idx=1&sn=f3eddfc2975922228b1ff91ec1dd21a3">深入理解 iOS Rendering Process</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=400417748&idx=1&sn=0c5f6747dd192c5a0eea32bb4650c160&3rd=MzA3MDU4NTYzMw==&scene=6#rd">iOS 事件处理机制与图像渲染过程</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CO4NuwoHDeH7rQ-6Caze_Q">iOS 渲染原理解析</a><br><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RFIiwvEhdSBub7HFm3C1Ug">iOS圆角的离屏渲染，你真的弄明白了吗</a></p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dfe084fadfc2">iOS动画（Core Animation）总结</a><br><a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition">iOS 视图控制器转场详解</a><br><a target="_blank" rel="noopener" href="https://onevcat.com/2013/10/vc-transition-in-ios7/">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-5-3/">View Controller 转场</a></p>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a><br><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/ios_image_tips/">iOS 处理图片的一些小 Tip</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7d8a82115060">WWDC2018-Image and Graphics Best Practices</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7d8a82115060">iOS性能优化——图片加载和处理</a><br><a target="_blank" rel="noopener" href="http://blog.cnbang.net/tech/2578/">iOS图片加载速度极限优化—FastImageCache解析</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903464934326279">谈谈 iOS 中图片的解压缩</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903439525216269">iOS中的imageIO与image解码</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903439525216270">图片之旅</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/samplecode/LargeImageDownsizing/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011173-Intro-DontLinkElementID_2">Large Image Downsizing</a></p>
<h3 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904084059717640">源码浅析 SDWebImage 5.5.2</a></p>
<h3 id="YYWebImage"><a href="#YYWebImage" class="headerlink" title="YYWebImage"></a>YYWebImage</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd5537fa0caf">YYWebImage 源码剖析：线程处理与缓存策略</a></p>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DOfnIJwfz0m7A6-vooICHg">YYText 源码剖析：CoreText 与异步绘制</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/95023">28 | 怎么应对各种富文本表现需求？</a></p>
<h2 id="Quartz-2D"><a href="#Quartz-2D" class="headerlink" title="Quartz 2D"></a>Quartz 2D</h2><p><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/11/10/quartz2d-1/">Quartz 2D编程指南之一：概览</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36820191?utm_source=weibo&utm_medium=social&utm_oi=37937647452160&from=1084393010&wm=3333_2001&weiboauthoruid=1438670852">移动端IM开发者必读(二)：史上最全移动弱网络优化方法总结</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22959110#%E6%A6%82%E8%A7%88">深度优化iOS网络模块</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ccbb55ef8564">iOS 端定位「网络问题」</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904056767381518">iOS Authentication Challenge</a></p>
<h2 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h2><p><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/tree/master/contents/AFNetworking">AFNetworking</a><br><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/7510469283">AFNetworking 源码分析</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MQgWeYC6Cq9N9BraRMAkow">探秘AFNetworking</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UdwRytczg2lar0FwRpLTyg">NSURLSession最全攻略</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KB3yQhYfdX0yEBBFI9FDew">Network.framework 入门</a></p>
<h1 id="NSCoding"><a href="#NSCoding" class="headerlink" title="NSCoding"></a>NSCoding</h1><p><a target="_blank" rel="noopener" href="https://nshipster.cn/nscoding/">NSCoding &#x2F; NSKeyed​Archiver</a><br><a target="_blank" rel="noopener" href="https://github.com/ChenYilong/iOS12AdaptationTips/issues/1">领悟到 NSCoding 是一个坑，Apple 花了10年时间</a></p>
<h1 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ac45d99cf912">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1004876">JavaScriptCore全面解析 （下篇）</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html">深入理解JSCore</a><br><a target="_blank" rel="noopener" href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication/">从零收拾一个hybrid框架（一）– 从选择JS通信方案开始#几种通信方式的优缺点对比</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/WebViewPerf.html">WebView性能、体验分析与优化</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d8da122f265da5b5a7209fa">iOS 端 h5 页面秒开优化实践</a></p>
<h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904121300959246">Flutter动态化热更新的思考与实践</a></p>
<h1 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MUbzJ8xcEMN2snFLGM5JOQ">iOS自动化埋点探索</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903812986060814">无痕埋点的设计与实现</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/87925">09 | 无侵入的埋点方案如何实现？</a><br><a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md">打造一个通用、可配置、多句柄的数据上报 SDK</a></p>
<h1 id="加密-Code-Signing"><a href="#加密-Code-Signing" class="headerlink" title="加密&#x2F;Code Signing"></a>加密&#x2F;Code Signing</h1><p><a target="_blank" rel="noopener" href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a><br><a target="_blank" rel="noopener" href="https://objccn.io/issue-17-2/">代码签名探析</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d3feaf7e51d4561e224a2a7#heading-24">iOS 的 Code Signing 体系</a><br><a target="_blank" rel="noopener" href="http://xelz.info/blog/2019/01/11/ios-code-signature/">深度长文：细说iOS代码签名</a><br><a target="_blank" rel="noopener" href="https://danleechina.github.io/migrating-code-signing/#sign-in-xcode8">将代码签名配置迁移到 Xcode 8</a></p>
<h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653577384&idx=1&sn=b44a9c9651bf09c5bea7e0337031c53c&scene=1&srcid=0730OYrkabYWsw4AFBCJELvS&from=groupmessage&isappinstalled=0#wechat_redirect">移动App入侵与逆向破解技术－iOS篇</a><br><a target="_blank" rel="noopener" href="http://iosre.com/t/app/11340">小蚁摄像机App加密探究</a><br><a target="_blank" rel="noopener" href="https://everettjf.github.io/2018/01/15/ios-app-reverse-engineering-stuff/">iOS应用逆向工程资料</a></p>
<h1 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h1><p><a target="_blank" rel="noopener" href="https://github.com/VideoFlint/Cabbage/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E">iOS 视频编辑核心架构</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d29d884f265da1b971aa220">(强烈推荐)移动端音视频从零到上手</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31717622">【音视频开发】开发小白如何成为音视频专家？</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/15811977">FFMPEG视音频编解码零基础学习方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/28114081">视频压缩编码和音频压缩编码的基本原理</a><br><a target="_blank" rel="noopener" href="http://www.52im.net/thread-228-1-1.html">即时通讯音视频开发</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1ea0TG_Zq8F4qXD_v6KH9Q">VideoLab - 高性能且灵活的 iOS 视频剪辑与特效框架</a><br><a target="_blank" rel="noopener" href="https://ffmpeg.xianwaizhiyin.net/">FFmpeg原理</a></p>
<h1 id="Dark-Mode"><a href="#Dark-Mode" class="headerlink" title="Dark Mode"></a>Dark Mode</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Tm8RiDymNO5oMrP1D8edvw">微软是如何适配 Dark Mode 的？</a></p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p><a target="_blank" rel="noopener" href="https://awesome-tips.github.io/iostip/">iOS知识小集 —— 微博话题</a><br><a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/knowledge-kit/blob/master/SUMMARY.md">knowledge-kit</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hI7ljWQ940ZIlXK5i2eqyg">10 个 iOS 开发实用小技巧</a></p>
<h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/10/25/navigation-transition-solution-and-best-practice-in-meituan.html">iOS系统中导航栏的转场解决方案与最佳实践</a></p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b0eb24b567b">2018 6月底面试经历简单回忆</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56e40ea56813">2017年5月iOS招人心得（附面试题）</a><br><a target="_blank" rel="noopener" href="https://github.com/colourful987/bytedance-alibaba-interview">阿里、字节 一套高效的iOS面试题解答（完结）</a><br><a target="_blank" rel="noopener" href="https://github.com/liberalisman/iOS-Interview-Question-Answer">Interview-Question &amp; Answer</a><br><a target="_blank" rel="noopener" href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md">《招聘一个靠谱的iOS》面试题参考答案（上）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64a7c9f7f6b2">集合</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">CS-Notes</a><br><a target="_blank" rel="noopener" href="https://trello.com/b/NaN6GOo6/ios-interviews">ios-interviews</a></p>
<h1 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EIPHLdxBMb5MiRDDfxzJtA">A站 的 Swift 实践 —— 下篇</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qPlg716RqtiT2PK_WqtBZQ">Swift5.0的Runtime机制浅析</a></p>
<h1 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p><a target="_blank" rel="noopener" href="https://176zane.github.io/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">Runtime 源码笔记：对象与类</a><br><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/">重识 Objective-C Runtime - Smalltalk 与 C 的融合</a><br><a target="_blank" rel="noopener" href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a><br><a href="">刨根问底Objective－C Runtime</a></p>
<p><a target="_blank" rel="noopener" href="https://176zane.github.io/2021/11/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Objective-C%20Runtime%20Programming%20Guide/">【翻译】Objective-C Runtime Programming Guide</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p><a target="_blank" rel="noopener" href="https://176zane.github.io/2020/09/15/Block%20%E7%AC%94%E8%AE%B0/">Block 笔记</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5U_VwfEEFfOFvcKIpgNFbQ">一道Block面试题的深入挖掘</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XRccU9-M0PG9ceL7fArvkA">一种查看Block中引用的所有外部对象的实现方法</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2018/06/24/Objective-C-Block-Mangle-Name/">追踪 Objective-C Block 代码定义的位置</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/">追踪 Objective-C 方法中的 Block 参数对象</a></p>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/7083154629">《Objective-C 高级编程》干货三部曲（一）：引用计数篇</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-%E6%8C%87%E9%92%88%EF%BC%88NONPOINTER-ISA%EF%BC%89">Objective-C 引用计数原理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993634762896195615">iOS底层学习——weak实现原理和销毁过程</a><br><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1006618">深入理解Autorelease Pool</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/autoreleasepool/">自动释放池的前世今生 —- 深入解析 autoreleasepool</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a5a25ce1dca1?utm_campaign=hugo&utm_medium=reader_share&utm_content=note&utm_source=weixin-friends">DEAD in iOS Memory</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WQ7rrTJm-cn3Cb6e_zZ4cA">iOS Memory Deep Dive</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/">iOS Memory Deep Dive</a></p>
<h2 id="多线程-GCD-锁"><a href="#多线程-GCD-锁" class="headerlink" title="多线程 GCD 锁"></a>多线程 GCD 锁</h2><p><a href="">Power, Performance, and Diagnostics: What’s new in GCD and XPC</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2015/226/">Advanced NSOperations–WWDC 2015 - Session 226</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/210/">Mastering Grand Central Dispatch–WWDC 2011 - Session 210</a><br><a target="_blank" rel="noopener" href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">GCD 深入理解：第一部分</a><br><a target="_blank" rel="noopener" href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23998703">iOS多线程到底不安全在哪里？</a><br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/90870">17 | 远超你想象的多线程的那些坑</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24618377">如何用Xcode8解决多线程问题</a></p>
<p><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/">Threading Programming Guide(1)</a><br><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/4805163927">《Objective-C 高级编程》干货三部曲（三）：GCD篇</a><br><a target="_blank" rel="noopener" href="http://cocoa-chen.github.io/2018/03/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">深入浅出GCD之基础篇</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7030116598727835661">iOS中常见的八种锁</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2dc347464188">正确使用多线程同步锁@synchronized()</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/">Threading Programming Guide(3)</a></p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p><a target="_blank" rel="noopener" href="https://176zane.github.io/2020/12/15/KVC-KVO%20%E7%AC%94%E8%AE%B0/">KVC&#x2F;KVO 笔记</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HO5k6FFkWs4pvjB_w5DslA">巧妙利用 KVO 实现精准的 VC 耗时检测</a><br><a target="_blank" rel="noopener" href="https://draveness.me/kvocontroller">如何优雅地使用 KVO</a></p>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2014/04/30/ios_iterator/">iOS 中集合遍历方法的比较和技巧</a><br><a target="_blank" rel="noopener" href="https://nshipster.cn/enumerators/">NSFast​Enumeration &#x2F; NSEnumerator</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KL5Myz7jio4ackRZVkP7Sw">一些NSArray,NSDictionary,NSSet相关的算法知识</a><br><a target="_blank" rel="noopener" href="https://nshipster.cn/nshashtable-and-nsmaptable/">NSHash​Table &amp; NSMap​Table</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/15/KVC-KVO%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/KVC-KVO%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">KVC/KVO 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-15 20:02:46" itemprop="dateCreated datePublished" datetime="2021-12-15T20:02:46+08:00">2021-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:41:31" itemprop="dateModified" datetime="2023-09-15T14:41:31+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>KVC&#x2F;KVO 并不属于 Objective-C 语言的特性，而是 Cocoa 提供的一种特性。KVC&#x2F;KVO 是通过采用<strong>NSKeyValueCoding &#x2F; NSKeyValueObserving 非正式协议</strong>的方式所实现的一种机制。从协议的角度讲，它是给我们定义了一套去遵循和实现的方法。不过NSObject 提供了相关方法的默认实现，不需要我们显示的实现了。</p>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>除了通过调用访问方法和直接设置实例变量来更改对象状态外，还可以通过键-值编码（key-value coding）的间接方式。<strong>这种间接访问能让开发者在运行时而非编译期决定访问哪个属性</strong>。即使在编译期还不知道属性的键是什么也无所谓。这种动态访问对于 nib 文件的加载和 iOS 中的 Core Data 尤其重要，在 MacOS 中，KVC 则是 AppleScript 接口的基础部分。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>键-值编码中的基本调用是<code>-valueForKey:</code>和<code>-setValue:forKey:</code>方法，向对象发送消息，并传递想要访问的属性名称字符串（键）作为参数。KVC 的默认实现可以参考苹果的官方文档《Key-Value Coding Programming Guide》中的这一章：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955">Accessor Search Patterns</a>。下面简单介绍一下，当调用<code>-valueForKey:</code>方法时，会按照如下步骤进行：</p>
<ol>
<li><p>首先查找名为<code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>或者<code>_&lt;key&gt;</code>的 getter 方法，若找到则跳到第5步，否则进行下一步。</p>
</li>
<li><p>查找匹配如下模式的实例方法，若匹配则 KVO 系统会创建一个可以响应所有 NSArray 方法的 NSKeyValueArray 数组代理对象并返回，它是NSArray的子类，这个代理数组对象与 KVC 结合起来使用中行为与真正的数组对象一样。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-countOf&lt;Key&gt;</span><br><span class="line"><span class="comment">//以下二选一</span></span><br><span class="line">-objectIn&lt;Key&gt;AtIndex:</span><br><span class="line">-&lt;key&gt;AtIndexes：</span><br><span class="line"><span class="comment">//&lt;优化可选&gt;</span></span><br><span class="line">-get&lt;Key&gt;:range:</span><br><span class="line"></span><br><span class="line"><span class="comment">//若是可变容器类的属性还需实现</span></span><br><span class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:</span><br><span class="line">-removeObjectFrom&lt;Key&gt;AtIndex: </span><br><span class="line"><span class="comment">//&lt;优化可选&gt;</span></span><br><span class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</span><br></pre></td></tr></table></figure></li>
<li><p>查找如下的匹配模式，若匹配则创建与上述数组代理对象类似的行为与 NSSet 一致的集合代理对象并返回。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-countOf&lt;Key&gt;</span><br><span class="line">-enumeratorOf&lt;Key&gt;</span><br><span class="line">-memberOf&lt;Key&gt;:</span><br></pre></td></tr></table></figure>
</li>
<li><p>若接收者的类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>，则查找名为<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>的实例变量，找到则跳到5，否则跳到6</p>
</li>
<li><p>若获取到的属性是对象指针则直接返回。若获取到的属性是标量类型的值且可以封装为 NSNumber 对象则封装后返回。若获取到的属性是标量类型的值但不能封装为 NSNumber 对象则封装为 NSValue 对象后返回。</p>
</li>
<li><p>若上面的所有步骤都失效，则调用<code>valueForUndefinedKey:</code>方法，该方法默认会抛出异常，但是 NSObject 子类可以重写并对特殊的 key 提供相应的行为。</p>
</li>
</ol>
<p><code>-valueForKey:</code>在 Objective-C 运行时中使用元数据打开对象并进入其中查找需要的信息。在 C 或 C++ 中不能执行这种操作。通过使用 KVC，没有相关 getter 方法也能获取对象值。<br>对于上面步骤5中的自动装箱和开箱标量值。可以看下如下的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">float</span> mileage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">[car setValue:@(<span class="number">200.0</span>) forKey:<span class="string">@&quot;mileage&quot;</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *mileage = [car valueForKey:<span class="string">@&quot;mileage&quot;</span>];</span><br></pre></td></tr></table></figure>
<p><code>setValue:forKey:</code>会将 <code>@(200.0)</code> 开箱取出值，再调用<code>setMileage:</code>或者更改 <code>mileage</code> 变量。</p>
<h3 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h3><p>可以使用 <code>valueForKeyPath:</code>和<code>setValue:forKeyPath:</code>来通过键路径访问属性。键路径可以包含嵌套关系，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[car setValue:@(<span class="number">200</span>) forKeyPath:<span class="string">@&quot;engine.horsepower&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="KVC-实现高阶消息传递"><a href="#KVC-实现高阶消息传递" class="headerlink" title="KVC 实现高阶消息传递"></a>KVC 实现高阶消息传递</h3><p>如果键路径中有 NSArray 或 NSSet 这样的容器类属性，则该键路径的其余部分将被发送给容器类的每个对象。而不是对容器本身进行操作。结果会被添加进返回的容器中。这样可以方便的用一个容器对象创建另一个容器对象。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@&quot;foo&quot;</span>,<span class="string">@&quot;bar&quot;</span>,<span class="string">@&quot;ted&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *capitals = [array valueForKey:<span class="string">@&quot;capitalizedString&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>把消息(capitalizedString)作为参数传递称为高阶消息传递。</p>
<h3 id="容器操作符"><a href="#容器操作符" class="headerlink" title="容器操作符"></a>容器操作符</h3><p>键路径不仅能引用对象值，还可以引用一些运算符来进行一些运算。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@&quot;foo&quot;</span>,<span class="string">@&quot;bar&quot;</span>,<span class="string">@&quot;ted&quot;</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> totalLength = [[array valueForKeyPath:<span class="string">@&quot;@sum.length&quot;</span>] intValue];</span><br></pre></td></tr></table></figure>
<p><code>@sum</code>是一个操作符，对指定的属性(length)求和。key path 中的 @ 符号代表了一个特定的集合方法。具体的使用也可以参考 NSHipster 的这篇文章：<a target="_blank" rel="noopener" href="http://nshipster.cn/kvc-collection-operators/">KVC Collection Operators</a>。 KVC 能非常轻松的处理集合类，但是它需要解析字符串来计算你想要的答案，所以通常速度比较慢。</p>
<h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>对于标量值的属性，如果使用 nil 作为参数调用<code>setValue:forKey:</code>，那么键会被传递给<code>setNilValueForKey:</code>方法，如果该对象支持标量值属性这是为 nil，则需要实现这个方法。默认的行为是抛出异常。<br>对 NSDictionary 对象的<code>setObject:forKey:</code>方法传入 nil 值，会发出警告。但是若使用<code>setValue:forKey:</code>传入 nil 值，则会把对应键的值从字典中删除。</p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>Cocoa 有若干观察者机制，包括委托和 NSNotification，但是 KVO 的开销更小，被观察的对象允许其他对象去监听它的某个属性的改变，并且不需要有任何额外的代码来通知观察者，而如果没有观察者，KVO 就没有运行时的消耗，只有对象被真正观察时，KVO 系统才添加通知代码。<br>关于 KVO 的基本使用可以看看以下几篇博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2015/04/23/cocoa-foundation-nskeyvalueobserving/">Foundation: NSKeyValueObserving(KVO)</a></li>
<li><a target="_blank" rel="noopener" href="https://objccn.io/issue-7-3/">KVC 和 KVO</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/">objc kvo简单探索</a></li>
</ul>
<h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><p>要让一个对象监听另一个对象属性的变化，首先被观察对象要添加观察者对象为其相关属性的观察者。调用方法如下（**注意这个方法调用时，两个对象都不会被<code>retain</code>**）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer </span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options </span><br><span class="line">            context:(<span class="keyword">nullable</span> <span class="type">void</span> *)context;</span><br></pre></td></tr></table></figure>
<p>注册 KVO 时，要给 context 传递进去一个随机数据作为上下文数据。因为一个类只能有一个 KVO 回调，所以可能收到父类注册的属性变化事件。如果是这样，需要把回调传递给 super,所以要用唯一的 context 来识别观察的事件,这样子类和父类都能安全的观察同样的键值而不会冲突。推荐一个比较好的 context 值的声明方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> * xxContext = &amp;xxContext;</span><br></pre></td></tr></table></figure>
<p>将其声明在 .m 文件的顶端，xxContext 静态变量中存储着自己的指针，可以用来确定唯一的 context。<br>传入的 keyPath 最好也不要用字符串字面值，因为不能被编译器检查拼写错误。推荐使用 <code>NSStringFromSelector(@selector(length))</code>这种写法。</p>
<p>options 为 NSKeyValueObservingOptions 的选项组合。它指定了观察通知中包含了什么数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSKeyValueObservingOptions</span>) &#123;</span><br><span class="line">    <span class="comment">//通知的 change 字典中应该包含新值</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">//通知的 change 字典中应该包含旧值</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">/*立即发送一个通知给观察者，甚至在观察者注册方法返回之前。如果同时组合了 NSKeyValueObservingOptionNew 选项的话，</span></span><br><span class="line"><span class="comment">    通知的 change 字典中总会包含新值。但是永远不会包含旧值。（虽然最初的那一个通知中值可能是旧值，但是对于观察者来说也是新值。）</span></span><br><span class="line"><span class="comment">    可以将这个选项用来避免初始化时需要显示的调用观察者的 -observeValueForKeyPath:ofObject:change:context: 回调方法中的代码。</span></span><br><span class="line"><span class="comment">    当这个选项用于 addObserver:toObjectAtIndexes:forKeyPath:options:context: 方法时。通知将会发送给观察者被添加的每一个索引对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">/*不仅在属性改变后发送通知，还在改变前发送一条通知。改变前发送的通知的 change 字典中会包含NSKeyValueChangeNotificationIsPriorKey 入口，</span></span><br><span class="line"><span class="comment">    但是永远不会包含 NSKeyValueChangeNewKey 入口。通常用于当观察者自身的 KVO 需要为自己的某个属性调用 -willChange... 方法，而这个属性的值又依赖于被观察对象的属性时。</span></span><br><span class="line"><span class="comment">    改变后发送的通知的 change 字典中与不指定此选项时是相同的。（按顺序排列的 to-many 关系的 NSOrderedSets属性例外）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="观察者回调"><a href="#观察者回调" class="headerlink" title="观察者回调"></a>观察者回调</h3><p>观察者必须实现<code>-observerValueForKeyPath:ofObject:change:context:</code>方法，来对被观察对象属性修改的通知做相应的处理。对观察者对象来说，它所有观察的改变都被聚集到这个方法回调中来，所以需要通过 context 上下文信息来准确的判断是哪个被观察对象的改变通知。<br>change 字典是<code>NSDictionary&lt;NSKeyValueChangeKey,id&gt;</code>类型的, NSKeyValueChangeKey 定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> * <span class="built_in">NSKeyValueChangeKey</span>;</span><br><span class="line"><span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeKindKey</span>;</span><br><span class="line"><span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNewKey</span>;</span><br><span class="line"><span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeOldKey</span>;</span><br><span class="line"><span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeIndexesKey</span>;</span><br><span class="line"><span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>;</span><br></pre></td></tr></table></figure>
<p>举个例子，当注册时的 options 包含<code>NSKeyValueObservingOptionInitial</code>时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> horsepower;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> * carContext = &amp;carContext;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == carContext) &#123;</span><br><span class="line">        <span class="comment">//仅打印 change 字典</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;change = %@&quot;</span>,change);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="variable language_">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setupCar &#123;</span><br><span class="line">    Engine *engine = [[Engine alloc] init];</span><br><span class="line">    engine.horsepower = <span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    [engine addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(horsepower)) options:<span class="built_in">NSKeyValueObservingOptionInitial</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:carContext];</span><br><span class="line">    engine.horsepower = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>打印结果如下如下所示，注册时会回调一次，change 字典中包含了 new 值：300。改变属性为 100 时，又回调一次， change 字典中包含 old 值：300，new 值：100。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">100</span>;</span><br><span class="line">    old = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述注册方法中的<code>NSKeyValueObservingOptionInitial</code>选项换成<code>NSKeyValueObservingOptionPrior</code>时，打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    notificationIsPrior = <span class="number">1</span>;</span><br><span class="line">    old = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">100</span>;</span><br><span class="line">    old = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在属性改变为 100 前回调一次，change 字典中包含了<code>notificationIsPrior</code>键，且它的值总为<code>@(YES)</code>。属性改变后回调中的 change 字典跟其他选项时一样。<br>上面的例子中，kind 的值总是 1，其实 NSKeyValueChangeKindKey 键的值的定义如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSKeyValueChange</span>) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueChangeSetting</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeInsertion</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeRemoval</span> = <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeReplacement</span> = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当观察的对象关系是一对多时，出现插入、剔除或替换时就会出现其他值了，change 字典中其他键值对也会相应变化。</p>
<h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><p>当观察者完成了对监听对象的观察之后，被观察对象需要调用<code>-removeObserver:forKeyPath:</code>或<code>-removeObserver:forKeyPath:context:</code>方法移除观察者。如果忘记调用该方法移除观察者的话，程序会崩溃，因为在这些对象被释放之后，KVO 依然保留着它们的注册信息，KVO对这种情况的处理就是让程序直接崩溃。<br>若调用该方法时，传入的观察者对象并没有被注册为该键路径的观察者，程序也会崩溃。因此要追踪自己观察的属性。一个妥协的方法是可以使用 @try&#x2F;@catch 来使它不崩溃，但这个方法并不推荐。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    [string removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(length))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;&#125;<span class="comment">//@catch中没有做处理</span></span><br></pre></td></tr></table></figure>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是指该属性依赖于其他一个或多个属性的变化而变化。因此在 KVO 中，所依赖的其他属性变化时，我们也想要监听到计算属性的相应通知。<code>NSKeyValueObserving</code>协议提供了下面的两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line"><span class="comment">//或针对某一属性的:</span></span><br><span class="line">+(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffecting&lt;key&gt;</span><br></pre></td></tr></table></figure>
<p>举个例子，一般的 color 属性都是依赖于RGB三个部分的变化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="comment">//调用父类的此方法，获取父类中可能对 key 指定属性产生影响的属性集合</span></span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="variable language_">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span>([key isEqualToString:<span class="string">@&quot;color&quot;</span>])&#123;</span><br><span class="line">       keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="string">@&quot;red&quot;</span>,<span class="string">@&quot;green&quot;</span>,<span class="string">@&quot;blue&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者如下方法，确定父类没有对此属性的依赖属性时：</span></span><br><span class="line">+(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingColor &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@&quot;red&quot;</span>,<span class="string">@&quot;green&quot;</span>,<span class="string">@&quot;blue&quot;</span>,<span class="literal">nil</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写了这个方法之后，无论是<code>color</code>属性自己发生了变化还是<code>red</code>、<code>green</code>、<code>blue</code>属性发生变化，我们都会收到<code>color</code>属性的通知回调。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>观察容器类和观察其中的对象是不同的。KVO 旨在观察关系而不是集合。对于集合属性，我们将其当成一个整体来监听它的变化，而无法监听集合中的某个元素的变化。举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *wheels;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Garage</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)repair;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> * garContext = &amp;garContext;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Garage</span></span></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;change = %@&quot;</span>,change);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)repair &#123;</span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    [car addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(wheels)) options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:garContext];</span><br><span class="line">    car.wheels = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [car.wheels addObject:<span class="string">@&quot;frontWheel&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上述例子在调用了 garage 对象的 <code>repair</code>方法后的打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new =     (</span><br><span class="line">    );</span><br><span class="line">    old = <span class="string">&quot;&lt;null&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见当我们观察 car 对象的 wheels 数组属性时，获取的是真正的可变数组，只有在 wheels 属性被整体修改的时候，才会触发 KVO，在后面添加元素进去的时候并没有触发 KVO！</p>
<h4 id="代理集合对象"><a href="#代理集合对象" class="headerlink" title="代理集合对象"></a>代理集合对象</h4><p>在上面的 KVC 部分我们说过，只要实现了指定的方法，我们就可以使用**代理集合对象(collection proxy object)**来通过 KVC 处理集合相关的操作。此外我们可以通过调用<code>mutableArrayValueForKey:</code>或<code>mutableSetValueForKey:</code>来获取可变数组属性或可变集合属性的代理对象。集合代理对象与 KVO 结合起来也十分强大，KVO 机制在这些代理集合对象改变的时候可以把详细变化放进 change 字典中。我们可以将上个例子中的最后两行代码换成下面的试试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car.wheels = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *wheels = [car mutableArrayValueForKey:<span class="string">@&quot;wheels&quot;</span>];</span><br><span class="line">[wheels addObject:<span class="string">@&quot;backWheel&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">change = &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new =     (</span><br><span class="line">    );</span><br><span class="line">    old = <span class="string">&quot;&lt;null&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">change = &#123;</span><br><span class="line">    indexes = <span class="string">&quot;&lt;_NSCachedIndexSet: 0x100703a70&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]&quot;</span>;</span><br><span class="line">    kind = <span class="number">2</span>;</span><br><span class="line">    new =     (</span><br><span class="line">        backWheel</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到往 wheels 数组中添加对象时，也触发了KVO。并且 change 字典中有详细的变化信息。</p>
<h3 id="KVO的实现"><a href="#KVO的实现" class="headerlink" title="KVO的实现"></a>KVO的实现</h3><p>KVO 是通过 Objective-C 的 runtime 来实现的，第一次对一个对象调用<code>addObserver:forKeyPath:options:context:</code>时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象(将新对象的 isa 指针指向新子类)。在这个特殊的子类中重写所有被观察属性的 setter 方法，并在其中添加通知变化的代码。<strong>这种继承和方法注入是在运行时而不是编译时实现的。</strong><br>在 KVO 的默认实现中，在被观察属性发生改变之前，会自动调用<code>willChangeValueForKey:</code>方法，这就会记录旧的值。而当改变发生后，<code>didChangeValueForKey:</code>会被调用，继而观察者的<code>observeValueForKey:ofObject:change:context:</code>也会被调用。<br>我们也可以手动来发送这些通知，从而达到更精确的管理。实现方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察类必须重写如下方法:</span></span><br><span class="line">+ (<span class="type">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span>([key isEqualToString:<span class="string">@&quot;horsepower&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;<span class="comment">//关闭了 -willChangeValueForKey: 和 -didChangeValueForKey: 的自动调用，</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动发送通知：</span></span><br><span class="line">-(<span class="type">void</span>)setHorsepower:(<span class="built_in">NSInteger</span>)horsepower &#123;</span><br><span class="line">    <span class="keyword">if</span>(_horsepower != horsepower) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;horsepower&quot;</span>];</span><br><span class="line">        _horsepower = horsepower;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;horsepower&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：对于集合代理对象，发送通知的方法更为详细。</span></span><br></pre></td></tr></table></figure>
<h3 id="KVO-和线程"><a href="#KVO-和线程" class="headerlink" title="KVO 和线程"></a>KVO 和线程</h3><p><strong>KVO 的行为是同步的，并且与所观察值的变化发生在同样的线程上。没有队列或者 run-loop 的处理。因此当我们试图从其他线程改变属性值的时候要十分小心，除非能确定所有的观察者都是用线程安全的方法处理 KVO 通知，我们不应该将 KVO 和多线程混用起来。</strong><br>KVO 的同步特性十分强大，只要我们在单一线程运行，则对于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.horsepower = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p>KVO 能保证所有 horsepower 的观察者在 setter 方法返回前收到通知。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>我们可以在 lldb 中查看一个被观察对象的所有观察信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb)po [observedObject observationInfo]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>observationInfo 这个方法的默认实现是以对象的指针作为键从一个全局字典中获取信息。得到的是一个 NSKeyValueObservationInfo 对象，它包含了指定对象上的所有的监听信息。<br>由此可见 KVO 的信息是存储在一个全局字典中，而不是存储在对象本身。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>注意：并不是所有的类的所有属性都兼容 KVO。如果类的所有者不保证类的某个属性兼容 KVO，我们就不能保证 KVO 正常工作。详情可以查看官方文档。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Objective-C%20Runtime%20Programming%20Guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Objective-C%20Runtime%20Programming%20Guide/" class="post-title-link" itemprop="url">【翻译】Objective-C Runtime Programming Guide</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-03 09:22:42" itemprop="dateCreated datePublished" datetime="2021-11-03T09:22:42+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-09 21:35:01" itemprop="dateModified" datetime="2023-08-09T21:35:01+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 语言将尽可能多的决定从编译期和链接期推迟到运行时。它尽可能的动态化。这就意味着这门语言不仅需要编译器还需要运行时系统来执行它编译好的代码。运行时系统对于 Objective-C 语言来说就像操作系统一样来使它运行起来。</p>
<p>这篇文档着眼于<code>NSObject</code>类和 Objective-C 程序如何与运行时系统交互。重点探讨了在运行时动态加载新类的范例，将消息转发给其他对象。还有对在程序运行时如何查找对象的有关信息提供了相关资料。</p>
<p>你可以通过阅读此文档来了解 Objective-C 运行时系统是如何工作的以及如何利用它。同时，你几乎不需要了解这篇文档就可以写 cocoa 应用了。</p>
<h2 id="不同平台与版本的运行时系统"><a href="#不同平台与版本的运行时系统" class="headerlink" title="不同平台与版本的运行时系统"></a>不同平台与版本的运行时系统</h2><p>不同的平台上使用着不同版本的运行时系统。</p>
<h3 id="早期版本与现代版本"><a href="#早期版本与现代版本" class="headerlink" title="早期版本与现代版本"></a>早期版本与现代版本</h3><p>现在同时存在着两个版本的运行时系统：“现代版本”和“早期版本”，现代版本是与 Objective-C 2.0以及很多其他特性一起引入的。早期版本的编程接口可以在 Objective-C 1 Runtime Reference 中查看。现代版本的编程接口可以在 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc">Objective-C Runtime</a>这里查看。</p>
<p>现代版本的运行时系统最值得注意的地方在于实例变量是“稳固的”：</p>
<ul>
<li>在早期版本的运行时系统中，如果你改变了一个类的实例变量的布局，你就得重新编译所有继承于此类的类。</li>
<li>在现在版本中则不需要。</li>
</ul>
<p>除此之外，现代版本的运行时系统支持已声明属性的实例变量的自动合成。</p>
<h3 id="不同平台的版本"><a href="#不同平台的版本" class="headerlink" title="不同平台的版本"></a>不同平台的版本</h3><p>iphone 应用程序和 OS X 10.5 之后的 64 位程序都使用现代版本的运行时系统。</p>
<p>其他程序（OS X 上的 32 位应用）使用了早期版本的运行时系统。</p>
<h2 id="与运行时系统交互"><a href="#与运行时系统交互" class="headerlink" title="与运行时系统交互"></a>与运行时系统交互</h2><p>Objective-C 程序可以在三个不同的层次上与运行时系统进行交互：通过 Objective-C 源代码；通过 Foundation 框架中<code>NSObject</code>类中定义的方法；通过直接调用运行时函数。</p>
<h3 id="Objective-C-源代码"><a href="#Objective-C-源代码" class="headerlink" title="Objective-C 源代码"></a>Objective-C 源代码</h3><p>大多数情况下，运行时系统都是在幕后自动工作的，你仅仅需要编写和编译 Objective-C 源代码。</p>
<p>当你编译包含 Objective-C 类和方法的代码时，编译器会创建实现该语言动态特征的数据结构和函数调用。数据结构中会包含类和分类的定义以及协议声明中的信息。其中有《The Objective-C Programming Language》中<code>Defining a Class and Protocols</code>章节中讨论过的类和协议对象，以及方法选择器，实例变量模板及其他从源代码中提取出的信息。最基本的运行时方法是在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1">Messaging</a>中描述的发送消息的方法。它通过源代码中的消息表达式调用。</p>
<h3 id="NSObject-方法"><a href="#NSObject-方法" class="headerlink" title="NSObject 方法"></a>NSObject 方法</h3><p>Cocoa 中的大多数对象都是<code>NSObject</code>类的子类，因此他们都继承了<code>NSObject</code>类定义的方法。（一个例外是<code>NSProxy</code>类）这些方法使得每一个实例对象和类对象都有与生俱来的一些能力。然而极少数情况下，NSObject 类只提供了相关方法的模板，并不提供所有的实现代码。</p>
<p>举例来说，<code>NSObject</code>类定义了一个返回类的相关内容的字符串的<code>description</code>实例方法，主要用于调试-GDB的<code>print-object</code>命令就打印这个方法返回的字符串。由于并不知道类中包含什么，所以<code>NSObject</code>对<code>description</code>方法的实现只是返回包含对象的名字以及内存地址的字符串。<code>NSObject</code>的子类可以实现这个方法来返回更多信息。比如基础类<code>NSArray</code>返回了它包含对象的列表。</p>
<p>有些<code>NSObject</code>类的方法只是向运行时系统查询相关信息。这些方法允许对象自省。例如，<code>class</code>方法是对象用来确定自己的类的方法；<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>是用来检查对象在继承等级中的位置的；<code>respondsToSelector:</code>方法是用来指明一个对象是否可以接受特定消息的；<code>conformsToProtocol:</code>方法用于指明一个对象是否声明要实现相应协议中定义的方法；<code>methodForSelector:</code>方法提供了方法实现的内存地址。这些方法为对象提供了自省的相关能力。</p>
<h3 id="运行时函数"><a href="#运行时函数" class="headerlink" title="运行时函数"></a>运行时函数</h3><p>运行时系统是一个有公用接口的动态共享库，接口包含了存储在<code>/usr/include/objc</code>目录下的头文件中的一系列函数和数据结构。它们中的大多数函数允许你在写 Objective-C 代码时使用直白的 C 代码来复制编译器的行为。其他的组成了<code>NSObject</code>类中方法相关功能的基础。这些函数使开发其他运行时系统接口成为可能并生产了提高开发环境能力的工具。这些函数并不是编写 Objective-C 程序是必须的，但是有些函数偶尔会非常有用。这些函数都在<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc">Objective-C Runtime Reference</a>中列出了。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>本章主要描述消息表达式如何转换成对<code>objc_msgSend</code>的函数调用，以及如何通过名字查找方法。然后解释了如何使用<code>objc_msgSend</code>函数，如果需要的话怎么绕过消息的动态绑定。</p>
<h3 id="objc-msgSend-函数"><a href="#objc-msgSend-函数" class="headerlink" title="objc_msgSend 函数"></a>objc_msgSend 函数</h3><p>在 Objective-C 中，直到运行时消息才与方法实现绑定在一起。编译器将如下消息表达式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver message]</span><br></pre></td></tr></table></figure>
<p>转换为<code>objc_msgSend</code>消息函数的调用。这个函数将接收者及消息中提及的方法名字也就是方法选择器作为它的两个基本参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>任何在消息中传递的参数也传给<code>objc_msgSend</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>这个发送消息函数做了动态绑定的所有工作：</p>
<ul>
<li>它首先查找到方法选择器所指向的程序（方法实现）。由于不同的类可以对相同的方法提供不同的实现，所以这个准确的方法实现就取决于接收者所属的类。</li>
<li>然后调用这个程序，并传递消息接收者对象（指向其数据的指针）和其他指定的参数。</li>
<li>最后，将程序的返回值作为自己的返回值返回。</li>
</ul>
<blockquote>
<p>注意：编译器会自动调用<code>objc_msgSend</code>这个发送消息函数，你不应该在自己的代码中直接调用它。</p>
</blockquote>
<p>发送消息的关键在于编译器为每个类和对象所创建的结构体，每个类的结构体包含了如下两个重要元素：</p>
<ul>
<li>一个指向其父类的指针。</li>
<li>一个类的分发表。这个表记录了方法选择器和它对应的特属于该类的方法实现的指针之间的关联。如方法选择器<code>setOrigin::</code>与<code>setOrgin::</code>方法的实现程序的地址间的相互关联，方法选择器<code>display</code>与<code>display</code>方法的实现程序的地址之间相互关联，等等…</li>
</ul>
<p>当一个新的对象被创建成功后，内存空间已经开辟好了，它的实例变量也已经初始化完成了，对象的变量中的第一个就是指向其类结构体的命名为<code>isa</code>的指针。通过这个指针，对象可以访问其所属类，通过所属类可以访问它的所有父类。</p>
<blockquote>
<p>严格来说<code>isa</code>指针并不是 Objective-C 语言的一部分，但是它确实是运行时系统所必需的。一个对象必须与定义在<code>objc/objc.h</code>中的<code>struct objc_object</code>结构体所定义的等同。任何继承自<code>NSObject</code>或<code>NSProxy</code>的对象都自动包含了这个<code>isa</code>变量，你几乎不需要创建自己的根对象。</p>
</blockquote>
<p>类与对象的结构体的元素如下图所示：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="Figuire 3-1"></p>
<p>当一个消息发送给对象时，<code>objc_msgSend</code>函数顺着对象的<code>isa</code>指针找到对象所属类的结构体，从而在类的分发表中查找方法选择器。如果找不到就顺着指向父类的指针找到父类的结构体并在其中的分发表中继续查找。连续的失败会使<code>objc_msgSend</code>函数顺着类的继承层级一路找到<code>NSObject</code>类。一旦定位到方法选择器之后，这个函数就会调用与之关联的方法实现，并将消息接受对象的数据结构作为参数传递过去。</p>
<p>这就是在运行时决定最终的方法调用的过程，或者用行话来说就是面向对象编程，即方法是动态绑定到消息上的。</p>
<p>为加速发送消息的过程，运行时系统会随着方法的调用建立起方法选择器与方法的实现地址之间的缓存。每一个类都会都单独的缓存，其中不仅包含了类自己定义的方法还有继承的方法。在<code>objc_msgSend</code>函数查找分发表之前，它会例行先查找一下接收者对象所属类的缓存（有一种理论是一个方法在使用之后很快又会被再次使用）。如果在缓存中找到这个方法选择器，那么发送消息过程只会比一般的函数调用慢一丢丢。因此一旦程序运行时间足够长致使缓存系统“热身”后，几乎所有的消息都可以在缓存中找到对应的方法。程序运行时，缓存会自动扩充来容纳新的消息。</p>
<h3 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h3><p>当<code>objc_msgSend</code>函数查找到实现方法的程序时，它就会调用这个程序并将消息中的参数传递过去。此外还有两个隐藏的参数被传递过去：</p>
<ul>
<li>消息的接收对象</li>
<li>方法的选择器</li>
</ul>
<p>这些参数给方法表达式调用起的方法实现提供了足够准确的信息。说它们是“隐藏的”是因为在定义方法的源代码中并没有声明它们，它们是在编译时被插入实现代码中的。</p>
<p>尽管这些参数并没有被显示的声明，在源代码中依然可以引用它们（跟引用其他接收者对象的实例变量一样），方法中使用<code>self</code>来引用接收者对象，使用<code>_cmd</code>来引用方法选择器。在下面的例子中，<code>_cmd</code>引用<code>strange</code>方法的选择器，<code>self</code>用来引用接收<code>strange</code>消息的对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span>  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个参数中<code>self</code>更有用一些，通过它方法中才可以访问接收者对象的实例变量。</p>
<h3 id="获取一个方法的地址"><a href="#获取一个方法的地址" class="headerlink" title="获取一个方法的地址"></a>获取一个方法的地址</h3><p>绕过动态绑定的唯一办法是获取到方法的地址，然后像函数一样直接调用它。当你需要连续多次执行某一方法又想要避免每一次都需要发送消息的过程时，绕过动态绑定才可能会稍微合理。</p>
<p>你可以通过定义在<code>NSObject</code>类中的方法：<code>methodForSelector:</code>来获取指向方法实现的程序的指针，然后通过该指针来调用程序。<code>methodForSelector:</code>返回的指针必须被小心的转换成合适的函数类型，参数类型与返回值类型都必须被转换。</p>
<p>下面的例子中展示了<code>setFill:</code>方法的实现程序是如何被调用的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*<span class="keyword">setter</span>)(<span class="type">id</span>, SEL, <span class="type">BOOL</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">setter</span> = (<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure>
<p>传入程序的前两个参数是接收者对象（<code>self</code>）和方法选择器（<code>_cmd</code>），这两个参数在方法被当做函数调用时必须显示的传入。</p>
<p>使用<code>methodForSelector:</code>来绕过动态绑定能节省大多数发送消息所需的时间，但是这种节省只会在特定消息被连续多次重复，像上面的<code>for</code>循环中那样才会比较明显。</p>
<p>注意<code>methodForSelector:</code>方法是由 Cocoa 运行时系统提供的，它并不是语言的一部分。</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>本章描述了如何动态的提供方法的实现。</p>
<h3 id="动态方法解析-1"><a href="#动态方法解析-1" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>有时候你可能需要动态提供方法的实现，举个例子，当 Objective-C 中的已声明的属性使用了<code>@dynamic</code>指令时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure>
<p>这个指令告诉编译器与属性相关方法都会被动态的在运行时提供。</p>
<p>你可以通过实现<code>resolveInstanceMethod:</code>为实例方法动态的提供实现程序，实现<code>resolveClassMethod:</code>来为类方法动态的提供实现程序。</p>
<p>一个 Objective-C 方法就是最少有两个参数-<code>self</code>和<code>_cmd</code>的简单 C 函数。你可以使用<code>class_addMethod</code>函数来给一个类添加一个函数作为方法。例如对于如下的函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dynamicMethodIMP(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像下面这样使用<code>resolveInstanceMethod:</code>将它作为一个方法（<code>resolveThisMethodDynamically</code>方法）动态的添加进类中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>消息转发与动态方法解析是互补的，动态方法解析是在消息转发机制开始前进行的。当<code>respondsToSelector:</code>或<code>instancesResponsToSelector:</code>方法被调用时，动态方法解析机制首先会给你提供方法实现<code>IMP</code>的机会。如果你实现了<code>resolveInstanceMethod</code>方法，但是还想要特定的选择器通过消息转发机制被转发，只需要对这些选择器返回<code>NO</code>。</p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>Objective-C 程序可以在运行时加载和链接新的类和分类，这些代码被合并入程序中并且和启动时加载进的类和分类被同等对待。</p>
<p>动态加载可以做很多事情，举个例子，系统偏好设置里面的各种模块都是被动态加载的。</p>
<p>在 Cocoa 环境中，动态加载普遍被用于应用程序的自定义化。运行时加载其他人编写的模块-诸如 Interface Builer 加载自定义的选项板， OS X 系统偏好设置加载自定义的偏好模块。这些可加载模块可以通过一种你允许的但却不能参与或者定义它的方式来扩展你应用的能力。你只需要提供框架，由其他人来实现代码。（注：本段原文中似乎是以系统为第一人称来表述动态加载的功能，不清楚时可翻看原文）。</p>
<p>除此之外还有运行时函数（定义在<code>objc/objc-load.h</code>中的<code>objc_loadModules</code>）用来动态加载 Mach-O 文件类型的 Objective-C 模块，Cocoa 的 <code>NSBundle</code> 类也提供了更方便的面向对象的集成了相关服务的动态加载方法。查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsbundle">NSBundle</a>类来获取更多信息。 </p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>给一个对象发送它不能处理的消息是一个错误。然而在提示错误之前，运行时系统给接收者对象第二次机会来处理这条消息。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>给一个对象发送它不能处理的消息时，在提示错误之前，运行时系统会给对象发送带有一个<code>NSInvocation</code>对象（其中封装了原始消息和传入的参数）作为唯一参数的消息<code>forwardInvocation:</code>。</p>
<p>你可以通过实现<code>forwardInvocation:</code>方法给消息提供一个默认的响应或者其他操作来避免错误。就像<code>forwardInvocation:</code>这个方法名所暗示的它主要用于将消息转发给其他对象。</p>
<p>为了解转发的意图，想象这样一个场景：假设你在设计一个可以响应<code>negotiate</code>消息的对象，你想在这个响应中包含其他不同对象的响应，你可以简单的通过在<code>negotiate</code>消息的实现代码中把<code>negotiate</code>消息传递给其他对象。</p>
<p>更进一步，假设你想让对象对<code>negotiate</code>消息的响应完全是其他某个类所实现的响应，一种实现办法是使你的类继承于那个类。然而这种方法或许不可能实现，因为你的类与实现<code>negotiate</code>消息的类很大可能属于不同分支的继承链中。</p>
<p>即使你的类不能继承<code>negotiate</code>方法，你仍然可以通过传递消息给其他类的实例来简单的借用它的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)negotiate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [someOtherObject respondsTo:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">        <span class="keyword">return</span> [someOtherObject negotiate];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式比较麻烦，尤其是当你想把一大堆消息传递给其他对象时。你必须为每一个想要从其他类借用的方法实现提供一个方法实现。更甚者，当你编写代码时，你可能并不知道所有想要转发的消息和目标对象，这种情况就难以处理了。这些消息或许是运行时触发的,或许变成未来实现的新的方法和类。</p>
<p><code>forwardInvocation:</code>消息提供了一种更具有普适性的动态而非静态的方式来为处理这种问题。它是这样工作的：当一个对象因为没有与消息的选择器相匹配的方法而不能响应这条消息时，运行时系统会通过发送一条<code>forwardInvocation:</code>消息来通知该对象。每个对象都会从<code>NSObject</code>类中继承这个<code>forwardInvocation:</code>方法，然而<code>NSObject</code>对这个方法的实现只是简单的调用了<code>doesNotRecognizeSelector:</code>。通过重写这个方法来实现自己的逻辑，你就可以利用<code>forwardInvocation:</code>提供的机会将消息转发给其他对象。</p>
<p>为了转发消息，<code>forwardInvocation:</code>只需要：</p>
<ul>
<li>决定消息转发给谁。</li>
<li>然后将带有原始参数的消息发送给它。</li>
</ul>
<p>发送消息可以使用<code>invokeWithTarget:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [<span class="variable language_">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被转发的消息的返回值被返回到原来发送消息的对象。任何类型的返回值都会被返还到原发送者，包括<code>id</code>类型、结构体、双精度浮点数等等。</p>
<p><code>forwardInvocation:</code>消息可以用作不能识别的消息的分发中心，将消息打包后发送给不同的接收者。或者也可以被用作转发站，将所有的消息发送到相同的目的地，或者简单的”吞噬”掉某些消息使其没有响应也不会发出错误提示。<code>forwardInvocation:</code>方法还可以将好几条消息合并到同一个响应中去。<code>forwardInvocation:</code>的行为取决于实现它的人，但是它所提供的将对象添加进一条转发链中的机会为程序设计提供了更多的可能性。</p>
<blockquote>
<p>注：只有在接收者并不会被调用起一个已经存在的方法的时候<code>forwardInvocation:</code>才能处理消息。例如：加入想要接收者对象把<code>negotiate</code>消息转发给其他对象，那么接收者就不能有<code>negotiate</code>的方法实现。如果有的话，消息就永远不会被发送到<code>forwardInvocation:</code>。</p>
</blockquote>
<p>可以查询<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsinvocation?language=occ"><code>NSInvocation</code></a>文档来获取更多消息转发与调用的信息。</p>
<h3 id="转发与多重继承"><a href="#转发与多重继承" class="headerlink" title="转发与多重继承"></a>转发与多重继承</h3><p>转发过程可以模拟继承，可以被借用于在 Objective-C 程序中实现一些多重继承的效果。如图 Figure 5-1 所示，对象通过消息转发来实现借用或”继承”其他类中的实现方法来响应消息。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif"></p>
<p>上图中，<code>Warrior</code>类的实例对象将<code>negotiate</code>消息转发给<code>Diplomat</code>类的实例对象。这个勇士就会像外交官一样来谈判，勇士对象似乎可以响应<code>negotiate</code>消息，而且实际上也确实响应了，即使大部分工作是由外交官对象来完成的。</p>
<p>对象通过转发消息来实现从两个不同的继承链分支（自己的继承链和响应消息的对象的继承链）<code>继承</code>，在上面的例子中，<code>Warrior</code>类似乎同时继承了它的父类和<code>Diplomat</code>类。</p>
<p>消息转发提供了你想从多重继承获取的大部分特性，但是两者还有很大区别：多重继承将不同的能力集成与同一对象上，它倾向于实现庞大的多功能的对象。而消息转发会把不同的任务分派给不同的对象,会将问题分拆给小的对象，但是又将这些对象连接起来，使得从消息发送者的角度来看这一切都是透明的。</p>
<h3 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h3><p>消息转发不仅模仿多重继承，还使得开发轻量级的对象来代表或者“隐藏”其他背后的对象，代理对象作为其他对象的替身将消息过滤给他们。</p>
<p>在《The Objective-C Programming Language》中“Remote Messaging”中讨论的代理就是这样一种代理方式。代理负责将消息转发给一个远程对象(译注：位于不同的地址空间)的各种事务，保证通过这种连接，参数可以被拷贝和取回，它不会做过多的事情，它不会复制远程对象的功能，而是仅仅为它提供一个本地地址，使得存在于另一个应用中的远程对象可以接收到消息。（译注：这一部分不熟悉的话可以去<a target="_blank" rel="noopener" href="http://cagt.bu.edu/w/images/b/b6/Objective-C_Programming_Language.pdf">The Objective-C 2.0 Programming Language</a>看一下）</p>
<p>也可以实现其他类型的代理对象，举个例子，假设你有一个要操控很多数据的对象-或许它创建了一个复杂的图片或者读取了磁盘中的文件，创建这个对象会很耗时，所以你倾向于惰性的设置它-即当你真正需要时或者系统资源空闲时。同时你需要一个占位的对象来使得应用中的其他对象正常运行。</p>
<p>在这种情况下，你可以在最初创建一个轻量级的代理对象而不是成熟的对象。这个对象可以完成一些简单的功能，如回答关于数据的问题等，但是主要还是用于为大对象占位置，当时机来临时将消息转发给它。当代理对象的<code>forwardInvocation:</code>消息收到发给其他对象的消息时，它要保证那个对象存在，如果不存在的话就创建一个。大对象的所有消息都通过代理对象。所以对于程序的其他部分来说，代理对象和大对象是相同的。</p>
<h3 id="转发和继承"><a href="#转发和继承" class="headerlink" title="转发和继承"></a>转发和继承</h3><p>尽管转发可以模仿继承，但是<code>NSObject</code>类并不会混淆他们。像<code>respondToSelector:</code>和<code>isKindOfClass:</code>这样的消息就只会在继承链中查找，绝不会去转发链中查找。举个例子：如果勇士对象被问到是否会响应<code>negotiate</code>消息时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>返回值永远是 <code>NO</code>，即使在某种意义上它可以通过转发给外交官对象来无错误的接收并响应<code>negotiate</code>消息。</p>
<p>大多数情况下 <code>NO</code>都是正确的答案，但不总是。如果你使用消息转发来创建一个代理对象或者扩展你类的能力。转发机制应该像继承一样是透明的。如果想要你的对象真的像继承了要转发到的对象的行为时，你需要重写一下<code>respondToSelector:</code>和<code>isKindOfClass:</code>方法将你的转发机制考虑在内。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [<span class="variable language_">super</span> respondsToSelector:aSelector] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Here, test whether the aSelector message can     *</span></span><br><span class="line"><span class="comment">         * be forwarded to another object and whether that  *</span></span><br><span class="line"><span class="comment">         * object can respond to it. Return YES if it can.  */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>respondToSelector:</code>和<code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>方法也需要反映转发机制。如果使用了协议，<code>conformToProtocol:</code>方法也需要添加进需要重写方法的列表中。相似的，如果对象转发了它收到的远程消息，它应该实现能返回最终响应转发来的消息的方法的确切描述的<code>methodSignatureForSelector:</code>方法。举个例子：如果对象能转发消息给它的代理对象，你要像下面这样实现<code>methodSignatureForSelector:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="variable language_">super</span> methodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">       signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以将这些有转发机制有关的方法都整理在一起，当有转发消息的时候就调用它。</p>
<blockquote>
<p>注：这是个用于其他方法都不能解决的问题的高级技巧，它并不打算替代继承，如果要使用这个技巧，确保你完全了解转发消息的类和接收转发消息的类的行为。</p>
</blockquote>
<p>这一部分提到的方法在<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/nsobject?language=objc"><code>NSObject</code></a>文档中可以查阅，可以查询<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsinvocation?language=occ"><code>NSInvocation</code></a>文档来获取<code>invokeWithTarget:</code>方法的相关信息。</p>
<h2 id="类型编码"><a href="#类型编码" class="headerlink" title="类型编码"></a>类型编码</h2><p>为协助运行时系统，编译器会将每个方法中的返回值和参数的类型编码成字符串并且和方法选择器联系起来。这种编码方案在其他上下文中也很有用所以通过<code>@encode()</code>编译器指令将其公开化了。给一个特定类型，<code>@encode()</code>会返回一个编码了这个类型的字符串。类型可以是<code>int</code>，指针,有标签的结构体或联合这样的基础类型，或者一个类名，或者任何类型。这个指令可以像 C 中的<code>sizeof()</code>操作符一样用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf1 = <span class="keyword">@encode</span>(<span class="type">int</span> **);</span><br><span class="line"><span class="type">char</span> *buf2 = <span class="keyword">@encode</span>(<span class="keyword">struct</span> key);</span><br><span class="line"><span class="type">char</span> *buf3 = <span class="keyword">@encode</span>(Rectangle);</span><br></pre></td></tr></table></figure>
<p>下表列出了各种类型编码，注意它们中很多会与你编码对象来归档或者分发时的编码重复，但是还有一些编码是你在写一个编码器时不能使用的，还有一些当你为不使用<code>@encode()</code>指令编写一个编码器想使用的编码。（查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nscoder?language=objc">NSCoder</a>类获取更多关于编码对象来归档和分发的信息。）</p>
<p>Table 6-1  Objective-C 类型编码</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">语义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">A char</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">An int</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">A short</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">A long ,l is treated as a 32-bit quantity on 64-bit programs.</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">A long long</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">An unsigned char</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">An unsigned int</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">An unsigned short</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">An unsigned long</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">An unsigned long long</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">A float</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">A double</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">A C++ bool or a C99 _Bool</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">A void</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">A character string (char *)</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">An object (whether statically typed or typed id)</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">A class object (Class)</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">A method selector (SEL)</td>
</tr>
<tr>
<td align="center">[array type]</td>
<td align="center">An array</td>
</tr>
<tr>
<td align="center">{name&#x3D;type…}</td>
<td align="center">A structure</td>
</tr>
<tr>
<td align="center">(name&#x3D;type…)</td>
<td align="center">A union</td>
</tr>
<tr>
<td align="center">bnum</td>
<td align="center">A bit field of num bits</td>
</tr>
<tr>
<td align="center">^type</td>
<td align="center">A pointer to type</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">An unknown type (among other things, this code is used for function pointers)</td>
</tr>
</tbody></table>
<blockquote>
<p>重要：Objective-C 不支持<code>long double</code>类型,<code>@encode(long double)</code>返回<code>d</code>，跟<code>double</code>使用同样的编码。</p>
</blockquote>
<p>数组的类型编码是包裹在方括号中的；左方括号后紧跟数组中的元素个数，然后是数组类型。例如一个有12个指向<code>floats</code>的指针的数组会被编码成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>^f]</span><br></pre></td></tr></table></figure>
<p>结构体的类型编码被包裹在花括号中，联合被包裹在括号中，结构体编码中先写出标签，然后按顺序列出结构体中的成员的类型，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> example &#123;</span><br><span class="line">    <span class="type">id</span>   anObject;</span><br><span class="line">    <span class="type">char</span> *aString;</span><br><span class="line">    <span class="type">int</span>  anInt;</span><br><span class="line">&#125; Example;</span><br></pre></td></tr></table></figure>
<p>会被编码成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;example=@*i&#125;</span><br></pre></td></tr></table></figure>
<p>不论传入<code>@encode()</code>的是结构体定义的类型名（<code>Example</code>）还是结构体的标签名（<code>example</code>），编码都会返回同样的结果。对于指向结构体的指针来说编码也会携带同样的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;example=@*i&#125;</span><br></pre></td></tr></table></figure>
<p>然而多加一层间接寻址（译注：指针的指针）就会去掉类型的内部信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^^&#123;example&#125;</span><br></pre></td></tr></table></figure>
<p>对象也会被当做结构体看待，例如将<code>NSObject</code>类名传给<code>@encode()</code>会产生如下编码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">NSObject</span>=#&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSObject</code>类只声明了一个实例变量，一个 <code>Class</code>类型的<code>isa</code>变量。</p>
<p>(译注：尝试如下所示)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="built_in">NSObject</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="type">id</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="built_in">NSObject</span> *));</span><br><span class="line"><span class="comment">//打印结果为：</span></span><br><span class="line"><span class="comment">//&#123;NSObject=#&#125;</span></span><br><span class="line"><span class="comment">//@</span></span><br><span class="line"><span class="comment">//@    </span></span><br></pre></td></tr></table></figure>
<p>注意当在协议中声明方法中有类型限定符时，<code>@encode()</code>指令并不会返回他们，但是运行时系统会使用下表中的额外的编码。</p>
<p>Table 6-1  Objective-C 方法编码</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">语义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">const</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">in</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">inout</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">out</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">bycopy</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">byref</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">oneway</td>
</tr>
</tbody></table>
<h2 id="已声明的属性"><a href="#已声明的属性" class="headerlink" title="已声明的属性"></a>已声明的属性</h2><p>当编译器碰到属性声明时（在 The Objective-C Programming Language 的 Declared Properties 章节描述），会生成与封装它的类、分类或者协议相关的描述性的元数据。你可以使用能够通过名字在类或协议中查询属性的函数，获取属性的类型作为一个<code>@encode</code>字符串的函数或者可以拷贝属性特征列表为一个 C 字符串数组的函数来访问这些元数据。每一个类和协议都有一串的已声明的属性可以使用。</p>
<h3 id="属性类型和函数"><a href="#属性类型和函数" class="headerlink" title="属性类型和函数"></a>属性类型和函数</h3><p><code>Property</code>结构体为 property 描述符提供了一个不透明的处理。</p>
<p>你可以使用函数<code>class_copyPropertyList</code>和<code>protocol_copyPropertyList</code>来分别获取类（包含以及加载的分类）和协议相关联的属性的数组。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="type">unsigned</span> <span class="type">int</span> *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="type">unsigned</span> <span class="type">int</span> *outCount)</span><br></pre></td></tr></table></figure>
<p>例如给定如下的类的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> <span class="type">float</span> alone;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>你可以像这样获取属性列表：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> LenderClass = objc_getClass(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> outCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>property_getName</code>函数来找到属性的名字。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span> *property_getName(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>class_getProperty</code>和<code>protocol_getProperty</code>函数用属性的名字分别从类和协议中获取相应的属性的引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="type">char</span> *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="type">char</span> *name, <span class="type">BOOL</span> isRequiredProperty, <span class="type">BOOL</span> isInstanceProperty)</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>property_getAttributes</code>函数来查找一个属性的名字和<code>@encode</code>编码类型的字符串。查看类型编码一章和下面的内容来获取更多类型编码字符串相关的信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>将这些代码组合在一起，你就可以打印和这个类相关的属性的列表了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> LenderClass = objc_getClass(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    fprintf(stdout, <span class="string">&quot;%s %s\n&quot;</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//译注：打印结果：</span></span><br><span class="line"><span class="comment">//alone Tf,V_alone</span></span><br></pre></td></tr></table></figure>
<h3 id="属性类型字符串"><a href="#属性类型字符串" class="headerlink" title="属性类型字符串"></a>属性类型字符串</h3><p>你可以使用<code>property_getAttributes</code>函数来查找一个属性的名字和<code>@encode</code>编码类型的字符串以及其他特性。</p>
<p>这个字符串以<code>T</code>开头，紧跟着<code>@encode</code>编码类型的字符串和一个逗号,以<code>V</code>后面跟着属性背后的实例变量的名字结束，中间是以逗号隔开的各种特性的描述符，如下表所示：</p>
<p>Table 7-1  已声明的属性类型编码</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">语义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R</td>
<td align="center">The property is read-only (readonly).</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">The property is a copy of the value last assigned (copy).</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">The property is a reference to the value last assigned (retain).</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">The property is non-atomic (nonatomic).</td>
</tr>
<tr>
<td align="center">G<name></td>
<td align="center">The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).</td>
</tr>
<tr>
<td align="center">S<name></td>
<td align="center">The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">The property is dynamic (@dynamic).</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">The property is a weak reference (__weak).</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">The property is eligible for garbage collection.</td>
</tr>
<tr>
<td align="center">t<encoding></td>
<td align="center">Specifies the type using old-style encoding.</td>
</tr>
</tbody></table>
<h3 id="属性特性描述示例"><a href="#属性特性描述示例" class="headerlink" title="属性特性描述示例"></a>属性特性描述示例</h3><p>给定下面的定义:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FooManChu &#123; FOO, MAN, CHU &#125;;</span><br><span class="line"><span class="keyword">struct</span> YorkshireTeaStruct &#123; <span class="type">int</span> pot; <span class="type">char</span> lady; &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> YorkshireTeaStruct YorkshireTeaStructType;</span><br><span class="line"><span class="keyword">union</span> MoneyUnion &#123; <span class="type">float</span> alone; <span class="type">double</span> down; &#125;;</span><br></pre></td></tr></table></figure>
<p>下表展示了属性声明及相应的由<code>property_getAttributes:</code>函数返回的字符串：</p>
<table>
<thead>
<tr>
<th align="center">属性声明</th>
<th align="center">属性描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@property char charDefault;</td>
<td align="center">Tc,VcharDefault</td>
</tr>
<tr>
<td align="center">@property double doubleDefault;</td>
<td align="center">Td,VdoubleDefault</td>
</tr>
<tr>
<td align="center">@property enum FooManChu enumDefault;</td>
<td align="center">Ti,VenumDefault</td>
</tr>
<tr>
<td align="center">@property float floatDefault;</td>
<td align="center">Tf,VfloatDefault</td>
</tr>
<tr>
<td align="center">@property int intDefault;</td>
<td align="center">Ti,VintDefault</td>
</tr>
<tr>
<td align="center">@property long longDefault;</td>
<td align="center">Tl,VlongDefault</td>
</tr>
<tr>
<td align="center">@property short shortDefault;</td>
<td align="center">Ts,VshortDefault</td>
</tr>
<tr>
<td align="center">@property signed signedDefault;</td>
<td align="center">Ti,VsignedDefault</td>
</tr>
<tr>
<td align="center">@property struct YorkshireTeaStruct structDefault;</td>
<td align="center">T{YorkshireTeaStruct&#x3D;”pot”i”lady”c},VstructDefault</td>
</tr>
<tr>
<td align="center">@property YorkshireTeaStructType typedefDefault;</td>
<td align="center">T{YorkshireTeaStruct&#x3D;”pot”i”lady”c},VtypedefDefault</td>
</tr>
<tr>
<td align="center">@property union MoneyUnion unionDefault;</td>
<td align="center">T(MoneyUnion&#x3D;”alone”f”down”d),VunionDefault</td>
</tr>
<tr>
<td align="center">@property unsigned unsignedDefault;</td>
<td align="center">TI,VunsignedDefault</td>
</tr>
<tr>
<td align="center">@property int (*functionPointerDefault)(char *);</td>
<td align="center">T^?,VfunctionPointerDefault</td>
</tr>
<tr>
<td align="center">@property id idDefault;Note: the compiler warns: “no ‘assign’, ‘retain’, or ‘copy’ attribute is specified - ‘assign’ is assumed”</td>
<td align="center">T@,VidDefault</td>
</tr>
<tr>
<td align="center">@property int *intPointer;</td>
<td align="center">T^i,VintPointer</td>
</tr>
<tr>
<td align="center">@property void *voidPointerDefault;</td>
<td align="center">T^v,VvoidPointerDefault</td>
</tr>
<tr>
<td align="center">@property int intSynthEquals;</td>
<td align="center">In the implementation block:</td>
</tr>
<tr>
<td align="center">@synthesize intSynthEquals&#x3D;_intSynthEquals;</td>
<td align="center">Ti,V_intSynthEquals</td>
</tr>
<tr>
<td align="center">@property(getter&#x3D;intGetFoo, setter&#x3D;intSetFoo:) int intSetterGetter;</td>
<td align="center">Ti,GintGetFoo,SintSetFoo:,VintSetterGetter</td>
</tr>
<tr>
<td align="center">@property(readonly) int intReadonly;</td>
<td align="center">Ti,R,VintReadonly</td>
</tr>
<tr>
<td align="center">@property(getter&#x3D;isIntReadOnlyGetter, readonly) int intReadonlyGetter;</td>
<td align="center">Ti,R,GisIntReadOnlyGetter</td>
</tr>
<tr>
<td align="center">@property(readwrite) int intReadwrite;</td>
<td align="center">Ti,VintReadwrite</td>
</tr>
<tr>
<td align="center">@property(assign) int intAssign;</td>
<td align="center">Ti,VintAssign</td>
</tr>
<tr>
<td align="center">@property(retain) id idRetain;</td>
<td align="center">T@,&amp;,VidRetain</td>
</tr>
<tr>
<td align="center">@property(copy) id idCopy;</td>
<td align="center">T@,C,VidCopy</td>
</tr>
<tr>
<td align="center">@property(nonatomic) int intNonatomic;</td>
<td align="center">Ti,VintNonatomic</td>
</tr>
<tr>
<td align="center">@property(nonatomic, readonly, copy) id idReadonlyCopyNonatomic;</td>
<td align="center">T@,R,C,VidReadonlyCopyNonatomic</td>
</tr>
<tr>
<td align="center">@property(nonatomic, readonly, retain) id idReadonlyRetainNonatomic;</td>
<td align="center">T@,R,&amp;,VidReadonlyRetainNonatomic</td>
</tr>
</tbody></table>
<h2 id="修正历史"><a href="#修正历史" class="headerlink" title="修正历史"></a>修正历史</h2><p>下表列出了Objective-C Runtime Programming Guide 的修改历史。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">记录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2009-10-19</td>
<td align="center">Made minor editorial changes.</td>
</tr>
<tr>
<td align="center">2009-07-14</td>
<td align="center">Completed list of types described by property_getAttributes.</td>
</tr>
<tr>
<td align="center">2009-02-04</td>
<td align="center">Corrected typographical errors.</td>
</tr>
<tr>
<td align="center">2008-11-19</td>
<td align="center">New document that describes the Objective-C 2.0 runtime support library.</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/15/Block%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/Block%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Block 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 10:36:38" itemprop="dateCreated datePublished" datetime="2021-09-15T10:36:38+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-15 14:41:17" itemprop="dateModified" datetime="2023-09-15T14:41:17+08:00">2023-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">iOS 笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h1><p>Blocks 是 C 语言的扩展功能，是带有<strong>自动变量（局部变量）</strong>的<strong>匿名函数</strong>。这一概念在其他程序语言中也称为闭包（Closure）、Lambda等。<br>C 语言标准不允许不带有名称的函数，想要不通过函数名来调用函数可以如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> (*funcptr)(<span class="type">int</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> result = (*funcptr)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>但是其实在赋值函数指针时，还是用到了函数的名称。</p>
<p>C语言的函数中使用的变量有一下几种：</p>
<ul>
<li>函数的参数 - 存储在栈中</li>
<li>自动变量（局部变量）- 存储在栈中</li>
<li>静态变量（静态局部变量）- 作用域与局部变量相同，但是改变了存储方式，从而改变了生存周期</li>
<li>全局变量</li>
<li>静态全局变量 - 与全局变量一样是静态存储方式，但是将其作用域限制在了定义该变量的源文件内</li>
</ul>
<p><img src="/images/%E5%A0%86%E6%A0%88.png" alt="进程在虚拟内存中的结构"></p>
<p>能够在函数的多次调用中传递值的变量有：静态局部变量、静态全局变量和全局变量，这几种变量虽然作用域不同，但是在整个程序中，一个变量总是保持在一个内存区域中，函数对其多次访问也是访问同一个值。</p>
<p><strong>Blocks</strong> 提供了类似 C++ 和 Objective-C 类生成实例或对象来保持变量值的方法，它保持局部变量的值。同时避免了声明类的大量代码，也没有使用静态变量、静态全局变量或全局变量时，访问的总是同一个值的问题。</p>
<h2 id="Blocks的语法"><a href="#Blocks的语法" class="headerlink" title="Blocks的语法"></a>Blocks的语法</h2><p>我们看一个简单的Block的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="type">int</span> (<span class="type">int</span> count)&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其实它与一般的C语言函数只有两点不同：1、返回值类型前面带有”^”符合，2、返回值类型后面没有函数名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testFunc</span> <span class="params">(<span class="type">int</span> count)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>我们在通常使用中会省略Block的返回值类型，所以上面的表达式通常写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="type">int</span> count)&#123; </span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>在省略返会在类型时，如果表达式中没有<code>return</code>语句，就使用<code>void</code>类型，有<code>return</code>语句就使用该返回值的类型，若有多个<code>return</code>语句，那么所有的语句返回值类型应该相同。<br>如果不使用参数的话，参数列表也可以省略。</p>
<h3 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h3><p>在 Block 语法下，可将 Block 语法赋值给声明为 Block 类型的变量中。即源代码中一旦使用 Block 语法就相当于生成了可赋值给 Block 类型变量的“值”。Block 类型变量完全可以与一般的 C 语言变量一样使用。<br>我们将上文中的 Block 赋值给 Block 类型的变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (^blk)(<span class="type">int</span>) = ^(<span class="type">int</span> count)&#123;<span class="keyword">return</span> count + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>但是在函数参数或返回值中使用 Block 类型变量时，记述起来很复杂，因此常用 typedef 来解决：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> (^blk_t)(<span class="type">int</span>);</span><br><span class="line">blk_t blk = ^(<span class="type">int</span> count)&#123;<span class="keyword">return</span> count + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Blocks的实现"><a href="#Blocks的实现" class="headerlink" title="Blocks的实现"></a>Blocks的实现</h2><h3 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h3><p><strong>Block的本质就是 C 语言结构体的实例，Block 就是 Objective-C 对象。</strong><br>Block 的语法看上去很特别，但实际上是作为普通的 C 语言源代码来处理的。我们可以用 clang 编译器的“clang -rewrite-objc 源代码文件名”指令将源代码转化为我们可读的源代码。</p>
<p>下面我们看如下这段代码转化为 C++ 源代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">&quot;Block\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;<span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Block结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;<span class="comment">//用于描述这个Block的附加信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Block构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;<span class="comment">//isa指针指向这个Block所属的类 _NSConcreteStackBlock</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Block使用的匿名函数其实被转化为简单的C的函数代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Block\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;<span class="comment">//为今后版本升级保留的区域</span></span><br><span class="line">  <span class="type">size_t</span> Block_size;<span class="comment">//Block的大小</span></span><br><span class="line"></span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block截获自动变量值"><a href="#Block截获自动变量值" class="headerlink" title="Block截获自动变量值"></a>Block截获自动变量值</h3><p>Block 是带有<strong>自动变量（局部变量）</strong>的<strong>匿名函数</strong>,”带有自动变量值”在 Block 中表现为截获 Block 中使用到的自动变量值。<br>我们看一个实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *fmt = <span class="string">&quot;var = %d\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(fmt,val);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed. var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    blk();<span class="comment">//打印出var = 10，因为Block保存了该自动变量的瞬间值，在执行Block后即使改变该自动变量值也不会影响Block执行时的自动变量值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt;  <span class="comment">//Block中访问的自动变量被作为成员变量追加到了Block结构体实例中</span></span><br><span class="line">  <span class="type">int</span> val;          <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">const</span> <span class="type">char</span> *_fmt, <span class="type">int</span> _val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">fmt</span>(_fmt), <span class="built_in">val</span>(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// Block实际执行的函数中访问的自动变量来自Block结构体实例</span></span><br><span class="line">  <span class="type">int</span> val = __cself-&gt;val; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(fmt,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dmy = <span class="number">256</span>;<span class="comment">//没有在Block中访问，所以没有被截获</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fmt = <span class="string">&quot;var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line"></span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed. var = %d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h3><p>实际上，自动变量值截获只能保存执行 Block 语法瞬间的值，保存后就不能在 Block 中改写该值。试图在 Block 中修改自动变量会导致编译错误。<br>如果我们要改变 Block 中截获的自动变量值，有以下两个方法：</p>
<ul>
<li>使用 static 修饰自动变量值将其变为静态变量，修改其存储域。</li>
<li>使用 __block 修饰符</li>
</ul>
<p>我们看一下下面的源代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> static_global_val = <span class="number">2</span>;<span class="comment">//全局静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> static_val = <span class="number">3</span>;<span class="comment">//静态变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        global_val *=<span class="number">1</span>;</span><br><span class="line">        static_global_val *=<span class="number">2</span>;</span><br><span class="line">        static_val *=<span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量与全局静态变量并没有被捕获到Block中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> *static_val;<span class="comment">//截获了静态变量的指针</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> *_static_val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">static_val</span>(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// 从结构体中获取该指针</span></span><br><span class="line"></span><br><span class="line">  global_val *=<span class="number">1</span>;<span class="comment">//对于全局变量和静态全局变量的访问与转换前完全相同</span></span><br><span class="line">  static_global_val *=<span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  (*static_val) *=<span class="number">3</span>;<span class="comment">//使用静态变量的指针对其进行访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对于静态变量，Block 会捕获其指针对其进行访问。这种方法似乎对于自动变量也可以，为什么不截获自动变量的指针呢？因为自动变量再其作用域结束时已经被废弃了，Block调用时再去通过指针访问会出错。</p>
<p>我们在来看看使用“__block存储域类说明符”的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main()&#123;</span><br><span class="line">    __block <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化后的 C++ 源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;<span class="comment">//被捕获的__block变量生成的结构体并不在Block用__main_block_impl_0结构体中，这样做是为了能再多个Block中使用同一个__block变量</span></span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="type">int</span> val;<span class="comment">//最初的自动变量变为了结构体中的实例变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// 结构体指针。__block将自动变量变成了栈上生成的结构体实例</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">val</span>(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// 获取结构体指针</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;<span class="comment">//通过__forwarding指针访问变量值</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;val, (<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="type">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="built_in">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*blk)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">0x22000000</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__block 说明符将自动变量变成了栈上生成的结构体实例 __Block_byref_val_0，且这个结构体的指针被 Block 结构体所捕获。被捕获的 __block变量生成的结构体并不在Block用__main_block_impl_0结构体中，这样做是为了能在多个Block中使用同一个 __block变量。<br>__Block_byref_val_0 结构体实例的成员变量 __forwarding 持有该结构体实例自身的指针，通过这个 __forwarding 指针访问成员变量 val。 如下图所示</p>
<p><img src="/images/%E8%AE%BF%E9%97%AE__block%E5%8F%98%E9%87%8F.jpg" alt="访问__block变量"></p>
<p>为什么要使用指向结构体自身的 __forwarding 指针来访问其val值呢？为什么 Block 作为返回值时可以超出其变量作用域而存在呢？<br>其实，Block 所属类有以下几种：</p>
<ul>
<li>__NSConcreteStackBlock –该类的对象分配在栈上</li>
<li>__NSConcreteGlobalBlock –该类的对象分配在.data区</li>
<li>__NSConcreteMallocBlock –该类的对象分配在堆中</li>
</ul>
<p>在记述全局变量的地方使用Block变量时，实际的Block对象类为 __NSConcreteGlobalBlock。还有一种情况当 Block 语法的表达式中不使用应截获的自动变量时，Block也是 __NSConcreteGlobalBlock 类对象。</p>
<p>Blocks提供了将 Block 和 __block 变量从栈上复制到堆上的方法来使 Block 可以超出其作用域而存在，这时候在堆上分配的 Block 就是 __NSConcreteMallocBlock 类对象。栈上的 Block 会在以下几种情况时复制到堆：</p>
<ul>
<li>调用Block的 copy 方法时（除以下3种情况时均推荐自己调用copy方法，防止Block被废弃）</li>
<li>Block作为函数返回值返回时</li>
<li>将Block赋值给附有 __strong修饰符 id 类型的类或Block类型成员变量时</li>
<li>在方法名中含有 usingBlock的Cocoa框架方法或者GCD的API中传递Block时</li>
</ul>
<p><img src="/images/%E5%A4%8D%E5%88%B6__block%E5%8F%98%E9%87%8F.png" alt="复制__block变量"></p>
<p>将 Block 复制到堆之后，栈上的Block 的 __forwarding 指针指向了堆上的Block,从而保证了任何时候都可以正确的访问到val值。</p>
<h3 id="Block截获对象"><a href="#Block截获对象" class="headerlink" title="Block截获对象"></a>Block截获对象</h3><p>如果Block捕获的自动变量是 Objective-C 对象,会是什么情况呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    blk = [^(<span class="type">id</span> object)&#123;</span><br><span class="line">        [array addObject:object];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;array count = %ld&quot;</span>,[array count]);</span><br><span class="line">        <span class="comment">//array = [NSMutableArray array];//不能给array重新赋值，因为捕获的是指向该对象的指针，而不是对象本身</span></span><br><span class="line">    &#125; <span class="keyword">copy</span>];<span class="comment">//调用copy方法将block复制到堆上，才会对截获的array调用retain方法，否则array会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 1</span></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 2</span></span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);<span class="comment">//打印array count = 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到在作用域结束后，array并没有没废弃，这个对象被Block截获，并且在Block复制到堆时对其进行了retain操作，从而持有了这个对象。<br>我们看看上面代码的 C++版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  id __strong array;<span class="comment">//截获的对象</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, id _array, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">    id __strong array = __cself-&gt;array;</span><br><span class="line">    [array addObject:obj]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;array count = %ld&quot;</span>,[array count]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//当block复制到堆时调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;array, (<span class="type">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<span class="comment">//相当于调用retain方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当堆上的block被废弃的时候调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="type">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<span class="comment">//相当于调用release方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">blk_t</span> blk;</span><br><span class="line">&#123;</span><br><span class="line">    id __strong array = [[NSMutalbleArray alloc] init];</span><br><span class="line">    blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">0x22000000</span>));</span><br><span class="line">    blk = [blk copy];</span><br><span class="line">&#125;</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk,[[NSObject alloc] init]);</span><br></pre></td></tr></table></figure>
<p>在OC中，C语言结构体不能含有__strong修饰符的变量，因为编译器不知道合适进行C语言结构体的初始化喝废弃操作，不能很好的管理内存，但是运行时库能准确把我 Block 从栈复制到堆以及堆上的Block被废弃的时机，因此Block结构体中可以含有附有 __strong或__weak修饰的变量。</p>
<h3 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h3><p>当我们想要在block中修改被捕获的对象时，可以用__block修饰，其代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="type">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]；<span class="comment">//obj默认是__strong</span></span><br></pre></td></tr></table></figure>

<p>该代码经过clang转换后的__block变量结构体部分如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_obj_0</span> &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_obj_0 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="built_in">void</span> (*__Block_byref_id_object_copy)(<span class="type">void</span>*, <span class="type">void</span>*);<span class="comment">//如果__block对象变量从栈复制到堆时，使用_Block_object_assign函数</span></span><br><span class="line"> <span class="built_in">void</span> (*__Block_byref_id_object_dispose)(<span class="type">void</span>*);<span class="comment">//堆上的__block对象变量被废弃时，使用_Block_object_dispose函数</span></span><br><span class="line"> __strong id obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Block中使用__strong修饰符的对象类型自动变量的情况下，当Block从栈复制到堆时，使用__Block_object_assign函数，持有Block截获的对象。<br>需要特别注意的是如果对象是__weak修饰的，则不论是否有__block修饰，Block复制到堆时，均不持有该对象。</p>
<h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><p>在Block内部使用__strong修饰符的对象类型的自动变量时，当Block从栈复制到堆的时候，该对象就会被Block所持有。如果这个对象还同时持有Block的话，就容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>(^blk_t)(<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Person 类对象持有Block类型成员变量blk，init实例方法中Block语法使用了附有__strong修饰符的对象self，并且由于Block语法赋值在了成员变量blk中，因此该栈上生成的Block会复制到堆，从而持有self，导致了循环引用。<br>可以使用__weak修饰符打破循环：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> temp = <span class="keyword">self</span>;</span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,temp);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候也可以使用__block修饰符来打破循环：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    __block <span class="type">id</span> temp = <span class="keyword">self</span>;</span><br><span class="line">    blk_= ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>,temp);</span><br><span class="line">        temp = <span class="literal">nil</span>;<span class="comment">//需要再blk中将temp置空。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)execBlock &#123;</span><br><span class="line">    blk();<span class="comment">//保证blk被执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用__block来打破循环的话，需要再block中将对象置为nil，并且保证block执行来打破循环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Understanding%20JavaScript%20Bind%20()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Understanding%20JavaScript%20Bind%20()/" class="post-title-link" itemprop="url">【翻译】Understanding JavaScript Bind ()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-07 10:53:02" itemprop="dateCreated datePublished" datetime="2021-09-07T10:53:02+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-03 21:16:50" itemprop="dateModified" datetime="2023-08-03T21:16:50+08:00">2023-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">前端笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/#top">Understanding JavaScript Bind ()</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>稍微写多点儿 JS 的人应该都见过<code>var self = this</code>这种写法，它是为了解决在不同函数调用时，<code>this</code>所指向的上下文参数变化的问题，你可以通过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN this</a>这篇文章先了解一下 JS 中的<code>this</code>。下文提供了将函数与其想要的<code>this</code>绑定的方法，以下是翻译正文。</p>
<h1 id="理解-JS-中的-Bind"><a href="#理解-JS-中的-Bind" class="headerlink" title="理解 JS 中的 Bind()"></a>理解 JS 中的 Bind()</h1><p>当你初学 JavaScript 时你可能并不关心函数绑定的问题，但是当你需要一个在其他函数中保持<code>this</code>内容的解决方案时，你可能并没有意识到你真正需要的就是<code>Function.prototype.bind()</code>函数。</p>
<p>第一次遇到这个问题时，当你切换上下文时可能会将<code>this</code>赋值给一个可以引用的变量。大多数人会选择<code>self</code>，<code>_this</code>或<code>context</code>作为变量名，这种方法是可用的，并不会出错，但是还有一种更好、更优雅的方式。</p>
<p><a target="_blank" rel="noopener" href="https://twitter.com/jaffathecake/">Jake Archibald</a>发推讨论过捕获<code>this</code>的问题：</p>
<blockquote>
<p>Ohhhh I would do anything for scope, but I won’t do that &#x3D; this — Jake Archibald (@jaffathecake) February 20, 2013</p>
</blockquote>
<p>当<a target="_blank" rel="noopener" href="https://twitter.com/sindresorhus/">Sindre Sorhus</a>讨论这个问题时，答案已经很显然了：</p>
<blockquote>
<p>@benhowdle $this for jQuery, for plain JS i don’t, use .bind() — Sindre Sorhus (@sindresorhus) February 22, 2013</p>
</blockquote>
<p>但是我却忽略了好几个月。</p>
<h1 id="我们想要解决什么问题？"><a href="#我们想要解决什么问题？" class="headerlink" title="我们想要解决什么问题？"></a>我们想要解决什么问题？</h1><p>在下面的代码中，将上下文对象赋值给一个变量是情有可原的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">specialFunction</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">anotherSpecialFunction</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">getAsyncData</span>: <span class="keyword">function</span> (<span class="params">cb</span>) &#123;</span><br><span class="line">        <span class="title function_">cb</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAsyncData</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            that.<span class="title function_">specialFunction</span>();</span><br><span class="line">            that.<span class="title function_">anotherSpecialFunction</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure>
<p>如果我们在上面的代码中直接调用<code>this.specialFunction()</code>，那么就会看到如下的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Object [object global] has no method &#x27;specialFunction&#x27;</span><br></pre></td></tr></table></figure>
<p>我们需要持有<code>myObj</code>对象的上下文用于回调函数的调用，调用<code>that.specialFunction()</code>函数使我们持有上下文并且正确的执行我们的函数。但是使用<code>Function.prototype.bind()</code>是更优雅的方法。</p>
<p>我们写个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAsyncData</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">specialFunction</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">anotherSpecialFunction</span>();</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="上例中做了什么？"><a href="#上例中做了什么？" class="headerlink" title="上例中做了什么？"></a>上例中做了什么？</h1><p><code>.bing()</code>只是创建了一个新的函数，当它被调用时会将<code>this</code>关键字设置为之前提供的值。这样我们就可以向<code>.bind()</code>函数传入期望的上下文参数即<code>this</code>（在这里就是<code>myObj</code>），然后当回调函数执行时，<code>this</code>就引用了<code>myObj</code>对象。</p>
<p>如果你想看看<code>Function.prototype.bind()</code>这个函数内部是如何运行的，可以看下面这个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">scope</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(scope);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是个简单的用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> boundFunc = bar.<span class="title function_">bind</span>(foo);</span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>我们创建了一个新的函数，其执行时会将<code>this</code>设置为<code>foo</code>对象，而不是像例子中直接调用<code>bar()</code>时，<code>this</code>默认指向的全局对象。</p>
<h1 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h1><table>
<thead>
<tr>
<th align="center">浏览器</th>
<th align="center">支持的版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Chrome</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">Firefox(Gecko)</td>
<td align="center">4.2(2)</td>
</tr>
<tr>
<td align="center">Internet Explore0</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">11.60</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">5.1.4</td>
</tr>
</tbody></table>
<p>如上所示，在 Internet Explorer 8 及以下版本中并不支持<code>Function.prototype.bind()</code>函数，所以你需要一个备用方案。</p>
<p>幸好，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a>提供了一个可靠的备选方案，用于没有在本地实现<code>.bind()</code>方法的浏览器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="variable language_">this</span>,</span><br><span class="line">        fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">        fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">                                 ? <span class="variable language_">this</span></span><br><span class="line">                                 : oThis,</span><br><span class="line">                    aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用法范例"><a href="#用法范例" class="headerlink" title="用法范例"></a>用法范例</h1><p>我发现当学习东西时，不仅要透彻的学习它的概念，还要将它用在实践中。幸好，下面的几个例子可以用于你的代码中或者解决你的问题。</p>
<h2 id="点击事件处理"><a href="#点击事件处理" class="headerlink" title="点击事件处理"></a>点击事件处理</h2><p>通常用于记录点击事件（或者点击后执行一个动作），这时就需要将信息保存在一个对象中，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">updateCount</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可能会像下面这样添加点击事件处理，在其中调用<code>logger</code>对象的<code>updateCount()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    logger.<span class="title function_">updateCount</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是为使得<code>updateCount()</code>函数中的<code>this</code>关键字表示正确的值，我们需要创建一个并不必须的匿名函数。</p>
<p>可以像下面这样优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, logger.<span class="property">updateCount</span>.<span class="title function_">bind</span>(logger));</span><br></pre></td></tr></table></figure>
<p>我们可以使用方便的<code>.bind()</code>函数来创建一个新的函数，然后将作用域设置的绑定到<code>logger</code>对象。</p>
<h2 id="SetTimeout"><a href="#SetTimeout" class="headerlink" title="SetTimeout"></a>SetTimeout</h2><p>如果你尝试过模板引擎（例如Handlebars）或者某种 MV* 框架（如 Backbone.js）,你可能会碰到这样的问题：当你渲染模板时，在调用了渲染方法后，想要立即获取新的 DOM 节点可能就会出错。</p>
<p>假设我们再初始化一个 jQuery 插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myView = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;/* a template string containing our &lt;select /&gt; */&#x27;</span>,</span><br><span class="line">    <span class="attr">$el</span>: $(<span class="string">&#x27;#content&#x27;</span>),</span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">afterRender</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myView.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure>
<p>你可能会发现这段代码可以正常运行，但并不总是这样。问题就在这里，它产生了一种竞争的情况：有时候渲染先执行完成，有时候插件的初始化先执行完成。</p>
<p>有些人可能不知道，我们可以通过使用<code>setTimeout()</code>函数来解决问题。</p>
<p>像下面这样简单的修改下代码，使得我们可以在 DOM 节点展示完成后立马安全的初始化我们的 jQuery 插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">afterRender</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>然而，我们会看到找不到<code>.afterRender()</code>函数的报错信息。</p>
<p>是时候祭出我们的<code>.bind()</code>方法了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="attr">afterRender</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">find</span>(<span class="string">&#x27;select&#x27;</span>).<span class="title function_">myPlugin</span>();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">html</span>(<span class="variable language_">this</span>.<span class="title function_">template</span>());</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">afterRender</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>现在，我们的<code>afterRender()</code>函数就会执行在正确的上下文环境中了。</p>
<h2 id="整理通过-querySelectorAll-绑定的事件"><a href="#整理通过-querySelectorAll-绑定的事件" class="headerlink" title="整理通过 querySelectorAll 绑定的事件"></a>整理通过 querySelectorAll 绑定的事件</h2><p>自从添加了诸如<code>querySelector</code>,<code>querySelectorAll</code>和<code>classList</code>等有用的方法后，DOM API 提升了很多。</p>
<p>然而，到目前为止并没有一个原生的方法来对一个<code>NodeList</code>中的所有节点添加事件，因此我们还需要使用<code>Array.prototype</code>中的<code>forEach</code>方法来循环添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.klasses&#x27;</span>), <span class="keyword">function</span>(<span class="params">el</span>)&#123;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, someFunction);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用<code>.bind()</code>方法来优化一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundForEach = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>,</span><br><span class="line">    forEach = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(unboundForEach);</span><br><span class="line"></span><br><span class="line"><span class="title function_">forEach</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.klasses&#x27;</span>), <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, someFunction);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在我们有一个整齐的方法来循环我们的 DOM 节点了。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如你所见，JS 的<code>bind()</code>函数可以巧妙的用于各种用途或者代码的整理。期望你能在需要时将<code>.bind()</code>添加进你的代码中来驾驭<code>this</code>值转换的能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
