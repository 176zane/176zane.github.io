<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引言同事突然指着Runtime(objc4-723)的源码objc-private.h中下面这段，问我：“objc_object结构体中只有一个isa变量，那对象中的实例变量去哪了？” 123struct objc_object &amp;#123;   isa_t isa;&amp;#125; 一下子有点儿懵逼，印象中的对象的内存布局总是如下图所示：  声明一个RoundedRectangle类的实例对象变量，">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime 源码笔记：对象与类">
<meta property="og:url" content="http://yoursite.com/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/index.html">
<meta property="og:site_name" content="Deep Thought">
<meta property="og:description" content="引言同事突然指着Runtime(objc4-723)的源码objc-private.h中下面这段，问我：“objc_object结构体中只有一个isa变量，那对象中的实例变量去哪了？” 123struct objc_object &amp;#123;   isa_t isa;&amp;#125; 一下子有点儿懵逼，印象中的对象的内存布局总是如下图所示：  声明一个RoundedRectangle类的实例对象变量，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="http://yoursite.com/images/TaggedPointer.png">
<meta property="og:image" content="http://yoursite.com/images/TaggedPointer2.png">
<meta property="og:image" content="http://yoursite.com/images/objc-isa-class-diagram.png">
<meta property="og:image" content="http://yoursite.com/images/class_data_bits_t.png">
<meta property="og:image" content="http://yoursite.com/images/alloc.png">
<meta property="article:published_time" content="2022-07-04T08:28:36.000Z">
<meta property="article:modified_time" content="2023-08-02T16:03:23.165Z">
<meta property="article:author" content="姚七六">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Objective-C">
<meta property="article:tag" content="Foundation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png">

<link rel="canonical" href="http://yoursite.com/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Runtime 源码笔记：对象与类 | Deep Thought</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Deep Thought</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/04/Runtime%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.gif">
      <meta itemprop="name" content="姚七六">
      <meta itemprop="description" content="Life is short. Live your dream and wear your passion.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep Thought">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Runtime 源码笔记：对象与类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 16:28:36" itemprop="dateCreated datePublished" datetime="2022-07-04T16:28:36+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-03 00:03:23" itemprop="dateModified" datetime="2023-08-03T00:03:23+08:00">2023-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>同事突然指着<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime(objc4-723)的源码</a><code>objc-private.h</code>中下面这段，问我：“<code>objc_object</code>结构体中只有一个<code>isa</code>变量，那对象中的实例变量去哪了？”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">   <span class="type">isa_t</span> isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一下子有点儿懵逼，印象中的对象的内存布局总是如下图所示：</p>
<p><img src="/images/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="对象中实例变量的布局"></p>
<p>声明一个<code>RoundedRectangle</code>类的实例对象变量，该变量指向对象中继承自<code>NSObject</code>类的<code>isa</code>实例变量，<code>isa</code>后紧跟着继承自其父类<code>Shape</code>中的<code>fillColor</code>和<code>bounds</code>实例变量，之后是它自己的<code>radius</code>实例变量。</p>
<p>那么，这到底是怎么回事呢？</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>我们在最初学习 Objective-C 时知道，所有的对象都包含一个叫<code>isa</code>的变量，该变量是一个指向对象所属类的指针，其定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    Class isa;                              <span class="comment">//指向该类的 metaClass</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__                              <span class="comment">//以下在OBJC2（06年发布）版本后就废弃了</span></span></span><br><span class="line">    Class super_class;                      <span class="comment">//指向该类的父类，若该类为根类时为NULL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                       <span class="comment">//类名</span></span><br><span class="line">    <span class="type">long</span> version;                           <span class="comment">//类的版本信息</span></span><br><span class="line">    <span class="type">long</span> info;                              <span class="comment">//类信息，运行时使用个位标识，如普通类、元类</span></span><br><span class="line">    <span class="type">long</span> instance_size;                     <span class="comment">//类的实例变量大小（包含继承自父类的实例变量）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> *ivars;           <span class="comment">//类的成员变量地址列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_method_list</span> **methodLists;  <span class="comment">//类的方法地址列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_cache</span> *cache;               <span class="comment">//缓存的方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_protocol_list</span> *protocols;   <span class="comment">//遵循的协议列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>id</code>是一种特殊的类型，它能指代任意的 Objective-C 对象类型。对象是由<code>objc_object</code>结构体来定义的。其中包含一个<code>Class</code>类型的变量<code>isa</code>，<code>Class</code>是一个指向<code>objc_class</code>结构体的指针，在这个结构体中存放着类的“元数据”。</p>
<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>然而在处理器从32位迁移到64位后，对象指针扩大为64位的整数，为了使地址内存对齐，一些位将永远是零。出于节省内存和提高运行效率的目的，苹果爸爸在<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC 2013 Session 404</a>中提出了 Tagged Pointer 的概念，因此也修改了<code>objc_object</code>的定义。</p>
<p><img src="/images/TaggedPointer.png" alt="Tagged Pointer"></p>
<p><img src="/images/TaggedPointer2.png" alt="Tagged Pointer2"></p>
<p>当对象指针的最低有效位（LSB）为 1 时，则该指针为 Tagged Pointer。其实这个指针的值本质上已经不是指向对象的地址了，而是保存着对象数据的值类型的变量。所以它的内存并不存储在堆中，也不需要 malloc&#x2F;free。</p>
<p>我们再看一下<code>objc_object</code>的定义的变化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;    <span class="comment">//非 tagged pointer 对象获取其 Class 的函数</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>; <span class="comment">//tagged pointer 对象获取其 Class 的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=false*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initClassIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initProtocolIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initInstanceIsa</span><span class="params">(Class cls, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">changeIsa</span><span class="params">(Class newCls)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">//这里只提取了__x86_64__架构的结构体定义，其他如__arm64__等架构类似。</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>; <span class="comment">//标志位：0表示原生指针，1表示使用 taggedPointer 优化内存</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>; <span class="comment">//是否绑定过关联对象，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>; <span class="comment">//是否有析构函数，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">44</span>;<span class="comment">//所属类指针的非零位</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>; <span class="comment">//固定值0xd2，调试器用来分辨对象的</span></span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>; <span class="comment">//是否被 __weak 变量引用过，若没有可快速释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>; <span class="comment">//是否正在释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">//引用计数值是否过大</span></span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">8</span>; <span class="comment">//对象的引用计数值-1（若值为5，则对象引用计数为6）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::initIsa</span><span class="params">(Class cls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isTaggedPointer</span>()); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!DisableNonpointerIsa);</span><br><span class="line">        <span class="built_in">assert</span>(!cls-&gt;<span class="built_in">instancesRequireRawIsa</span>());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">isa_t</span> <span class="title">newisa</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//这里截取SUPPORT_INDEXED_ISA = 0 时的代码，查知只有在watchABI的环境下SUPPORT_INDEXED_ISA值才为1</span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (<span class="type">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isa</code>变量的类型由<code>Class</code>类型变为了<code>isa_t</code>的类型，这个类型是一个联合（<code>union</code>），在联合中，几个字段共用同一块内存，其长度为联合中最大字段的长度。在<code>initIsa</code>方法中，当不启用 Tagged Pointer 时，就直接使用类的指针为<code>isa.cls</code>赋值，它还是表示对象所属类的指针。当启用时，使用宏<code>ISA_MAGIC_VALUE</code>来初始化<code>isa.bits</code>,这样已经为结构体内的<code>magic</code>、<code>nonpointer</code>字段赋值了，然后根据函数参数设置<code>has_cxx_dtor</code>，将类的指针右移 3 位以消除用于内存对齐所补的 0，使用非 0 位来为<code>shiftcls</code>字段赋值。</p>
<h1 id="类与元类"><a href="#类与元类" class="headerlink" title="类与元类"></a>类与元类</h1><p>无论是否启用 Tagged Pointer，<code>isa</code>变量中都保存了对象所属类的信息。接下来我们看一下定义类的结构体<code>objc_class</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// 缓存指针和 vtable，加速方法调用</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t类型的结构体指针加 retain/release/alloc/dealloc 路径优化的标记位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code>是继承自<code>objc_object</code>的，因此类本质上也是对象，称为类对象。类对象中包含继承来的<code>isa</code>变量，与实例对象中<code>isa</code>变量“指向”对象的所属类类似（这里的指向指的是变量中保存了对象所属类的信息，可以通过此信息找到类，下文中均如此表述），类对象的<code>isa</code>指向该类的元类（metaclass）。这一点可以从创建类与元类的函数<code>objc_allocateClassPair</code>中看出：</p>
<h2 id="动态创建类与元类"><a href="#动态创建类与元类" class="headerlink" title="动态创建类与元类"></a>动态创建类与元类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="type">const</span> <span class="type">char</span> *name, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls, meta;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="type">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="comment">//检查类名是否已经存在，验证父类是否合格（已实现的构建完成的类或者创建根类时可为空）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getClass</span>(name)  ||  !<span class="built_in">verifySuperclass</span>(superclass, <span class="literal">true</span><span class="comment">/*rootOK*/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为类与元类开辟空间</span></span><br><span class="line">    cls  = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">    meta = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">    <span class="comment">//初始化类与元类</span></span><br><span class="line">    <span class="built_in">objc_initializeClassPair_internal</span>(superclass, name, cls, meta);</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本来不想贴这长串代码，但是细读对理解类的创建过程的有所理解</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">objc_initializeClassPair_internal</span><span class="params">(Class superclass, <span class="type">const</span> <span class="type">char</span> *name, Class cls, Class meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertWriting</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">class_ro_t</span> *cls_ro_w, *meta_ro_w;</span><br><span class="line">    <span class="comment">//分配class_rw_t和class_ro_t结构体空间</span></span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>((<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>));</span><br><span class="line">    meta-&gt;<span class="built_in">setData</span>((<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>));</span><br><span class="line">    cls_ro_w   = (<span class="type">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    meta_ro_w  = (<span class="type">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;ro = cls_ro_w;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;ro = meta_ro_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置class_rw_t结构体内基本信息</span></span><br><span class="line">    <span class="comment">//类已分配但未注册|class_rw_t-&gt;ro是class_ro_t在堆中的拷贝|class_t-&gt;data是class_rw_t不是class_ro_t|类已开始实现但未完成</span></span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;version = <span class="number">0</span>;</span><br><span class="line">    meta-&gt;<span class="built_in">data</span>()-&gt;version = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置cls_ro_t结构体内基本信息</span></span><br><span class="line">    cls_ro_w-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    meta_ro_w-&gt;flags = RO_META;<span class="comment">//元类</span></span><br><span class="line">    <span class="keyword">if</span> (!superclass) &#123;</span><br><span class="line">        cls_ro_w-&gt;flags |= RO_ROOT;<span class="comment">//根类</span></span><br><span class="line">        meta_ro_w-&gt;flags |= RO_ROOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (superclass) &#123;</span><br><span class="line">        <span class="comment">//设置cls_ro_t-&gt;instanceStart和cls_ro_t-&gt;instanceSize为父类的instanceSize</span></span><br><span class="line">        cls_ro_w-&gt;instanceStart = superclass-&gt;<span class="built_in">unalignedInstanceSize</span>();</span><br><span class="line">        meta_ro_w-&gt;instanceStart = superclass-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">unalignedInstanceSize</span>();</span><br><span class="line">        cls-&gt;<span class="built_in">setInstanceSize</span>(cls_ro_w-&gt;instanceStart);</span><br><span class="line">        meta-&gt;<span class="built_in">setInstanceSize</span>(meta_ro_w-&gt;instanceStart);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cls_ro_w-&gt;instanceStart = <span class="number">0</span>;</span><br><span class="line">        meta_ro_w-&gt;instanceStart = (<span class="type">uint32_t</span>)<span class="built_in">sizeof</span>(objc_class);</span><br><span class="line">        cls-&gt;<span class="built_in">setInstanceSize</span>((<span class="type">uint32_t</span>)<span class="built_in">sizeof</span>(id));  <span class="comment">// just an isa</span></span><br><span class="line">        meta-&gt;<span class="built_in">setInstanceSize</span>(meta_ro_w-&gt;instanceStart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置类名与元类名</span></span><br><span class="line">    cls_ro_w-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    meta_ro_w-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">//初始化储存属性内存管理特性的值</span></span><br><span class="line">    cls_ro_w-&gt;ivarLayout = &amp;UnsetLayout;<span class="comment">//记录__strong的实例变量</span></span><br><span class="line">    cls_ro_w-&gt;weakIvarLayout = &amp;UnsetLayout;<span class="comment">//记录__weak的实例变量</span></span><br><span class="line">    <span class="comment">//设置元类与类的索引</span></span><br><span class="line">    meta-&gt;<span class="built_in">chooseClassArrayIndex</span>();<span class="comment">//此处函数中逻辑只在 SUPPORT_INDEXED_ISA = 1 时编译</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别为类与元类添加它们与父类和元类的联系</span></span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(meta);</span><br><span class="line">    <span class="keyword">if</span> (superclass) &#123;</span><br><span class="line">        meta-&gt;<span class="built_in">initClassIsa</span>(superclass-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        cls-&gt;superclass = superclass;</span><br><span class="line">        meta-&gt;superclass = superclass-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">        <span class="built_in">addSubclass</span>(superclass, cls);</span><br><span class="line">        <span class="built_in">addSubclass</span>(superclass-&gt;<span class="built_in">ISA</span>(), meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有父类，则该类为根类</span></span><br><span class="line">        meta-&gt;<span class="built_in">initClassIsa</span>(meta);<span class="comment">//根类的元类指向元类本身</span></span><br><span class="line">        cls-&gt;superclass = Nil;<span class="comment">//根类的父类为 Nil</span></span><br><span class="line">        meta-&gt;superclass = cls;<span class="comment">//根类的元类的父类指向根类</span></span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);</span><br><span class="line">        <span class="built_in">addSubclass</span>(cls, meta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化方法缓存列表为空</span></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmpty</span>();</span><br><span class="line">    meta-&gt;cache.<span class="built_in">initializeToEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>cls-&gt;initClassIsa(meta);</code>可以看出类对象<code>cls</code>确实使用元类对象<code>meta</code>初始化了它的<code>isa</code>变量。接下来的代码在该类有没有父类的情况下分别建立起了类与元类与他们各自父类与元类的联系。<code>superclass</code>指针确立了继承关系，<code>isa</code>描述了实例所属的类，通过这些联系建立起来了<strong>”类的继承体系”</strong>，如下图所示,通过这张布局关系图，我们可以查出对象能否响应某个选择子，是否遵从某项协议等，并且能够通过<code>isMemberOfClass</code>和<code>isKindOfClass</code>等类型信息查询方法来检视类的继承体系。</p>
<p><img src="/images/objc-isa-class-diagram.png" alt="objc-isa-class-diagram"></p>
<p>需要注意以下两点:</p>
<ol>
<li>所有的 metaclass 的<code>isa</code>都指向根类的元类，包括根元类！这样就形成了一个闭环。当向对象（类对象&#x2F;元类对象）发送消息时，runtime 会在对象所属的类的方法列表里面查找消息对应的方法，这样的闭环会保证这一步执行正确。</li>
<li>元类的父类指向类的父类的元类（绕口令啊(ノ ﾟДﾟ)ノ　┻━━┻），例外的是根类，根类的 <code>superclass</code>为 nil，根类的元类的<code>superclass</code>指向根类。当在对象所属类的方法列表中没有找到对应的方法时，runtime 会去类的父类中查找，如果找到了就跳转到方法的实现代码中，如果一路向上找到根类也没有找到时，runtime 的”消息传递机制”就结束了。接下来会启动“消息转发机制”，详情可查看这里：<a target="_blank" rel="noopener" href="https://176zane.github.io/2017/11/03/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Objective-C%20Runtime%20Programming%20Guide/">【翻译】Objective-C Runtime Programming Guide</a></li>
</ol>
<p>我们说类对象结构体<code>objc_class</code>中存放着类的“元数据”，例如类的实例实现了哪些方法，具备多少个实例变量及其布局等信息，而元类中保存了类对象本身所具备的元数据，“类方法”就定义在这里，因为这些方法可以理解成类对象的实例方法。<code>objc_class</code>结构体中的<code>isa</code>和<code>superclass</code>变量构建起了类的继承体系，接下来我们看看剩下的部分。</p>
<h2 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h2><p><code>objc_class</code>结构体中的<code>cache</code>字段主要用于缓存调用过的方法。当对象接收到消息时，runtime 根据<code>isa</code>去对象所属类的方法列表中查找，如果每次都经过这样的流程，方法调用的效率会比较差，因此在第一次调用过一个方法后，这个方法就会被缓存在<code>cache</code>中，下次接收到消息时会先在这里查找，没有才去方法列表中查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;  <span class="comment">//一个用于存储缓存方法的散列表</span></span><br><span class="line">    <span class="type">mask_t</span> _mask;               <span class="comment">//_mask+1 = 目前分配的用来缓存方法的 bucket 的总数</span></span><br><span class="line">    <span class="type">mask_t</span> _occupied;           <span class="comment">//目前实际占用的 bucket 数量</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">cache_key_t</span> _key;           <span class="comment">//方法选择子对应的 key</span></span><br><span class="line">    IMP _imp;                   <span class="comment">//方法实现的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h2><p><code>objc_class</code>结构体中的<code>bits</code>字段的注释为：”class_rw_t * plus custom rr&#x2F;alloc flags”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getBit</span><span class="params">(<span class="type">uintptr_t</span> bit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBit</span>(FAST_HAS_CXX_CTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个结构体中只有一个 64 位的值<code>bits</code>，该数据中保存了一个指向<code>class_rw_t</code>结构体的指针和是否为 swift 类、是否有默认的<code>retain/release</code>等方法及是否要求 raw isa 三个标志位。结构体中还提供了使用掩码来访问这些数据的方法（甚至还提供一些对<code>class_rw_t</code>结构体中<code>flags</code>字段的访问函数）。引用<a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a>文章中的配图可以看得更明白一些：<br><img src="/images/class_data_bits_t.png" alt="class_data_bits_t"></p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_data_bits_t</code>结构体中的<code>data()</code>方法返回了指向<code>class_rw_t</code>结构体的指针，这个结构体中保存了类的方法、属性和协议等信息。先看一下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">//标记信息</span></span><br><span class="line">    <span class="type">uint32_t</span> version;               <span class="comment">//类的版本信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;           <span class="comment">//编译期就确定的类信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;         <span class="comment">//方法列表</span></span><br><span class="line">    <span class="type">property_array_t</span> properties;    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;     <span class="comment">//协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;            <span class="comment">//首个子类</span></span><br><span class="line">    Class nextSiblingClass;         <span class="comment">//下一个兄弟类</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *demangledName;            <span class="comment">//取消名字修饰后的类名</span></span><br><span class="line">    <span class="comment">//省略 SUPPORT_INDEXED_ISA = 1 时的 index 字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code>中还包含一个与它类似的结构体<code>class_ro_t</code>的常量指针。从命名我们可以猜出<code>class_ro_t</code>中存储的是只读的信息，而<code>class_rw_t</code>中存储了可读写的信息。实际上也是如此，在<code>class_ro_t</code>中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议等信息，<code>class_rw_t</code>存储的内容是可以动态修改的，所以运行时对类的扩展大都存储在这里。先看下<code>class_ro_t</code>的定义：</p>
<h4 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;                     <span class="comment">//标记信息</span></span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;             <span class="comment">//类自己定义的实例变量的起始偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;              <span class="comment">//类的总的实例变量大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;                  <span class="comment">//保留的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;         <span class="comment">//__strong修饰的实例变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;                  <span class="comment">//类名</span></span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;     <span class="comment">//方法列表</span></span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;    <span class="comment">//协议列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;          <span class="comment">//实例变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;     <span class="comment">//__weak修饰的实例变量</span></span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;    <span class="comment">//属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的“创建新的类与元类”部分，我们看到在初始化类与元类的函数<code>objc_initializeClassPair_internal</code>中，开辟了<code>class_rw_t</code>和<code>class_ro_t</code>的存储空间，并将返回的指针保存在相应的数据中。接着对<code>class_rw_t</code>中的<code>flags</code>,<code>version</code>,<code>ro</code>字段进行了初始化，在<code>addSubclass(superclass, cls)</code>方法中又设置了自身的<code>nextSiblingClass</code>以及父类的<code>firstSubclass</code>。同时初始化了<code>class_ro_t</code>中的<code>flags</code>,<code>instanceStart</code>,<code>instanceSize</code>,<code>ivarLayout</code>,<code>weakIvarLayout</code>,<code>name</code>等字段（注意当存在父类时，本类的<code>instanceStart</code>与<code>instanceSize</code>都使用父类的<code>instanceSize</code>进行了初始化）。</p>
<p>我们上面不是说过<code>class_ro_t</code>结构体中的值是只读的嘛？为什么在这里对其中的变量进行了设置？而且如果你阅读过<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc">Objective-C Runtime函数列表</a>，就会发现<code>class_addIvar</code>这个函数也是在运行时通过修改类的<code>class_ro_t</code>中的字段，向类中添加了实例变量。</p>
<p>这是因为这些操作都是发生在动态构建类的过程中！<code>class_addIvar</code>的文档中有这么一段话：</p>
<blockquote>
<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.</p>
</blockquote>
<p>也就是说一旦完成类的构建过程，就不能再修改<code>class_ro_t</code>中的内容了，当然也就不能向其中添加实例变量了。<code>objc_registerClassPair</code>中做的事情就是将类的<code>class_rw_t</code>中的<code>flags</code>标记的<code>RW_CONSTRUCTING | RW_REALIZING</code>标志位清除，同时设置<code>RW_CONSTRUCTED</code>这个表示类已经构建完成的标志位。</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>在上面一部分，我们通过阅读创建类与元类的函数<code>objc_allocateClassPair</code>对动态创建类的过程有了一定的理解，并且认识了表示类的结构体及其初始化的过程。但是对于我们在源代码中编写的类，它的加载过程是怎样的呢？</p>
<p>我们编写的源代码在编译结束后链接的过程中就静态链接进程序的二进制文件中了，而程序中引入的系统库如”Foundation.framework”和包含 Runtime 的”libobjc.A.dylib”等则是通过苹果的动态链接器-dyld（the dynamic link editor）在程序启动时动态加载的。我们看一下 Runtime 的初始化入口方法<code>_objc_init</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();</span><br><span class="line">    <span class="built_in">tls_init</span>();</span><br><span class="line">    <span class="built_in">static_init</span>();</span><br><span class="line">    <span class="built_in">lock_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>();</span><br><span class="line">    <span class="comment">//注册dyld事件的回调函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数的最后注册了 dyld 相关事件的回调函数，当 ImageLoader 读取了 images(可执行文件或动态库等）并将其加载进内存后，dyld 会调用回调函数<code>map_images</code>对其进行解析和处理。接下来当需要对该 image 进行初始化时，dyld 就会调用回调函数<code>load_images</code>对其初始化。</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><p><code>map_images</code>中提取了 images 中 ObjC 相关的元数据（Class、Selector、Protocol等符号）进行了初始化，主要过程发生在<code>_read_images</code>函数中：</p>
<ol>
<li><p>针对包含有 swift 旧版本代码和对 sdk 版本在 OS X 10.11之前的进行<code>disableTaggedPointers</code>操作。</p>
</li>
<li><p>初始化一个全局的映射表<code>gdb_objc_realized_classes</code>用来存储没有在 dyld 共享缓存中优化过的 Classes，注意这个名字中的 realized 属于误用，其中存放的类也可以是未实现的状态。</p>
</li>
<li><p><code>readClass</code> : 将类与元类照编译器编译好的方式从二进制中读出来，然后将不重复的非元类插入到<code>gdb_objc_realized_classes</code>中，该函数的返回值有3中情况：</p>
<ul>
<li>cls:即类的指针，注意如果该类之前被 alloc 为未来实现的类则需要拷贝一个新类并将<code>rw</code>的类型<code>class_rw_t</code>强制转换为<code>class_ro_t</code>为<code>rw-&gt;ro</code> 赋值，设置新的<code>rw</code>并将其添加进 <code>remappedClasses</code>，注意这里的<code>newCls</code>就已经是<code>realized</code>的状态了。代码如下：</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line"><span class="built_in">memcpy</span>(newCls, cls, <span class="built_in">sizeof</span>(objc_class));</span><br><span class="line">rw-&gt;ro = (<span class="type">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line"><span class="built_in">freeIfMutable</span>((<span class="type">char</span> *)old_ro-&gt;name);</span><br><span class="line"><span class="built_in">free</span>((<span class="type">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line"><span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">replacing = cls;</span><br><span class="line">cls = newCls;</span><br></pre></td></tr></table></figure>
<ul>
<li>nil:当类没有父类或者当前父类是弱连接的，将这个类添加进需要重新映射的表后返回 nil.</li>
<li>something else: 指向保留的用于为未来实现的类开辟的空间.</li>
</ul>
</li>
<li><p>修正上一步中添加进<code>remappedClasses</code>的类，用已经实现的新类替换旧类的引用。</p>
</li>
<li><p>修正 selector 的引用。</p>
</li>
<li><p>读取 protocals 以及修正其引用。</p>
</li>
<li><p>对于实现了<code>+load</code>方法或者有静态实例的 non-lazy classes 执行<code>realizeClass</code>来实现它（注意对于 lazy classes 则是在其首次接收到消息时才实现它），返回类真实的数据结构使其处于可用的状态,关键代码如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 ro 替换为 rw，标记类为 已实现|实现中</span></span><br><span class="line">ro = (<span class="type">const</span> <span class="type">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">    <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">    rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    ro = cls-&gt;<span class="built_in">data</span>()-&gt;ro;</span><br><span class="line">    cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">    rw = (<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询是否为元类</span></span><br><span class="line">isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"><span class="comment">//设置version </span></span><br><span class="line">rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Choose an index for this class.</span></span><br><span class="line"><span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">cls-&gt;<span class="built_in">chooseClassArrayIndex</span>(); <span class="comment">//仅在watchABI下有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span></span><br><span class="line"><span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line"><span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line">supercls = <span class="built_in">realizeClass</span>(<span class="built_in">remapClass</span>(cls-&gt;superclass));</span><br><span class="line">metacls = <span class="built_in">realizeClass</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略SUPPORT_NONPOINTER_ISA时的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;superclass = supercls;</span><br><span class="line">cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line"><span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">    cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">    <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect this class to its superclass&#x27;s subclass lists</span></span><br><span class="line"><span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">    <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">addRootClass</span>(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach categories</span></span><br><span class="line"><span class="built_in">methodizeClass</span>(cls);</span><br><span class="line"><span class="keyword">return</span> cls;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在上面的<code>reconcileInstanceVariables</code>过程中，在<code>ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize</code>情况下即父类扩展了它的实例变量使得实例变量大小增大时，校准了<code>ro-&gt;instanceSize</code>，<code>ro-&gt;instanceStart</code>和<code>ivars</code>容器中每个<code>ivar-&gt;offset</code>指向的值以实现<code>non-fragile instance variables</code>的功能！</p>
<p> 在<code>methodizeClass</code>过程中将<code>ro-&gt;baseMethods()</code>,<code>ro-&gt;baseProperties</code>,<code>ro-&gt;baseProtocols</code>分别添加进<code>rw-&gt;methods</code>,<code>rw-&gt;properties</code>和<code>rw-&gt;protocols</code>容器列表中，然后将通过<code>unattachedCategoriesForClass</code>获取的未附加的分类附加在类上。</p>
</li>
<li><p>读取 Category ,然后通过<code>addUnattachedCategoryForClass</code>将分类注册到它的所属类上，之后调用<code>remethodizeClass</code>将实例方法、协议和属性添加到类上，将类方法添加到元类上。需要注意的是：1，Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个methodA；2，Category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会返回。</p>
</li>
</ol>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><p><code>load_images</code>方法就是调用<code>+load</code>方法，看一下<code>prepare_load_methods</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">classref_t</span> *classlist = </span><br><span class="line">    _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="type">category_t</span> *cat = categorylist[i];</span><br><span class="line">    Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">    <span class="built_in">realizeClass</span>(cls);</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数基本就是准备好实现了<code>+load</code>方法的类和分类，将其分别添加到 loadable_list 中。需要留意的是在<code>schedule_class_load</code>方法中会递归调用<code>schedule_class_load(cls-&gt;superclass)</code>,来保证先将父类添加进 loadable_list 中。</p>
<p>准备好后就调用了<code>call_load_methods</code>，关键代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">call_class_loads</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">&#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>类的<code>+load</code>方法是先于分类调用的！但是在类的<code>+load</code>方法中可以调用该类的分类中声明的方法，因为在此之前分类就已经 attach 到这个类上面了。</li>
<li><code>call_class_loads</code>从 loadable_list 中依次取出 class 然后调用<code>+load</code>，这里保证了父类优先调用的顺序！</li>
<li><code>+load</code>方法是直接使用函数内存地址的方式调用的：<code>(*load_method)(cls, SEL_load)</code>，它对于实现了<code>+load</code>方法的添加进 loadable_list 中的每个类与分类都会调用。因此这里成了极佳的<a target="_blank" rel="noopener" href="http://nshipster.cn/method-swizzling/">Method Swizzling</a>的时机。但是分类之间的<code>+load</code>执行顺序是按照编译顺序决定的，因此不同的编译顺序会导致分类间的<code>+load</code>顺序不固定。类的载入顺序不同也导致类之间<code>+load</code>方法执行顺序不固定。</li>
<li>如果代码还依赖了其他程序库，那么其他程序库里面的相关类的<code>+load</code>方法会先执行。</li>
<li>留意与<code>+load</code>类似的<code>+initialize</code>方法，可以执行类的初始化操作，不同的是调用这个方法时，运行时系统已经处于正常状态了，在这里可以调用任意类的任意方法。<code>+initialize</code>方法是惰性调用的，在程序首次使用类的时候才会调用一次它，这个方法是线程安全的，执行时会堵塞其他线程。还有与<code>+load</code>不同，<code>+initialize</code>遵循普通的继承与覆写规则，当类没有实现这个方法时，会调用其父类的实现。</li>
</ul>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>接下来简单看下对象的创建过程,我们通过调用<code>[[XXXClass alloc] init]</code>来生成一个实例对象。</p>
<h2 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h2><p>在代码<code>[[NSObject alloc] init]</code>中添加一个断点，查看一下调用栈：<br><img src="/images/alloc.png" alt="alloc"></p>
<p>初始化对象的关键代码都在<code>_class_createInstanceFromZone</code>方法中,抽取出一个主要流程的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//获取实例对象内存对齐后的大小</span></span><br><span class="line">    <span class="type">size_t</span> size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br><span class="line">    <span class="comment">//分配存储空间</span></span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="comment">//初始化isa,这部分代码我们再文章上面可以看到</span></span><br><span class="line">    obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>init</code>操作只是简单的返回了对象背身。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>看完了这些我们也能回答引言中提出的问题了：Objective-C对象不能简单对应于一个C struct，访问成员变量不等于访问C struct成员,当生成对象时，开辟出来对象的<code>instanceSize</code>大小的内存区域并返回指向该空间的指针，在这个内存空间中不仅包含了<code>objc_object</code>中定义的<code>isa</code>还有其他所有的实例变量（包括继承自父类的及其自己的），我们通常所说的类的实例对象也就指的是这块内存空间。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html">[objc explain]: Non-pointer isa</a></li>
<li><a target="_blank" rel="noopener" href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">[objc explain]: Classes and metaclasses</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></li>
<li><a target="_blank" rel="noopener" href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md">从 NSObject 的初始化了解 isa</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
              <a href="/tags/Foundation/" rel="tag"># Foundation</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/12/iOS%20%E5%B8%B8%E8%AF%BB%E5%B8%B8%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" rel="prev" title="iOS 常读常新的文章索引（持续更新）">
      <i class="fa fa-chevron-left"></i> iOS 常读常新的文章索引（持续更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/27/%5BWWDC%5DMastering%20Grand%20Central%20Dispatch/" rel="next" title="【WWDC】Mastering Grand Central Dispatch">
      【WWDC】Mastering Grand Central Dispatch <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">2.1.</span> <span class="nav-text">Tagged Pointer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">类与元类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">动态创建类与元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache-t"><span class="nav-number">3.2.</span> <span class="nav-text">cache_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class-data-bits-t"><span class="nav-number">3.3.</span> <span class="nav-text">class_data_bits_t</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#class-rw-t"><span class="nav-number">3.3.1.</span> <span class="nav-text">class_rw_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-ro-t"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">class_ro_t</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-images"><span class="nav-number">3.4.1.</span> <span class="nav-text">map_images</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load-images"><span class="nav-number">3.4.2.</span> <span class="nav-text">load_images</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">4.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#alloc"><span class="nav-number">4.1.</span> <span class="nav-text">alloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#init"><span class="nav-number">4.2.</span> <span class="nav-text">init</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">最后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚七六"
      src="/images/self.gif">
  <p class="site-author-name" itemprop="name">姚七六</p>
  <div class="site-description" itemprop="description">Life is short. Live your dream and wear your passion.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/176zane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:176zane@gmail.com" title="E-Mail → mailto:176zane@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/176zane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;176zane" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lovekobe0824" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;lovekobe0824" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚七六</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
